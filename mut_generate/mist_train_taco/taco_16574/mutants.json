{
  "task_id": "taco_16574",
  "entry_point": "minimum_ken_ken_pa",
  "mutant_count": 112,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 * 18",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 * 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 + 18",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 + 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 11 ** 18",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 11 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 9 ** 18",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 9 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 0 ** 18",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 0 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 1 ** 18",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 1 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = -10 ** 18",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = -10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 19",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 19\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 17",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 17\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 0",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 0\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 1",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 1\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** -18",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** -18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "used[s][0] = False",
      "mutated_line": "used[s][0] = True",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = True\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s + 1, t - 1, 3)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s + 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s * 1, t - 1, 3)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s * 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - 1, t + 1, 3)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t + 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - 1, t * 1, 3)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t * 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - 1, t - 1, 4)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 4)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - 1, t - 1, 2)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 2)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - 1, t - 1, 0)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 0)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - 1, t - 1, 1)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 1)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - 1, t - 1, -3)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, -3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans == INF else -1",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans == INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else +1",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else +1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edge[u - 1].append(v - 1)",
      "mutated_line": "edge[u - 1].append(v + 1)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v + 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edge[u - 1].append(v - 1)",
      "mutated_line": "edge[u - 1].append(v * 1)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v * 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "d = [[INF] * p for _ in range(n)]",
      "mutated_line": "d = [[INF] / p for _ in range(n)]",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] / p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "d = [[INF] * p for _ in range(n)]",
      "mutated_line": "d = [[INF] + p for _ in range(n)]",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] + p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "d = [[INF] * p for _ in range(n)]",
      "mutated_line": "d = [[INF] ** p for _ in range(n)]",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] ** p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "used = [[True] * p for _ in range(n)]",
      "mutated_line": "used = [[True] / p for _ in range(n)]",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] / p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "used = [[True] * p for _ in range(n)]",
      "mutated_line": "used = [[True] + p for _ in range(n)]",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] + p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "used = [[True] * p for _ in range(n)]",
      "mutated_line": "used = [[True] ** p for _ in range(n)]",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] ** p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "used[s][0] = False",
      "mutated_line": "used[s][1] = False",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][1] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "used[s][0] = False",
      "mutated_line": "used[s][-1] = False",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][-1] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "used[s][0] = False",
      "mutated_line": "used[s][1] = False",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][1] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "used[v][md] = False",
      "mutated_line": "used[v][md] = True",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = True\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return d[g][0]",
      "mutated_line": "return d[g][1]",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][1]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return d[g][0]",
      "mutated_line": "return d[g][-1]",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][-1]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return d[g][0]",
      "mutated_line": "return d[g][1]",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][1]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - 2, t - 1, 3)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 2, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - 0, t - 1, 3)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 0, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - 0, t - 1, 3)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 0, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - -1, t - 1, 3)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - -1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - 1, t - 2, 3)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 2, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - 1, t - 0, 3)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 0, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - 1, t - 0, 3)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 0, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = dijkstra_heap(s - 1, t - 1, 3)",
      "mutated_line": "ans = dijkstra_heap(s - 1, t - -1, 3)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - -1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else -2",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -2"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else -0",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else -0",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else --1",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else --1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[u - 1].append(v - 1)",
      "mutated_line": "edge[u - 1].append(v - 2)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 2)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[u - 1].append(v - 1)",
      "mutated_line": "edge[u - 1].append(v - 0)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 0)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[u - 1].append(v - 1)",
      "mutated_line": "edge[u - 1].append(v - 0)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 0)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[u - 1].append(v - 1)",
      "mutated_line": "edge[u - 1].append(v - -1)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - -1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edge[u - 1].append(v - 1)",
      "mutated_line": "edge[u + 1].append(v - 1)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u + 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edge[u - 1].append(v - 1)",
      "mutated_line": "edge[u * 1].append(v - 1)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u * 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "used = [[True] * p for _ in range(n)]",
      "mutated_line": "used = [[False] * p for _ in range(n)]",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[False] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(ed_list, [1, es, 1])",
      "mutated_line": "heapq.heappush(ed_list, [2, es, 1])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [2, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(ed_list, [1, es, 1])",
      "mutated_line": "heapq.heappush(ed_list, [0, es, 1])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [0, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(ed_list, [1, es, 1])",
      "mutated_line": "heapq.heappush(ed_list, [0, es, 1])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [0, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(ed_list, [1, es, 1])",
      "mutated_line": "heapq.heappush(ed_list, [-1, es, 1])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [-1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(ed_list, [1, es, 1])",
      "mutated_line": "heapq.heappush(ed_list, [1, es, 2])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 2])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(ed_list, [1, es, 1])",
      "mutated_line": "heapq.heappush(ed_list, [1, es, 0])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 0])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(ed_list, [1, es, 1])",
      "mutated_line": "heapq.heappush(ed_list, [1, es, 0])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 0])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "heapq.heappush(ed_list, [1, es, 1])",
      "mutated_line": "heapq.heappush(ed_list, [1, es, -1])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, -1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if not used[g][0]:",
      "mutated_line": "if not used[g][1]:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][1]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if not used[g][0]:",
      "mutated_line": "if not used[g][-1]:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][-1]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if not used[g][0]:",
      "mutated_line": "if not used[g][1]:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][1]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if used[e][(md + 1) % p]:",
      "mutated_line": "if used[e][(md + 1) * p]:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) * p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if used[e][(md + 1) % p]:",
      "mutated_line": "if used[e][md + 1 + p]:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][md + 1 + p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (md + 1) % p == 1:",
      "mutated_line": "if (md + 1) % p != 1:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p != 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[u - 1].append(v - 1)",
      "mutated_line": "edge[u - 2].append(v - 1)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 2].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[u - 1].append(v - 1)",
      "mutated_line": "edge[u - 0].append(v - 1)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 0].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[u - 1].append(v - 1)",
      "mutated_line": "edge[u - 0].append(v - 1)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 0].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[u - 1].append(v - 1)",
      "mutated_line": "edge[u - -1].append(v - 1)",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - -1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if used[e][(md + 1) % p]:",
      "mutated_line": "if used[e][(md - 1) % p]:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md - 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if used[e][(md + 1) % p]:",
      "mutated_line": "if used[e][md * 1 % p]:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][md * 1 % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (md + 1) % p == 1:",
      "mutated_line": "if (md + 1) * p == 1:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) * p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (md + 1) % p == 1:",
      "mutated_line": "if md + 1 + p == 1:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if md + 1 + p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (md + 1) % p == 1:",
      "mutated_line": "if (md + 1) % p == 2:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 2:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (md + 1) % p == 1:",
      "mutated_line": "if (md + 1) % p == 0:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 0:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (md + 1) % p == 1:",
      "mutated_line": "if (md + 1) % p == 0:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 0:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (md + 1) % p == 1:",
      "mutated_line": "if (md + 1) % p == -1:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == -1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if used[e][(md + 1) % p]:",
      "mutated_line": "if used[e][(md + 2) % p]:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 2) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if used[e][(md + 1) % p]:",
      "mutated_line": "if used[e][(md + 0) % p]:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 0) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if used[e][(md + 1) % p]:",
      "mutated_line": "if used[e][(md + 0) % p]:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 0) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if used[e][(md + 1) % p]:",
      "mutated_line": "if used[e][(md + -1) % p]:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + -1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (md + 1) % p == 1:",
      "mutated_line": "if (md - 1) % p == 1:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md - 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (md + 1) % p == 1:",
      "mutated_line": "if md * 1 % p == 1:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if md * 1 % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (md + 1) % p == 1:",
      "mutated_line": "if (md + 2) % p == 1:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 2) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (md + 1) % p == 1:",
      "mutated_line": "if (md + 0) % p == 1:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 0) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (md + 1) % p == 1:",
      "mutated_line": "if (md + 0) % p == 1:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 0) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (md + 1) % p == 1:",
      "mutated_line": "if (md + -1) % p == 1:",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + -1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(ed_list, [ken + 1, e, 1])",
      "mutated_line": "heapq.heappush(ed_list, [ken - 1, e, 1])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken - 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "heapq.heappush(ed_list, [ken + 1, e, 1])",
      "mutated_line": "heapq.heappush(ed_list, [ken * 1, e, 1])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken * 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "heapq.heappush(ed_list, [ken + 1, e, 1])",
      "mutated_line": "heapq.heappush(ed_list, [ken + 1, e, 2])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 2])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "heapq.heappush(ed_list, [ken + 1, e, 1])",
      "mutated_line": "heapq.heappush(ed_list, [ken + 1, e, 0])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 0])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "heapq.heappush(ed_list, [ken + 1, e, 1])",
      "mutated_line": "heapq.heappush(ed_list, [ken + 1, e, 0])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 0])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "heapq.heappush(ed_list, [ken + 1, e, 1])",
      "mutated_line": "heapq.heappush(ed_list, [ken + 1, e, -1])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, -1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "heapq.heappush(ed_list, [ken, e, (md + 1) % p])",
      "mutated_line": "heapq.heappush(ed_list, [ken, e, (md + 1) * p])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) * p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "heapq.heappush(ed_list, [ken, e, (md + 1) % p])",
      "mutated_line": "heapq.heappush(ed_list, [ken, e, md + 1 + p])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, md + 1 + p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "heapq.heappush(ed_list, [ken + 1, e, 1])",
      "mutated_line": "heapq.heappush(ed_list, [ken + 2, e, 1])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 2, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "heapq.heappush(ed_list, [ken + 1, e, 1])",
      "mutated_line": "heapq.heappush(ed_list, [ken + 0, e, 1])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 0, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "heapq.heappush(ed_list, [ken + 1, e, 1])",
      "mutated_line": "heapq.heappush(ed_list, [ken + 0, e, 1])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 0, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "heapq.heappush(ed_list, [ken + 1, e, 1])",
      "mutated_line": "heapq.heappush(ed_list, [ken + -1, e, 1])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + -1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "heapq.heappush(ed_list, [ken, e, (md + 1) % p])",
      "mutated_line": "heapq.heappush(ed_list, [ken, e, (md - 1) % p])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md - 1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "heapq.heappush(ed_list, [ken, e, (md + 1) % p])",
      "mutated_line": "heapq.heappush(ed_list, [ken, e, md * 1 % p])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, md * 1 % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(ed_list, [ken, e, (md + 1) % p])",
      "mutated_line": "heapq.heappush(ed_list, [ken, e, (md + 2) % p])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 2) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(ed_list, [ken, e, (md + 1) % p])",
      "mutated_line": "heapq.heappush(ed_list, [ken, e, (md + 0) % p])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 0) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(ed_list, [ken, e, (md + 1) % p])",
      "mutated_line": "heapq.heappush(ed_list, [ken, e, (md + 0) % p])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + 0) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(ed_list, [ken, e, (md + 1) % p])",
      "mutated_line": "heapq.heappush(ed_list, [ken, e, (md + -1) % p])",
      "code": "import heapq\n\ndef minimum_ken_ken_pa(n, m, edges, s, t):\n    INF = 10 ** 18\n    edge = [[] for _ in range(n)]\n    for (u, v) in edges:\n        edge[u - 1].append(v - 1)\n\n    def dijkstra_heap(s, g, p):\n        d = [[INF] * p for _ in range(n)]\n        used = [[True] * p for _ in range(n)]\n        used[s][0] = False\n        ed_list = []\n        for es in edge[s]:\n            heapq.heappush(ed_list, [1, es, 1])\n        while ed_list:\n            (ken, v, md) = heapq.heappop(ed_list)\n            if not used[v][md]:\n                continue\n            d[v][md] = ken\n            used[v][md] = False\n            if not used[g][0]:\n                break\n            for e in edge[v]:\n                if used[e][(md + 1) % p]:\n                    if (md + 1) % p == 1:\n                        heapq.heappush(ed_list, [ken + 1, e, 1])\n                    else:\n                        heapq.heappush(ed_list, [ken, e, (md + -1) % p])\n        return d[g][0]\n    ans = dijkstra_heap(s - 1, t - 1, 3)\n    return ans if ans != INF else -1"
    }
  ]
}