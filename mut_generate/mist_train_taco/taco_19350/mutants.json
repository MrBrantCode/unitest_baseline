{
  "task_id": "taco_19350",
  "entry_point": "max_train_routes_to_close",
  "mutant_count": 118,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 1\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = -1\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 1\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[1] = 0",
      "mutated_line": "dist[1] = 1",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 1\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[1] = 0",
      "mutated_line": "dist[1] = -1",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = -1\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[1] = 0",
      "mutated_line": "dist[1] = 1",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 1\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "train = [-1 for _ in range(n + 1)]",
      "mutated_line": "train = [+1 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [+1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if train[s] != -1:",
      "mutated_line": "if train[s] == -1:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] == -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans -= 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(2, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(0, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(0, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(-1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n - 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n * 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if dist[i] != float('inf'):",
      "mutated_line": "if dist[i] == float('inf'):",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] == float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[1] = 0",
      "mutated_line": "dist[2] = 0",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[2] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[1] = 0",
      "mutated_line": "dist[0] = 0",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[0] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[1] = 0",
      "mutated_line": "dist[0] = 0",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[0] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[1] = 0",
      "mutated_line": "dist[-1] = 0",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[-1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cut = [0 for _ in range(n + 1)]",
      "mutated_line": "cut = [1 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [1 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cut = [0 for _ in range(n + 1)]",
      "mutated_line": "cut = [-1 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [-1 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cut = [0 for _ in range(n + 1)]",
      "mutated_line": "cut = [1 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [1 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "vis = [0 for _ in range(n + 1)]",
      "mutated_line": "vis = [1 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [1 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "vis = [0 for _ in range(n + 1)]",
      "mutated_line": "vis = [-1 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [-1 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "vis = [0 for _ in range(n + 1)]",
      "mutated_line": "vis = [1 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [1 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "vis[u] = 1",
      "mutated_line": "vis[u] = 2",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 2\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "vis[u] = 1",
      "mutated_line": "vis[u] = 0",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 0\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "vis[u] = 1",
      "mutated_line": "vis[u] = 0",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 0\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "vis[u] = 1",
      "mutated_line": "vis[u] = -1",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = -1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if b == 1:",
      "mutated_line": "if b != 1:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b != 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans -= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "train = [-1 for _ in range(n + 1)]",
      "mutated_line": "train = [-2 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-2 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "train = [-1 for _ in range(n + 1)]",
      "mutated_line": "train = [-0 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-0 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "train = [-1 for _ in range(n + 1)]",
      "mutated_line": "train = [-0 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-0 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "train = [-1 for _ in range(n + 1)]",
      "mutated_line": "train = [--1 for _ in range(n + 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [--1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist = [float('inf') for _ in range(n + 1)]",
      "mutated_line": "dist = [float('') for _ in range(n + 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "if train[s] != -1:",
      "mutated_line": "if train[s] != +1:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != +1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 2\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 0\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 0\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += -1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 2):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 0):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 0):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + -1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(pq, (0, 1))",
      "mutated_line": "heapq.heappush(pq, (1, 1))",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (1, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(pq, (0, 1))",
      "mutated_line": "heapq.heappush(pq, (-1, 1))",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (-1, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(pq, (0, 1))",
      "mutated_line": "heapq.heappush(pq, (1, 1))",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (1, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(pq, (0, 1))",
      "mutated_line": "heapq.heappush(pq, (0, 2))",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 2))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(pq, (0, 1))",
      "mutated_line": "heapq.heappush(pq, (0, 0))",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 0))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(pq, (0, 1))",
      "mutated_line": "heapq.heappush(pq, (0, 0))",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 0))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(pq, (0, 1))",
      "mutated_line": "heapq.heappush(pq, (0, -1))",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, -1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if dist[v] >= dist[u] + w:",
      "mutated_line": "if dist[v] > dist[u] + w:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] > dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if dist[v] >= dist[u] + w:",
      "mutated_line": "if dist[v] < dist[u] + w:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] < dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if dist[v] >= dist[u] + w:",
      "mutated_line": "if dist[v] == dist[u] + w:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] == dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if b == 1:",
      "mutated_line": "if b == 2:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 2:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if b == 1:",
      "mutated_line": "if b == 0:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 0:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if b == 1:",
      "mutated_line": "if b == 0:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 0:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if b == 1:",
      "mutated_line": "if b == -1:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == -1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n - 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n - 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n * 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n * 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "train = [-1 for _ in range(n + 1)]",
      "mutated_line": "train = [-1 for _ in range(n - 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n - 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "train = [-1 for _ in range(n + 1)]",
      "mutated_line": "train = [-1 for _ in range(n * 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n * 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dist = [float('inf') for _ in range(n + 1)]",
      "mutated_line": "dist = [float('inf') for _ in range(n - 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n - 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dist = [float('inf') for _ in range(n + 1)]",
      "mutated_line": "dist = [float('inf') for _ in range(n * 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n * 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if train[s] != -1:",
      "mutated_line": "if train[s] != -2:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -2:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if train[s] != -1:",
      "mutated_line": "if train[s] != -0:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -0:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if train[s] != -1:",
      "mutated_line": "if train[s] != -0:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -0:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if train[s] != -1:",
      "mutated_line": "if train[s] != --1:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != --1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dist[i] != float('inf'):",
      "mutated_line": "if dist[i] != float(''):",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float(''):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "cut = [0 for _ in range(n + 1)]",
      "mutated_line": "cut = [0 for _ in range(n - 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n - 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "cut = [0 for _ in range(n + 1)]",
      "mutated_line": "cut = [0 for _ in range(n * 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n * 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "vis = [0 for _ in range(n + 1)]",
      "mutated_line": "vis = [0 for _ in range(n - 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n - 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "vis = [0 for _ in range(n + 1)]",
      "mutated_line": "vis = [0 for _ in range(n * 1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n * 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if dist[v] >= dist[u] + w:",
      "mutated_line": "if dist[v] >= dist[u] - w:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] - w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if dist[v] >= dist[u] + w:",
      "mutated_line": "if dist[v] >= dist[u] * w:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] * w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if dist[v] != dist[u] + w:",
      "mutated_line": "if dist[v] == dist[u] + w:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] == dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dist[v] = dist[u] + w",
      "mutated_line": "dist[v] = dist[u] - w",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] - w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dist[v] = dist[u] + w",
      "mutated_line": "dist[v] = dist[u] * w",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] * w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if train[v] != -1:",
      "mutated_line": "if train[v] == -1:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] == -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + 2)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 2)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + 0)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 0)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + 0)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 0)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + -1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + -1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "train = [-1 for _ in range(n + 1)]",
      "mutated_line": "train = [-1 for _ in range(n + 2)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 2)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "train = [-1 for _ in range(n + 1)]",
      "mutated_line": "train = [-1 for _ in range(n + 0)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 0)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "train = [-1 for _ in range(n + 1)]",
      "mutated_line": "train = [-1 for _ in range(n + 0)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 0)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "train = [-1 for _ in range(n + 1)]",
      "mutated_line": "train = [-1 for _ in range(n + -1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + -1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist = [float('inf') for _ in range(n + 1)]",
      "mutated_line": "dist = [float('inf') for _ in range(n + 2)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 2)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist = [float('inf') for _ in range(n + 1)]",
      "mutated_line": "dist = [float('inf') for _ in range(n + 0)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 0)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist = [float('inf') for _ in range(n + 1)]",
      "mutated_line": "dist = [float('inf') for _ in range(n + 0)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 0)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist = [float('inf') for _ in range(n + 1)]",
      "mutated_line": "dist = [float('inf') for _ in range(n + -1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + -1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cut = [0 for _ in range(n + 1)]",
      "mutated_line": "cut = [0 for _ in range(n + 2)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 2)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cut = [0 for _ in range(n + 1)]",
      "mutated_line": "cut = [0 for _ in range(n + 0)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 0)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cut = [0 for _ in range(n + 1)]",
      "mutated_line": "cut = [0 for _ in range(n + 0)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 0)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cut = [0 for _ in range(n + 1)]",
      "mutated_line": "cut = [0 for _ in range(n + -1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + -1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "vis = [0 for _ in range(n + 1)]",
      "mutated_line": "vis = [0 for _ in range(n + 2)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 2)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "vis = [0 for _ in range(n + 1)]",
      "mutated_line": "vis = [0 for _ in range(n + 0)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 0)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "vis = [0 for _ in range(n + 1)]",
      "mutated_line": "vis = [0 for _ in range(n + 0)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 0)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "vis = [0 for _ in range(n + 1)]",
      "mutated_line": "vis = [0 for _ in range(n + -1)]",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + -1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if dist[v] != dist[u] + w:",
      "mutated_line": "if dist[v] != dist[u] - w:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] - w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if dist[v] != dist[u] + w:",
      "mutated_line": "if dist[v] != dist[u] * w:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] * w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "if train[v] != -1:",
      "mutated_line": "if train[v] != +1:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != +1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "cut[v] = 1",
      "mutated_line": "cut[v] = 2",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 2\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "cut[v] = 1",
      "mutated_line": "cut[v] = 0",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 0\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "cut[v] = 1",
      "mutated_line": "cut[v] = 0",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 0\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "cut[v] = 1",
      "mutated_line": "cut[v] = -1",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = -1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if train[v] != -1:",
      "mutated_line": "if train[v] != -2:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -2:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if train[v] != -1:",
      "mutated_line": "if train[v] != -0:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -0:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if train[v] != -1:",
      "mutated_line": "if train[v] != -0:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -0:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if train[v] != -1:",
      "mutated_line": "if train[v] != --1:",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] + w, v))\n                dist[v] = dist[u] + w\n                if train[v] != --1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "heapq.heappush(pq, (dist[u] + w, v))",
      "mutated_line": "heapq.heappush(pq, (dist[u] - w, v))",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] - w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "heapq.heappush(pq, (dist[u] + w, v))",
      "mutated_line": "heapq.heappush(pq, (dist[u] * w, v))",
      "code": "import heapq\n\ndef max_train_routes_to_close(n, m, k, roads, trains):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v, w) in roads:\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    train = [-1 for _ in range(n + 1)]\n    ans = 0\n    dist = [float('inf') for _ in range(n + 1)]\n    pq = []\n    for (s, y) in trains:\n        if train[s] != -1:\n            ans += 1\n            train[s] = min(train[s], y)\n            dist[s] = train[s]\n            continue\n        train[s] = y\n        dist[s] = y\n    for i in range(1, n + 1):\n        if dist[i] != float('inf'):\n            heapq.heappush(pq, (dist[i], i))\n    heapq.heappush(pq, (0, 1))\n    dist[1] = 0\n    cut = [0 for _ in range(n + 1)]\n    vis = [0 for _ in range(n + 1)]\n    while pq:\n        (dummy, u) = heapq.heappop(pq)\n        if vis[u]:\n            continue\n        vis[u] = 1\n        for (v, w) in adj[u]:\n            if dist[v] >= dist[u] + w:\n                if dist[v] != dist[u] + w:\n                    heapq.heappush(pq, (dist[u] * w, v))\n                dist[v] = dist[u] + w\n                if train[v] != -1:\n                    cut[v] = 1\n    for b in cut:\n        if b == 1:\n            ans += 1\n    return ans"
    }
  ]
}