{
  "task_id": "taco_15072",
  "entry_point": "calculate_minimum_cost",
  "mutant_count": 161,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count_0 = 0",
      "mutated_line": "count_0 = 1",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 1\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count_0 = 0",
      "mutated_line": "count_0 = -1",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = -1\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count_0 = 0",
      "mutated_line": "count_0 = 1",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 1\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "count_1 = 0",
      "mutated_line": "count_1 = 1",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 1\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "count_1 = 0",
      "mutated_line": "count_1 = -1",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = -1\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "count_1 = 0",
      "mutated_line": "count_1 = 1",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 1\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if char == '0':",
      "mutated_line": "if char != '0':",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char != '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "count_0 += 1",
      "mutated_line": "count_0 -= 1",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 -= 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if char == '1':",
      "mutated_line": "if char != '1':",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char != '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "count_1 += 1",
      "mutated_line": "count_1 -= 1",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 -= 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if n == length:",
      "mutated_line": "if n != length:",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n != length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if dp[n][a][b] != -1:",
      "mutated_line": "if dp[n][a][b] == -1:",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] == -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if S[n] == '0':",
      "mutated_line": "if S[n] != '0':",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] != '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ans(0, 0, 0)",
      "mutated_line": "return ans(1, 0, 0)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(1, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ans(0, 0, 0)",
      "mutated_line": "return ans(-1, 0, 0)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(-1, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ans(0, 0, 0)",
      "mutated_line": "return ans(1, 0, 0)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(1, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ans(0, 0, 0)",
      "mutated_line": "return ans(0, 1, 0)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ans(0, 0, 0)",
      "mutated_line": "return ans(0, -1, 0)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ans(0, 0, 0)",
      "mutated_line": "return ans(0, 1, 0)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ans(0, 0, 0)",
      "mutated_line": "return ans(0, 0, 1)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ans(0, 0, 0)",
      "mutated_line": "return ans(0, 0, -1)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return ans(0, 0, 0)",
      "mutated_line": "return ans(0, 0, 1)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if char == '0':",
      "mutated_line": "if char == '':",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "count_0 += 1",
      "mutated_line": "count_0 += 2",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 2\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "count_0 += 1",
      "mutated_line": "count_0 += 0",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 0\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "count_0 += 1",
      "mutated_line": "count_0 += 0",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 0\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "count_0 += 1",
      "mutated_line": "count_0 += -1",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += -1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if char == '1':",
      "mutated_line": "if char == '':",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "count_1 += 1",
      "mutated_line": "count_1 += 2",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 2\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "count_1 += 1",
      "mutated_line": "count_1 += 0",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 0\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "count_1 += 1",
      "mutated_line": "count_1 += 0",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 0\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "count_1 += 1",
      "mutated_line": "count_1 += -1",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += -1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 1\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return -1\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 1\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "if dp[n][a][b] != -1:",
      "mutated_line": "if dp[n][a][b] != +1:",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != +1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if S[n] == '0':",
      "mutated_line": "if S[n] == '':",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif S[n] == '1':",
      "mutated_line": "elif S[n] != '1':",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] != '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[+1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[+1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(102)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(102)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(100)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(100)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(0)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(0)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(1)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(1)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(-101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(-101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if dp[n][a][b] != -1:",
      "mutated_line": "if dp[n][a][b] != -2:",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -2:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if dp[n][a][b] != -1:",
      "mutated_line": "if dp[n][a][b] != -0:",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -0:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if dp[n][a][b] != -1:",
      "mutated_line": "if dp[n][a][b] != -0:",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -0:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if dp[n][a][b] != -1:",
      "mutated_line": "if dp[n][a][b] != --1:",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != --1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[n][a][b] = ans(n + 1, a + 1, b)",
      "mutated_line": "dp[n][a][b] = ans(n - 1, a + 1, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n - 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[n][a][b] = ans(n + 1, a + 1, b)",
      "mutated_line": "dp[n][a][b] = ans(n * 1, a + 1, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n * 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[n][a][b] = ans(n + 1, a + 1, b)",
      "mutated_line": "dp[n][a][b] = ans(n + 1, a - 1, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a - 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dp[n][a][b] = ans(n + 1, a + 1, b)",
      "mutated_line": "dp[n][a][b] = ans(n + 1, a * 1, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a * 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif S[n] == '1':",
      "mutated_line": "elif S[n] == '':",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif S[n] == '?':",
      "mutated_line": "elif S[n] != '?':",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] != '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-2 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-2 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-0 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-0 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-0 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-0 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[--1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[--1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(101)] for _ in range(102)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(102)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(101)] for _ in range(100)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(100)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(101)] for _ in range(0)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(0)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(101)] for _ in range(1)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(1)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(101)] for _ in range(-101)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(-101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[n][a][b] = ans(n + 1, a + 1, b)",
      "mutated_line": "dp[n][a][b] = ans(n + 2, a + 1, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 2, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[n][a][b] = ans(n + 1, a + 1, b)",
      "mutated_line": "dp[n][a][b] = ans(n + 0, a + 1, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 0, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[n][a][b] = ans(n + 1, a + 1, b)",
      "mutated_line": "dp[n][a][b] = ans(n + 0, a + 1, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 0, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[n][a][b] = ans(n + 1, a + 1, b)",
      "mutated_line": "dp[n][a][b] = ans(n + -1, a + 1, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + -1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[n][a][b] = ans(n + 1, a + 1, b)",
      "mutated_line": "dp[n][a][b] = ans(n + 1, a + 2, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 2, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[n][a][b] = ans(n + 1, a + 1, b)",
      "mutated_line": "dp[n][a][b] = ans(n + 1, a + 0, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 0, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[n][a][b] = ans(n + 1, a + 1, b)",
      "mutated_line": "dp[n][a][b] = ans(n + 1, a + 0, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 0, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[n][a][b] = ans(n + 1, a + 1, b)",
      "mutated_line": "dp[n][a][b] = ans(n + 1, a + -1, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + -1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = ans(n - 1, a, b + 1)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n - 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = ans(n * 1, a, b + 1)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n * 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = ans(n + 1, a, b - 1)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b - 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = ans(n + 1, a, b * 1)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b * 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif S[n] == '?':",
      "mutated_line": "elif S[n] == '':",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(102)] for _ in range(101)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(102)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(100)] for _ in range(101)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(100)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(0)] for _ in range(101)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(0)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(1)] for _ in range(101)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(1)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]",
      "mutated_line": "dp = [[[-1 for _ in range(-101)] for _ in range(101)] for _ in range(101)]",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(-101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = ans(n + 2, a, b + 1)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 2, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = ans(n + 0, a, b + 1)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 0, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = ans(n + 0, a, b + 1)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 0, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = ans(n + -1, a, b + 1)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + -1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = ans(n + 1, a, b + 2)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 2)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = ans(n + 1, a, b + 0)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 0)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = ans(n + 1, a, b + 0)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 0)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = ans(n + 1, a, b + -1)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + -1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) - ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) - ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min(((a - l1[n] + 1) * x - (a + 1)) * ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min(((a - l1[n] + 1) * x - (a + 1)) * ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) - ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) - ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), ((b - l2[n] + 1) * y - (b + 1)) * ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), ((b - l2[n] + 1) * y - (b + 1)) * ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b)",
      "mutated_line": "dp[n][a][b] = ans(n - 1, a, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n - 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b)",
      "mutated_line": "dp[n][a][b] = ans(n * 1, a, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n * 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x + (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x + (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x * (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x * (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y + (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y + (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y * (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y * (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b)",
      "mutated_line": "dp[n][a][b] = ans(n + 2, a, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 2, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b)",
      "mutated_line": "dp[n][a][b] = ans(n + 0, a, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 0, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b)",
      "mutated_line": "dp[n][a][b] = ans(n + 0, a, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 0, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dp[n][a][b] = ans(n + 1, a, b)",
      "mutated_line": "dp[n][a][b] = ans(n + -1, a, b)",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + -1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) / x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) / x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min(a - l1[n] + 1 + x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min(a - l1[n] + 1 + x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) ** x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) ** x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a - 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a - 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - a * 1 + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - a * 1 + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n - 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n - 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n * 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n * 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a - 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a - 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a * 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a * 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) / y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) / y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), b - l2[n] + 1 + y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), b - l2[n] + 1 + y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) ** y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) ** y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b - 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b - 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - b * 1 + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - b * 1 + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n - 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n - 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n * 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n * 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b - 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b - 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b * 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b * 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] - 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] - 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n]) * 1 * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n]) * 1 * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 2) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 2) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 0) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 0) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 0) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 0) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + -1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + -1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 2, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 2, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 0, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 0, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 0, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 0, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + -1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + -1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 2, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 2, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 0, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 0, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 0, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 0, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + -1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + -1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] - 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] - 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n]) * 1 * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n]) * 1 * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 2) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 2) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 0) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 0) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 0) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 0) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + -1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + -1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 2, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 2, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 0, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 0, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 0, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 0, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + -1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + -1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 2))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 2))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 0))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 0))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 0))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 0))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + -1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + -1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a + l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a + l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a * l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a * l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 2) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 2) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 0) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 0) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 0) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 0) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b),",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + -1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + -1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b + l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b + l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b * l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b * l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 2) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 2) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 0) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 0) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 0) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + 0) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(b - l2[n] + 1) * y - (b + 1) + ans(n + 1, a, b + 1)",
      "mutated_line": "dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + -1) * y - (b + 1) + ans(n + 1, a, b + 1))",
      "code": "def calculate_minimum_cost(S, x, y):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    l1 = []\n    l2 = []\n    count_0 = 0\n    count_1 = 0\n    for char in S:\n        if char == '0':\n            count_0 += 1\n        if char == '1':\n            count_1 += 1\n        l1.append(count_0)\n        l2.append(count_1)\n    length = len(S)\n\n    def ans(n, a, b):\n        if n == length:\n            return 0\n        if dp[n][a][b] != -1:\n            return dp[n][a][b]\n        if S[n] == '0':\n            dp[n][a][b] = ans(n + 1, a + 1, b)\n            return dp[n][a][b]\n        elif S[n] == '1':\n            dp[n][a][b] = ans(n + 1, a, b + 1)\n            return dp[n][a][b]\n        elif S[n] == '?':\n            dp[n][a][b] = min((a - l1[n] + 1) * x - (a + 1) + ans(n + 1, a + 1, b), (b - l2[n] + -1) * y - (b + 1) + ans(n + 1, a, b + 1))\n            return dp[n][a][b]\n        else:\n            dp[n][a][b] = ans(n + 1, a, b)\n            return dp[n][a][b]\n    return ans(0, 0, 0)"
    }
  ]
}