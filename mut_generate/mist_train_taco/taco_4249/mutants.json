{
  "task_id": "taco_4249",
  "entry_point": "find_tree_decomposition",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] / (n + 1)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] / (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] + (n + 1)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] + (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] ** (n + 1)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] ** (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "deg[a] += 1",
      "mutated_line": "deg[a] -= 1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] -= 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "deg[b] += 1",
      "mutated_line": "deg[b] -= 1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] -= 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 1\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = -1\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 1\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mxdeg = 0",
      "mutated_line": "mxdeg = 1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 1\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mxdeg = 0",
      "mutated_line": "mxdeg = -1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = -1\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mxdeg = 0",
      "mutated_line": "mxdeg = 1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 1\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "root = 0",
      "mutated_line": "root = 1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 1\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "root = 0",
      "mutated_line": "root = -1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = -1\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "root = 0",
      "mutated_line": "root = 1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 1\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if cnt > 1:",
      "mutated_line": "return ('No',)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt >= 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if cnt > 1:",
      "mutated_line": "return ('No',)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt <= 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if cnt > 1:",
      "mutated_line": "return ('No',)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt != 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "m = 0",
      "mutated_line": "m = 1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 1\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "m = 0",
      "mutated_line": "m = -1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = -1\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "m = 0",
      "mutated_line": "m = 1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 1\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] * (n - 1)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n - 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] * (n * 1)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n * 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "deg[a] += 1",
      "mutated_line": "deg[a] += 2",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 2\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "deg[a] += 1",
      "mutated_line": "deg[a] += 0",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 0\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "deg[a] += 1",
      "mutated_line": "deg[a] += 0",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 0\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "deg[a] += 1",
      "mutated_line": "deg[a] += -1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += -1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "deg[b] += 1",
      "mutated_line": "deg[b] += 2",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 2\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "deg[b] += 1",
      "mutated_line": "deg[b] += 0",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 0\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "deg[b] += 1",
      "mutated_line": "deg[b] += 0",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 0\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "deg[b] += 1",
      "mutated_line": "deg[b] += -1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += -1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(2, n + 1):",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(2, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(0, n + 1):",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(0, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(0, n + 1):",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(0, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(-1, n + 1):",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(-1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n - 1):",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n - 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n * 1):",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n * 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if deg[j] > mxdeg:",
      "mutated_line": "if deg[j] >= mxdeg:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] >= mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if deg[j] > mxdeg:",
      "mutated_line": "if deg[j] <= mxdeg:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] <= mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if deg[j] > mxdeg:",
      "mutated_line": "if deg[j] != mxdeg:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] != mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if deg[j] == 1:",
      "mutated_line": "if deg[j] != 1:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] != 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if deg[j] > 2:",
      "mutated_line": "if deg[j] >= 2:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] >= 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if deg[j] > 2:",
      "mutated_line": "if deg[j] <= 2:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] <= 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if deg[j] > 2:",
      "mutated_line": "if deg[j] != 2:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] != 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt -= 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if cnt > 1:",
      "mutated_line": "return ('No',)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 2:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if cnt > 1:",
      "mutated_line": "return ('No',)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 0:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if cnt > 1:",
      "mutated_line": "return ('No',)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 0:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if cnt > 1:",
      "mutated_line": "return ('No',)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > -1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if it != root:",
      "mutated_line": "if it == root:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it == root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "m += 1",
      "mutated_line": "m -= 1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m -= 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return (\"Yes\", m, paths)",
      "mutated_line": "return ('', m, paths)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [1] * (n + 1)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [1] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [-1] * (n + 1)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [-1] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [1] * (n + 1)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [1] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] * (n + 2)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 2)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] * (n + 0)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 0)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] * (n + 0)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 0)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] * (n + -1)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + -1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n + 2):",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 2):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n + 0):",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 0):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n + 0):",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 0):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for j in range(1, n + 1):",
      "mutated_line": "for j in range(1, n + -1):",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + -1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if deg[j] == 1:",
      "mutated_line": "if deg[j] == 2:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 2:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if deg[j] == 1:",
      "mutated_line": "if deg[j] == 0:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 0:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if deg[j] == 1:",
      "mutated_line": "if deg[j] == 0:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 0:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if deg[j] == 1:",
      "mutated_line": "if deg[j] == -1:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == -1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if deg[j] > 2:",
      "mutated_line": "if deg[j] > 3:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 3:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if deg[j] > 2:",
      "mutated_line": "if deg[j] > 1:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 1:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if deg[j] > 2:",
      "mutated_line": "if deg[j] > 0:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 0:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if deg[j] > 2:",
      "mutated_line": "if deg[j] > 1:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 1:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if deg[j] > 2:",
      "mutated_line": "if deg[j] > -2:",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > -2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 2\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 0\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 0\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += -1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return (\"No\",)",
      "mutated_line": "return ('',)",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "m += 1",
      "mutated_line": "m += 2",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 2\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "m += 1",
      "mutated_line": "m += 0",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 0\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "m += 1",
      "mutated_line": "m += 0",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += 0\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "m += 1",
      "mutated_line": "m += -1",
      "code": "def find_tree_decomposition(n, edges):\n    deg = [0] * (n + 1)\n    leaves = []\n    for (a, b) in edges:\n        deg[a] += 1\n        deg[b] += 1\n    cnt = 0\n    mxdeg = 0\n    root = 0\n    for j in range(1, n + 1):\n        if deg[j] > mxdeg:\n            mxdeg = deg[j]\n            root = j\n        if deg[j] == 1:\n            leaves.append(j)\n        if deg[j] > 2:\n            cnt += 1\n    if cnt > 1:\n        return ('No',)\n    m = 0\n    paths = []\n    for it in leaves:\n        if it != root:\n            m += -1\n            paths.append((root, it))\n    return ('Yes', m, paths)"
    }
  ]
}