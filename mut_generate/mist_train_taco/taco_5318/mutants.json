{
  "task_id": "taco_5318",
  "entry_point": "minimum_moves_to_equal_elements",
  "mutant_count": 52,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if sm % N != 0:",
      "mutated_line": "if sm % N == 0:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N == 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "avg = sm // N",
      "mutated_line": "avg = sm / N",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm / N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "avg = sm // N",
      "mutated_line": "avg = sm * N",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm * N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "possible = True",
      "mutated_line": "possible = False",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = False\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 1\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = -1\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 1\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cur = 0",
      "mutated_line": "cur = 1",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 1\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cur = 0",
      "mutated_line": "cur = -1",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = -1\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cur = 0",
      "mutated_line": "cur = 1",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 1\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if sm % N != 0:",
      "mutated_line": "if sm * N != 0:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm * N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if sm % N != 0:",
      "mutated_line": "if sm + N != 0:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm + N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if sm % N != 0:",
      "mutated_line": "if sm % N != 1:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 1:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if sm % N != 0:",
      "mutated_line": "if sm % N != -1:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != -1:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if sm % N != 0:",
      "mutated_line": "if sm % N != 1:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 1:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "tmp_sm = 0",
      "mutated_line": "tmp_sm = 1",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 1\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "tmp_sm = 0",
      "mutated_line": "tmp_sm = -1",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = -1\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "tmp_sm = 0",
      "mutated_line": "tmp_sm = 1",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 1\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp_n = 0",
      "mutated_line": "tmp_n = 1",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 1\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp_n = 0",
      "mutated_line": "tmp_n = -1",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = -1\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "tmp_n = 0",
      "mutated_line": "tmp_n = 1",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 1\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "tmp_sm += A[j]",
      "mutated_line": "tmp_sm -= A[j]",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm -= A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "tmp_n += 1",
      "mutated_line": "tmp_n -= 1",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n -= 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:",
      "mutated_line": "if tmp_sm % tmp_n != 0 and tmp_sm // tmp_n != avg:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 and tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "cur += avg - A[j]",
      "mutated_line": "cur -= avg - A[j]",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur -= avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "ans += abs(cur)",
      "mutated_line": "ans -= abs(cur)",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans -= abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(+1)",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(+1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tmp_n += 1",
      "mutated_line": "tmp_n += 2",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 2\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tmp_n += 1",
      "mutated_line": "tmp_n += 0",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 0\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tmp_n += 1",
      "mutated_line": "tmp_n += 0",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 0\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tmp_n += 1",
      "mutated_line": "tmp_n += -1",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += -1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:",
      "mutated_line": "if tmp_sm % tmp_n == 0 or tmp_sm // tmp_n != avg:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n == 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:",
      "mutated_line": "if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n == avg:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n == avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "possible = False",
      "mutated_line": "possible = True",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = True\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(+1)",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(+1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "cur += avg - A[j]",
      "mutated_line": "cur += avg + A[j]",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg + A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "cur += avg - A[j]",
      "mutated_line": "cur += avg * A[j]",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg * A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-2)",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-2)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-0)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-0)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(--1)",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(--1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:",
      "mutated_line": "if tmp_sm * tmp_n != 0 or tmp_sm // tmp_n != avg:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm * tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:",
      "mutated_line": "if tmp_sm + tmp_n != 0 or tmp_sm // tmp_n != avg:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm + tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:",
      "mutated_line": "if tmp_sm % tmp_n != 1 or tmp_sm // tmp_n != avg:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 1 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:",
      "mutated_line": "if tmp_sm % tmp_n != -1 or tmp_sm // tmp_n != avg:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != -1 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:",
      "mutated_line": "if tmp_sm % tmp_n != 1 or tmp_sm // tmp_n != avg:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 1 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:",
      "mutated_line": "if tmp_sm % tmp_n != 0 or tmp_sm / tmp_n != avg:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm / tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:",
      "mutated_line": "if tmp_sm % tmp_n != 0 or tmp_sm * tmp_n != avg:",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm * tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-2)",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-2)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-0)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(-0)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(--1)",
      "code": "def minimum_moves_to_equal_elements(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, D, A) = case\n        sm = sum(A)\n        if sm % N != 0:\n            results.append(-1)\n            continue\n        avg = sm // N\n        possible = True\n        for i in range(D):\n            tmp_sm = 0\n            tmp_n = 0\n            for j in range(i, N, D):\n                tmp_sm += A[j]\n                tmp_n += 1\n            if tmp_sm % tmp_n != 0 or tmp_sm // tmp_n != avg:\n                possible = False\n                break\n        if not possible:\n            results.append(--1)\n            continue\n        ans = 0\n        cur = 0\n        for i in range(D):\n            for j in range(i, N, D):\n                cur += avg - A[j]\n                ans += abs(cur)\n        results.append(ans)\n    return results"
    }
  ]
}