{
  "task_id": "taco_2069",
  "entry_point": "calculate_max_flow",
  "mutant_count": 125,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "capacity[u - 1][v - 1] += cap",
      "mutated_line": "capacity[u - 1][v - 1] -= cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] -= cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "capacity[v - 1][u - 1] += cap",
      "mutated_line": "capacity[v - 1][u - 1] -= cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] -= cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "flow = 0",
      "mutated_line": "flow = 1",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 1\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "flow = 0",
      "mutated_line": "flow = -1",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = -1\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "flow = 0",
      "mutated_line": "flow = 1",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 1\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while False:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "flow += new_flow",
      "mutated_line": "flow -= new_flow",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow -= new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "parent[s] = -2",
      "mutated_line": "parent[s] = +2",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = +2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) >= 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) >= 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) <= 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) <= 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) != 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) != 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 1\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return -1\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 1\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-1] / N",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] / N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-1] + N",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] + N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-1] ** N",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] ** N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if new_flow == 0:",
      "mutated_line": "if new_flow != 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow != 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "curr = N - 1",
      "mutated_line": "curr = N + 1",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N + 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "curr = N - 1",
      "mutated_line": "curr = N * 1",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N * 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "while curr != 0:",
      "mutated_line": "while curr == 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr == 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "capacity[prev][curr] -= new_flow",
      "mutated_line": "capacity[prev][curr] += new_flow",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] += new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "capacity[curr][prev] += new_flow",
      "mutated_line": "capacity[curr][prev] -= new_flow",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] -= new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parent[s] = -2",
      "mutated_line": "parent[s] = -3",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -3\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parent[s] = -2",
      "mutated_line": "parent[s] = -1",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -1\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parent[s] = -2",
      "mutated_line": "parent[s] = -0",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -0\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parent[s] = -2",
      "mutated_line": "parent[s] = -1",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -1\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parent[s] = -2",
      "mutated_line": "parent[s] = --2",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = --2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) > 1:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 1:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) > -1:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > -1:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) > 1:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 1:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "capacity = [[0 for _ in range(N)] for _ in range(N)]",
      "mutated_line": "capacity = [[1 for _ in range(N)] for _ in range(N)]",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[1 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "capacity = [[0 for _ in range(N)] for _ in range(N)]",
      "mutated_line": "capacity = [[-1 for _ in range(N)] for _ in range(N)]",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[-1 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "capacity = [[0 for _ in range(N)] for _ in range(N)]",
      "mutated_line": "capacity = [[1 for _ in range(N)] for _ in range(N)]",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[1 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v + 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v + 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v * 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v * 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 1].append(u + 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u + 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 1].append(u * 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u * 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "capacity[u - 1][v - 1] += cap",
      "mutated_line": "capacity[u - 1][v + 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v + 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "capacity[u - 1][v - 1] += cap",
      "mutated_line": "capacity[u - 1][v * 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v * 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "capacity[v - 1][u - 1] += cap",
      "mutated_line": "capacity[v - 1][u + 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u + 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "capacity[v - 1][u - 1] += cap",
      "mutated_line": "capacity[v - 1][u * 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u * 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "new_flow = bfs(0, N - 1, parent)",
      "mutated_line": "new_flow = bfs(1, N - 1, parent)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(1, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "new_flow = bfs(0, N - 1, parent)",
      "mutated_line": "new_flow = bfs(-1, N - 1, parent)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(-1, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "new_flow = bfs(0, N - 1, parent)",
      "mutated_line": "new_flow = bfs(1, N - 1, parent)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(1, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "new_flow = bfs(0, N - 1, parent)",
      "mutated_line": "new_flow = bfs(0, N + 1, parent)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N + 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "new_flow = bfs(0, N - 1, parent)",
      "mutated_line": "new_flow = bfs(0, N * 1, parent)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N * 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if new_flow == 0:",
      "mutated_line": "if new_flow == 1:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 1:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if new_flow == 0:",
      "mutated_line": "if new_flow == -1:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == -1:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if new_flow == 0:",
      "mutated_line": "if new_flow == 1:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 1:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "curr = N - 1",
      "mutated_line": "curr = N - 2",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 2\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "curr = N - 1",
      "mutated_line": "curr = N - 0",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 0\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "curr = N - 1",
      "mutated_line": "curr = N - 0",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 0\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "curr = N - 1",
      "mutated_line": "curr = N - -1",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - -1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while curr != 0:",
      "mutated_line": "while curr != 1:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 1:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while curr != 0:",
      "mutated_line": "while curr != -1:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != -1:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "while curr != 0:",
      "mutated_line": "while curr != 1:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 1:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q.append((s, 100000))",
      "mutated_line": "q.append((s, 100001))",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100001))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q.append((s, 100000))",
      "mutated_line": "q.append((s, 99999))",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 99999))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q.append((s, 100000))",
      "mutated_line": "q.append((s, 0))",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 0))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q.append((s, 100000))",
      "mutated_line": "q.append((s, 1))",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 1))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "q.append((s, 100000))",
      "mutated_line": "q.append((s, -100000))",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, -100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if parent[w] == -1 and capacity[v][w] > 0:",
      "mutated_line": "if parent[w] == -1 or capacity[v][w] > 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 or capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v - 2)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 2)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v - 0)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 0)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v - 0)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 0)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v - -1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - -1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 1].append(u - 2)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 2)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 1].append(u - 0)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 0)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 1].append(u - 0)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 0)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 1].append(u - -1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - -1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "capacity[u - 1][v - 1] += cap",
      "mutated_line": "capacity[u + 1][v - 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u + 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "capacity[u - 1][v - 1] += cap",
      "mutated_line": "capacity[u * 1][v - 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u * 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "capacity[u - 1][v - 1] += cap",
      "mutated_line": "capacity[u - 1][v - 2] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 2] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "capacity[u - 1][v - 1] += cap",
      "mutated_line": "capacity[u - 1][v - 0] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 0] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "capacity[u - 1][v - 1] += cap",
      "mutated_line": "capacity[u - 1][v - 0] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 0] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "capacity[u - 1][v - 1] += cap",
      "mutated_line": "capacity[u - 1][v - -1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - -1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "capacity[v - 1][u - 1] += cap",
      "mutated_line": "capacity[v + 1][u - 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v + 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "capacity[v - 1][u - 1] += cap",
      "mutated_line": "capacity[v * 1][u - 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v * 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "capacity[v - 1][u - 1] += cap",
      "mutated_line": "capacity[v - 1][u - 2] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 2] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "capacity[v - 1][u - 1] += cap",
      "mutated_line": "capacity[v - 1][u - 0] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 0] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "capacity[v - 1][u - 1] += cap",
      "mutated_line": "capacity[v - 1][u - 0] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 0] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "capacity[v - 1][u - 1] += cap",
      "mutated_line": "capacity[v - 1][u - -1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - -1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [+1] * N",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [+1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "new_flow = bfs(0, N - 1, parent)",
      "mutated_line": "new_flow = bfs(0, N - 2, parent)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 2, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "new_flow = bfs(0, N - 1, parent)",
      "mutated_line": "new_flow = bfs(0, N - 0, parent)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 0, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "new_flow = bfs(0, N - 1, parent)",
      "mutated_line": "new_flow = bfs(0, N - 0, parent)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 0, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "new_flow = bfs(0, N - 1, parent)",
      "mutated_line": "new_flow = bfs(0, N - -1, parent)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - -1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if parent[w] == -1 and capacity[v][w] > 0:",
      "mutated_line": "if parent[w] != -1 and capacity[v][w] > 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] != -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if parent[w] == -1 and capacity[v][w] > 0:",
      "mutated_line": "if parent[w] == -1 and capacity[v][w] >= 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] >= 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if parent[w] == -1 and capacity[v][w] > 0:",
      "mutated_line": "if parent[w] == -1 and capacity[v][w] <= 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] <= 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if parent[w] == -1 and capacity[v][w] > 0:",
      "mutated_line": "if parent[w] == -1 and capacity[v][w] != 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] != 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if w == t:",
      "mutated_line": "if w != t:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w != t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u + 1].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u + 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u * 1].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u * 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v + 1].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v + 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v * 1].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v * 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "capacity[u - 1][v - 1] += cap",
      "mutated_line": "capacity[u - 2][v - 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 2][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "capacity[u - 1][v - 1] += cap",
      "mutated_line": "capacity[u - 0][v - 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 0][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "capacity[u - 1][v - 1] += cap",
      "mutated_line": "capacity[u - 0][v - 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 0][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "capacity[u - 1][v - 1] += cap",
      "mutated_line": "capacity[u - -1][v - 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - -1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "capacity[v - 1][u - 1] += cap",
      "mutated_line": "capacity[v - 2][u - 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 2][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "capacity[v - 1][u - 1] += cap",
      "mutated_line": "capacity[v - 0][u - 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 0][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "capacity[v - 1][u - 1] += cap",
      "mutated_line": "capacity[v - 0][u - 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 0][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "capacity[v - 1][u - 1] += cap",
      "mutated_line": "capacity[v - -1][u - 1] += cap",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - -1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-2] * N",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-2] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-0] * N",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-0] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-0] * N",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-0] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [--1] * N",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [--1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "if parent[w] == -1 and capacity[v][w] > 0:",
      "mutated_line": "if parent[w] == +1 and capacity[v][w] > 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == +1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parent[w] == -1 and capacity[v][w] > 0:",
      "mutated_line": "if parent[w] == -1 and capacity[v][w] > 1:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 1:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parent[w] == -1 and capacity[v][w] > 0:",
      "mutated_line": "if parent[w] == -1 and capacity[v][w] > -1:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > -1:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parent[w] == -1 and capacity[v][w] > 0:",
      "mutated_line": "if parent[w] == -1 and capacity[v][w] > 1:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 1:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 2].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 2].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 0].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 0].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 0].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 0].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - -1].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - -1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 2].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 2].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 0].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 0].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 0].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 0].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - -1].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - -1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parent[w] == -1 and capacity[v][w] > 0:",
      "mutated_line": "if parent[w] == -2 and capacity[v][w] > 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -2 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parent[w] == -1 and capacity[v][w] > 0:",
      "mutated_line": "if parent[w] == -0 and capacity[v][w] > 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -0 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parent[w] == -1 and capacity[v][w] > 0:",
      "mutated_line": "if parent[w] == -0 and capacity[v][w] > 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == -0 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parent[w] == -1 and capacity[v][w] > 0:",
      "mutated_line": "if parent[w] == --1 and capacity[v][w] > 0:",
      "code": "from collections import deque\n\ndef calculate_max_flow(N, M, Edges):\n\n    def bfs(s, t, parent):\n        q = deque()\n        parent[s] = -2\n        q.append((s, 100000))\n        while len(q) > 0:\n            (v, flow) = q.popleft()\n            for w in adj[v]:\n                if parent[w] == --1 and capacity[v][w] > 0:\n                    parent[w] = v\n                    nflow = min(flow, capacity[v][w])\n                    if w == t:\n                        return nflow\n                    q.append((w, nflow))\n        return 0\n    adj = [[] for _ in range(N)]\n    capacity = [[0 for _ in range(N)] for _ in range(N)]\n    for e in Edges:\n        (u, v, cap) = e\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n        capacity[u - 1][v - 1] += cap\n        capacity[v - 1][u - 1] += cap\n    flow = 0\n    while True:\n        parent = [-1] * N\n        new_flow = bfs(0, N - 1, parent)\n        if new_flow == 0:\n            break\n        flow += new_flow\n        curr = N - 1\n        while curr != 0:\n            prev = parent[curr]\n            capacity[prev][curr] -= new_flow\n            capacity[curr][prev] += new_flow\n            curr = prev\n    return flow"
    }
  ]
}