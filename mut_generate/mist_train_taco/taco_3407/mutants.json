{
  "task_id": "taco_3407",
  "entry_point": "count_reachable_cells",
  "mutant_count": 242,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "r -= 1",
      "mutated_line": "r += 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r += 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "c -= 1",
      "mutated_line": "c += 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c += 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r -= 1",
      "mutated_line": "r -= 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 2\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r -= 1",
      "mutated_line": "r -= 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 0\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r -= 1",
      "mutated_line": "r -= 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 0\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r -= 1",
      "mutated_line": "r -= -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= -1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c -= 1",
      "mutated_line": "c -= 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 2\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c -= 1",
      "mutated_line": "c -= 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 0\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c -= 1",
      "mutated_line": "c -= 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 0\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c -= 1",
      "mutated_line": "c -= -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= -1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 1\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = -1\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 1\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "vd = [[0] * m for _ in range(n)]",
      "mutated_line": "vd = [[0] / m for _ in range(n)]",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] / m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "vd = [[0] * m for _ in range(n)]",
      "mutated_line": "vd = [[0] + m for _ in range(n)]",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] + m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "vd = [[0] * m for _ in range(n)]",
      "mutated_line": "vd = [[0] ** m for _ in range(n)]",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] ** m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "while ru >= 0 and labyrinth[ru][ci] == '.' and not vd[ru][ci]:",
      "mutated_line": "while ru >= 0 or labyrinth[ru][ci] == '.' or (not vd[ru][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 or labyrinth[ru][ci] == '.' or (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans -= 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "ru -= 1",
      "mutated_line": "ru += 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru += 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "rd = ri + 1",
      "mutated_line": "while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri - 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "rd = ri + 1",
      "mutated_line": "while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri * 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "while rd < n and labyrinth[rd][ci] == '.' and not vd[rd][ci]:",
      "mutated_line": "while rd < n or labyrinth[rd][ci] == '.' or (not vd[rd][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n or labyrinth[rd][ci] == '.' or (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans -= 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "rd += 1",
      "mutated_line": "rd -= 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd -= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while ru >= 0 and labyrinth[ru][ci] == '.' and not vd[ru][ci]:",
      "mutated_line": "while ru > 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru > 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while ru >= 0 and labyrinth[ru][ci] == '.' and not vd[ru][ci]:",
      "mutated_line": "while ru < 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru < 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while ru >= 0 and labyrinth[ru][ci] == '.' and not vd[ru][ci]:",
      "mutated_line": "while ru == 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru == 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while ru >= 0 and labyrinth[ru][ci] == '.' and not vd[ru][ci]:",
      "mutated_line": "while ru >= 0 and labyrinth[ru][ci] != '.' and (not vd[ru][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] != '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vd[ru][ci] = 1",
      "mutated_line": "vd[ru][ci] = 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 2\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vd[ru][ci] = 1",
      "mutated_line": "vd[ru][ci] = 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 0\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vd[ru][ci] = 1",
      "mutated_line": "vd[ru][ci] = 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 0\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vd[ru][ci] = 1",
      "mutated_line": "vd[ru][ci] = -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = -1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 2\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 0\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 0\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += -1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 or ci - 1 >= 0 or labyrinth[ru][ci - 1] == '.' or (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 or ci - 1 >= 0 or labyrinth[ru][ci - 1] == '.' or (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 or ci + 1 < m or labyrinth[ru][ci + 1] == '.' or (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 or ci + 1 < m or labyrinth[ru][ci + 1] == '.' or (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ru -= 1",
      "mutated_line": "ru -= 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 2\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ru -= 1",
      "mutated_line": "ru -= 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 0\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ru -= 1",
      "mutated_line": "ru -= 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 0\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ru -= 1",
      "mutated_line": "ru -= -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= -1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "rd = ri + 1",
      "mutated_line": "while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 2\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "rd = ri + 1",
      "mutated_line": "while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 0\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "rd = ri + 1",
      "mutated_line": "while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 0\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "rd = ri + 1",
      "mutated_line": "while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + -1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while rd < n and labyrinth[rd][ci] == '.' and not vd[rd][ci]:",
      "mutated_line": "while rd <= n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd <= n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while rd < n and labyrinth[rd][ci] == '.' and not vd[rd][ci]:",
      "mutated_line": "while rd >= n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd >= n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while rd < n and labyrinth[rd][ci] == '.' and not vd[rd][ci]:",
      "mutated_line": "while rd != n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd != n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while rd < n and labyrinth[rd][ci] == '.' and not vd[rd][ci]:",
      "mutated_line": "while rd < n and labyrinth[rd][ci] != '.' and (not vd[rd][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] != '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "vd[rd][ci] = 1",
      "mutated_line": "vd[rd][ci] = 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 2\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "vd[rd][ci] = 1",
      "mutated_line": "vd[rd][ci] = 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 0\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "vd[rd][ci] = 1",
      "mutated_line": "vd[rd][ci] = 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 0\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "vd[rd][ci] = 1",
      "mutated_line": "vd[rd][ci] = -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = -1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 2\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 0\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 0\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += -1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 or ci - 1 >= 0 or labyrinth[rd][ci - 1] == '.' or (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 or ci - 1 >= 0 or labyrinth[rd][ci - 1] == '.' or (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 or ci + 1 < m or labyrinth[rd][ci + 1] == '.' or (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 or ci + 1 < m or labyrinth[rd][ci + 1] == '.' or (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "rd += 1",
      "mutated_line": "rd += 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "rd += 1",
      "mutated_line": "rd += 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "rd += 1",
      "mutated_line": "rd += 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "rd += 1",
      "mutated_line": "rd += -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "vd = [[0] * m for _ in range(n)]",
      "mutated_line": "vd = [[1] * m for _ in range(n)]",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[1] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "vd = [[0] * m for _ in range(n)]",
      "mutated_line": "vd = [[-1] * m for _ in range(n)]",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[-1] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "vd = [[0] * m for _ in range(n)]",
      "mutated_line": "vd = [[1] * m for _ in range(n)]",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[1] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while ru >= 0 and labyrinth[ru][ci] == '.' and not vd[ru][ci]:",
      "mutated_line": "while ru >= 1 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 1 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while ru >= 0 and labyrinth[ru][ci] == '.' and not vd[ru][ci]:",
      "mutated_line": "while ru >= -1 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= -1 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while ru >= 0 and labyrinth[ru][ci] == '.' and not vd[ru][ci]:",
      "mutated_line": "while ru >= 1 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 1 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while ru >= 0 and labyrinth[ru][ci] == '.' and not vd[ru][ci]:",
      "mutated_line": "while ru >= 0 and labyrinth[ru][ci] == '' and (not vd[ru][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi >= 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi >= 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi <= 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi <= 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi != 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi != 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 > 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 > 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 < 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 < 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 == 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 == 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] != '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] != '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi >= 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi >= 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi <= 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi <= 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi != 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi != 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 <= m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 <= m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 >= m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 >= m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 != m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 != m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] != '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] != '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while rd < n and labyrinth[rd][ci] == '.' and not vd[rd][ci]:",
      "mutated_line": "while rd < n and labyrinth[rd][ci] == '' and (not vd[rd][ci]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi >= 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi >= 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi <= 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi <= 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi != 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi != 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 > 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 > 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 < 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 < 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 == 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 == 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] != '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] != '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi >= 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi >= 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi <= 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi <= 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi != 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi != 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 <= m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 <= m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 >= m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 >= m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 != m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 != m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] != '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] != '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 1 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 1 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > -1 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > -1 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 1 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 1 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci + 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci + 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci * 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci * 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 1 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 1 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= -1 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= -1 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 1 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 1 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 1 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 1 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > -1 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > -1 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 1 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 1 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci - 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci - 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci * 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci * 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 1 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 1 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > -1 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > -1 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 1 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 1 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci + 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci + 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci * 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci * 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 1 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 1 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= -1 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= -1 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 1 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 1 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 1 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 1 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > -1 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > -1 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 1 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 1 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci - 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci - 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci * 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci * 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 2 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 2 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 0 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 0 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 0 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 0 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - -1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - -1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci * 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci * 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci * 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci * 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "to_visit.append((ru, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((ru, ci + 1, xi - 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci + 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "to_visit.append((ru, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((ru, ci * 1, xi - 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci * 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "to_visit.append((ru, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((ru, ci - 1, xi + 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi + 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "to_visit.append((ru, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((ru, ci - 1, xi * 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi * 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 2 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 2 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 0 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 0 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 0 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 0 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + -1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + -1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[ru][ci * 1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci * 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci * 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci * 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "to_visit.append((ru, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((ru, ci - 1, xi, yi - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci - 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "to_visit.append((ru, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((ru, ci * 1, xi, yi - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci * 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "to_visit.append((ru, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((ru, ci + 1, xi, yi + 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi + 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "to_visit.append((ru, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((ru, ci + 1, xi, yi * 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi * 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 2 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 2 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 0 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 0 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 0 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 0 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - -1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - -1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci * 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci * 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci * 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci * 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "to_visit.append((rd, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((rd, ci + 1, xi - 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci + 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "to_visit.append((rd, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((rd, ci * 1, xi - 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci * 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "to_visit.append((rd, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((rd, ci - 1, xi + 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi + 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "to_visit.append((rd, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((rd, ci - 1, xi * 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi * 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 2 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 2 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 0 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 0 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 0 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 0 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + -1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + -1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[rd][ci * 1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci * 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci * 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci * 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "to_visit.append((rd, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((rd, ci - 1, xi, yi - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci - 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "to_visit.append((rd, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((rd, ci * 1, xi, yi - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci * 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "to_visit.append((rd, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((rd, ci + 1, xi, yi + 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi + 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "to_visit.append((rd, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((rd, ci + 1, xi, yi * 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi * 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 2] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 2] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 0] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 0] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 0] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 0] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - -1] == '.') and (not vd[ru][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - -1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 2]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 2]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 0]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 0]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 0]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 0]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[ru][ci - 1] == '.' and not vd[ru][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - -1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - -1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "to_visit.append((ru, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((ru, ci - 2, xi - 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 2, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "to_visit.append((ru, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((ru, ci - 0, xi - 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 0, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "to_visit.append((ru, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((ru, ci - 0, xi - 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 0, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "to_visit.append((ru, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((ru, ci - -1, xi - 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - -1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "to_visit.append((ru, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((ru, ci - 1, xi - 2, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 2, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "to_visit.append((ru, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((ru, ci - 1, xi - 0, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 0, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "to_visit.append((ru, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((ru, ci - 1, xi - 0, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 0, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "to_visit.append((ru, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((ru, ci - 1, xi - -1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - -1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 2] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 2] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 0] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 0] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 0] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 0] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + -1] == '.') and (not vd[ru][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + -1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 2]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 2]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 0]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 0]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 0]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 0]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[ru][ci + 1] == '.' and not vd[ru][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + -1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + -1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "to_visit.append((ru, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((ru, ci + 2, xi, yi - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 2, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "to_visit.append((ru, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((ru, ci + 0, xi, yi - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 0, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "to_visit.append((ru, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((ru, ci + 0, xi, yi - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 0, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "to_visit.append((ru, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((ru, ci + -1, xi, yi - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + -1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "to_visit.append((ru, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((ru, ci + 1, xi, yi - 2))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 2))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "to_visit.append((ru, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((ru, ci + 1, xi, yi - 0))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 0))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "to_visit.append((ru, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((ru, ci + 1, xi, yi - 0))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 0))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "to_visit.append((ru, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((ru, ci + 1, xi, yi - -1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - -1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 2] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 2] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 0] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 0] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 0] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 0] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - -1] == '.') and (not vd[rd][ci - 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - -1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 2]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 2]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 0]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 0]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 0]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 0]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if xi > 0 and ci - 1 >= 0 and labyrinth[rd][ci - 1] == '.' and not vd[rd][ci - 1]:",
      "mutated_line": "if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - -1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - -1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "to_visit.append((rd, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((rd, ci - 2, xi - 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 2, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "to_visit.append((rd, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((rd, ci - 0, xi - 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 0, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "to_visit.append((rd, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((rd, ci - 0, xi - 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 0, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "to_visit.append((rd, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((rd, ci - -1, xi - 1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - -1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "to_visit.append((rd, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((rd, ci - 1, xi - 2, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 2, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "to_visit.append((rd, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((rd, ci - 1, xi - 0, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 0, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "to_visit.append((rd, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((rd, ci - 1, xi - 0, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 0, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "to_visit.append((rd, ci - 1, xi - 1, yi))",
      "mutated_line": "to_visit.append((rd, ci - 1, xi - -1, yi))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - -1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 2] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 2] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 0] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 0] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 0] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 0] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + -1] == '.') and (not vd[rd][ci + 1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + -1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 2]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 2]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 0]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 0]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 0]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 0]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if yi > 0 and ci + 1 < m and labyrinth[rd][ci + 1] == '.' and not vd[rd][ci + 1]:",
      "mutated_line": "if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + -1]):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + -1]):\n                to_visit.append((rd, ci + 1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "to_visit.append((rd, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((rd, ci + 2, xi, yi - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 2, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "to_visit.append((rd, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((rd, ci + 0, xi, yi - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 0, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "to_visit.append((rd, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((rd, ci + 0, xi, yi - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 0, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "to_visit.append((rd, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((rd, ci + -1, xi, yi - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + -1, xi, yi - 1))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "to_visit.append((rd, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((rd, ci + 1, xi, yi - 2))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 2))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "to_visit.append((rd, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((rd, ci + 1, xi, yi - 0))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 0))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "to_visit.append((rd, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((rd, ci + 1, xi, yi - 0))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - 0))\n            rd += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "to_visit.append((rd, ci + 1, xi, yi - 1))",
      "mutated_line": "to_visit.append((rd, ci + 1, xi, yi - -1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, labyrinth):\n    r -= 1\n    c -= 1\n    vd = [[0] * m for _ in range(n)]\n    ans = 0\n    to_visit = deque()\n    to_visit.append((r, c, x, y))\n    while to_visit:\n        (ri, ci, xi, yi) = to_visit.popleft()\n        ru = ri\n        while ru >= 0 and labyrinth[ru][ci] == '.' and (not vd[ru][ci]):\n            vd[ru][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[ru][ci - 1] == '.') and (not vd[ru][ci - 1]):\n                to_visit.append((ru, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[ru][ci + 1] == '.') and (not vd[ru][ci + 1]):\n                to_visit.append((ru, ci + 1, xi, yi - 1))\n            ru -= 1\n        rd = ri + 1\n        while rd < n and labyrinth[rd][ci] == '.' and (not vd[rd][ci]):\n            vd[rd][ci] = 1\n            ans += 1\n            if xi > 0 and ci - 1 >= 0 and (labyrinth[rd][ci - 1] == '.') and (not vd[rd][ci - 1]):\n                to_visit.append((rd, ci - 1, xi - 1, yi))\n            if yi > 0 and ci + 1 < m and (labyrinth[rd][ci + 1] == '.') and (not vd[rd][ci + 1]):\n                to_visit.append((rd, ci + 1, xi, yi - -1))\n            rd += 1\n    return ans"
    }
  ]
}