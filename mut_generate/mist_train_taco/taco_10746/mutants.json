{
  "task_id": "taco_10746",
  "entry_point": "generate_tourist_attraction_matrix",
  "mutant_count": 263,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "b[2] = 1",
      "mutated_line": "b[2] = 2",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 2\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "b[2] = 1",
      "mutated_line": "b[2] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 0\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "b[2] = 1",
      "mutated_line": "b[2] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 0\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "b[2] = 1",
      "mutated_line": "b[2] = -1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = -1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b[3] = 2",
      "mutated_line": "b[3] = 3",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 3\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b[3] = 2",
      "mutated_line": "b[3] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 1\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b[3] = 2",
      "mutated_line": "b[3] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 0\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b[3] = 2",
      "mutated_line": "b[3] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 1\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b[3] = 2",
      "mutated_line": "b[3] = -2",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = -2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "can[1] = 0",
      "mutated_line": "can[1] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 1\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "can[1] = 0",
      "mutated_line": "can[1] = -1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = -1\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "can[1] = 0",
      "mutated_line": "can[1] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 1\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "can[2] = 0",
      "mutated_line": "can[2] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 1\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "can[2] = 0",
      "mutated_line": "can[2] = -1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = -1\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "can[2] = 0",
      "mutated_line": "can[2] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 1\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "x = 1",
      "mutated_line": "x = 2",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 2\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "x = 1",
      "mutated_line": "x = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 0\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "x = 1",
      "mutated_line": "x = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 0\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "x = 1",
      "mutated_line": "x = -1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = -1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "x += 1",
      "mutated_line": "x -= 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x -= 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [2 for i in range(1001)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [2 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [0 for i in range(1001)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [0 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [0 for i in range(1001)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [0 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [-1 for i in range(1001)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [-1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = [0 for i in range(n + 1)]",
      "mutated_line": "b = [1 for i in range(n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [1 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = [0 for i in range(n + 1)]",
      "mutated_line": "b = [-1 for i in range(n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [-1 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = [0 for i in range(n + 1)]",
      "mutated_line": "b = [1 for i in range(n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [1 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "b[2] = 1",
      "mutated_line": "b[3] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[3] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "b[2] = 1",
      "mutated_line": "b[1] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[1] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "b[2] = 1",
      "mutated_line": "b[0] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[0] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "b[2] = 1",
      "mutated_line": "b[1] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[1] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "b[2] = 1",
      "mutated_line": "b[-2] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[-2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b[3] = 2",
      "mutated_line": "b[4] = 2",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[4] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b[3] = 2",
      "mutated_line": "b[2] = 2",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[2] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b[3] = 2",
      "mutated_line": "b[0] = 2",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[0] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b[3] = 2",
      "mutated_line": "b[1] = 2",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[1] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b[3] = 2",
      "mutated_line": "b[-3] = 2",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[-3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "can[1] = 0",
      "mutated_line": "can[2] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[2] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "can[1] = 0",
      "mutated_line": "can[0] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[0] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "can[1] = 0",
      "mutated_line": "can[0] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[0] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "can[1] = 0",
      "mutated_line": "can[-1] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[-1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "can[2] = 0",
      "mutated_line": "can[3] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[3] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "can[2] = 0",
      "mutated_line": "can[1] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[1] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "can[2] = 0",
      "mutated_line": "can[0] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[0] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "can[2] = 0",
      "mutated_line": "can[1] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[1] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "can[2] = 0",
      "mutated_line": "can[-2] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[-2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(4, n + 1):",
      "mutated_line": "for k in range(5, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(5, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(4, n + 1):",
      "mutated_line": "for k in range(3, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(3, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(4, n + 1):",
      "mutated_line": "for k in range(0, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(0, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(4, n + 1):",
      "mutated_line": "for k in range(1, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(1, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(4, n + 1):",
      "mutated_line": "for k in range(-4, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(-4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for k in range(4, n + 1):",
      "mutated_line": "for k in range(4, n - 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n - 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for k in range(4, n + 1):",
      "mutated_line": "for k in range(4, n * 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n * 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b[k] = b[k - 1] + 1",
      "mutated_line": "b[k] = b[k - 1] - 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] - 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b[k] = b[k - 1] + 1",
      "mutated_line": "b[k] = b[k - 1] * 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] * 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "b[k] += 1",
      "mutated_line": "b[k] -= 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] -= 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "can[b[k]] = 0",
      "mutated_line": "can[b[k]] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 1\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "can[b[k]] = 0",
      "mutated_line": "can[b[k]] = -1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = -1\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "can[b[k]] = 0",
      "mutated_line": "can[b[k]] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 1\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [2 for i in range(1001)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [2 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [0 for i in range(1001)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [0 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [0 for i in range(1001)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [0 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [-1 for i in range(1001)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [-1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(3, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(3, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(1, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(0, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(1, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(-2, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(-2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n - 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n - 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n * 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n * 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "x += 1",
      "mutated_line": "x += 2",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 2\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "x += 1",
      "mutated_line": "x += 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 0\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "x += 1",
      "mutated_line": "x += 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 0\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "x += 1",
      "mutated_line": "x += -1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += -1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n - 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n - 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n * 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(3, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(3, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(0, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(-2, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(-2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n - 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n - 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n * 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n * 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(4, n + 1):",
      "mutated_line": "for k in range(4, n + 2):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 2):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(4, n + 1):",
      "mutated_line": "for k in range(4, n + 0):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 0):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(4, n + 1):",
      "mutated_line": "for k in range(4, n + 0):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 0):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(4, n + 1):",
      "mutated_line": "for k in range(4, n + -1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + -1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b[k] = b[k - 1] + 1",
      "mutated_line": "b[k] = b[k - 1] + 2",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 2\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b[k] = b[k - 1] + 1",
      "mutated_line": "b[k] = b[k - 1] + 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 0\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b[k] = b[k - 1] + 1",
      "mutated_line": "b[k] = b[k - 1] + 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 0\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b[k] = b[k - 1] + 1",
      "mutated_line": "b[k] = b[k - 1] + -1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + -1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b[k] += 1",
      "mutated_line": "b[k] += 2",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 2\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b[k] += 1",
      "mutated_line": "b[k] += 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 0\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b[k] += 1",
      "mutated_line": "b[k] += 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 0\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b[k] += 1",
      "mutated_line": "b[k] += -1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += -1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, k):",
      "mutated_line": "for i in range(3, k):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(3, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, k):",
      "mutated_line": "for i in range(1, k):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(1, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, k):",
      "mutated_line": "for i in range(0, k):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(0, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, k):",
      "mutated_line": "for i in range(1, k):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(1, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(2, k):",
      "mutated_line": "for i in range(-2, k):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(-2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 2):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 2):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 0):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 0):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + -1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + -1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(2, n + 1):",
      "mutated_line": "for j in range(3, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(3, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(2, n + 1):",
      "mutated_line": "for j in range(1, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(1, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(2, n + 1):",
      "mutated_line": "for j in range(0, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(0, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(2, n + 1):",
      "mutated_line": "for j in range(1, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(1, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(2, n + 1):",
      "mutated_line": "for j in range(-2, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(-2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for j in range(2, n + 1):",
      "mutated_line": "for j in range(2, n - 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n - 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for j in range(2, n + 1):",
      "mutated_line": "for j in range(2, n * 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n * 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[1 for j in range(n + 1)] for i in range(n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[1 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[-1 for j in range(n + 1)] for i in range(n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[-1 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[1 for j in range(n + 1)] for i in range(n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[1 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 2):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 2):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 0):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 0):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + -1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + -1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "a[1][i] = a[i][1] = b[i]",
      "mutated_line": "a[1][i] = a[i][2] = b[i]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][2] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "a[1][i] = a[i][1] = b[i]",
      "mutated_line": "a[1][i] = a[i][0] = b[i]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][0] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "a[1][i] = a[i][1] = b[i]",
      "mutated_line": "a[1][i] = a[i][0] = b[i]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][0] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "a[1][i] = a[i][1] = b[i]",
      "mutated_line": "a[1][i] = a[i][-1] = b[i]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][-1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 2):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 2):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 0):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + 0):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 0):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(2, n + 1):",
      "mutated_line": "for i in range(2, n + -1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + -1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i - 1, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i - 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i * 1, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i * 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 1, n - 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n - 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 1, n * 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n * 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] + b[3]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] + b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = (b[i] + b[j] + x - b[2]) * b[3]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = (b[i] + b[j] + x - b[2]) * b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(2, n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(2, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(0, n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(0, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(0, n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(0, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(-1, n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(-1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n - 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n - 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n * 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n * 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [1 for i in range(1002)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1002)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [1 for i in range(1000)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1000)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [1 for i in range(0)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(0)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [1 for i in range(1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [1 for i in range(-1001)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(-1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "b = [0 for i in range(n + 1)]",
      "mutated_line": "b = [0 for i in range(n - 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n - 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "b = [0 for i in range(n + 1)]",
      "mutated_line": "b = [0 for i in range(n * 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n * 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b[k] = b[k - 1] + 1",
      "mutated_line": "b[k] = b[k + 1] + 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k + 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b[k] = b[k - 1] + 1",
      "mutated_line": "b[k] = b[k * 1] + 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k * 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for p in range(2, k):",
      "mutated_line": "for p in range(3, k):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(3, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for p in range(2, k):",
      "mutated_line": "for p in range(1, k):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(1, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for p in range(2, k):",
      "mutated_line": "for p in range(0, k):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(0, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for p in range(2, k):",
      "mutated_line": "for p in range(1, k):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(1, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for p in range(2, k):",
      "mutated_line": "for p in range(-2, k):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(-2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "can[b[k] + b[p] - b[i]] = 0",
      "mutated_line": "can[b[k] + b[p] - b[i]] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 1\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "can[b[k] + b[p] - b[i]] = 0",
      "mutated_line": "can[b[k] + b[p] - b[i]] = -1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = -1\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "can[b[k] + b[p] - b[i]] = 0",
      "mutated_line": "can[b[k] + b[p] - b[i]] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 1\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [1 for i in range(1002)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1002)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [1 for i in range(1000)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1000)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [1 for i in range(0)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(0)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [1 for i in range(1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "can = [1 for i in range(1001)]",
      "mutated_line": "can = [1 for i in range(-1001)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(-1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(2, n + 1):",
      "mutated_line": "for j in range(2, n + 2):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 2):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(2, n + 1):",
      "mutated_line": "for j in range(2, n + 0):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 0):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(2, n + 1):",
      "mutated_line": "for j in range(2, n + 0):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 0):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(2, n + 1):",
      "mutated_line": "for j in range(2, n + -1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + -1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for p in range(2, n + 1):",
      "mutated_line": "for p in range(3, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(3, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for p in range(2, n + 1):",
      "mutated_line": "for p in range(1, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(1, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for p in range(2, n + 1):",
      "mutated_line": "for p in range(0, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(0, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for p in range(2, n + 1):",
      "mutated_line": "for p in range(1, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(1, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for p in range(2, n + 1):",
      "mutated_line": "for p in range(-2, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(-2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for p in range(2, n + 1):",
      "mutated_line": "for p in range(2, n - 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n - 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for p in range(2, n + 1):",
      "mutated_line": "for p in range(2, n * 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n * 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 1\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = -1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = -1\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 1\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[0 for j in range(n + 1)] for i in range(n - 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n - 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[0 for j in range(n + 1)] for i in range(n * 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n * 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "a[1][i] = a[i][1] = b[i]",
      "mutated_line": "a[2][i] = a[i][1] = b[i]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[2][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "a[1][i] = a[i][1] = b[i]",
      "mutated_line": "a[0][i] = a[i][1] = b[i]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[0][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "a[1][i] = a[i][1] = b[i]",
      "mutated_line": "a[0][i] = a[i][1] = b[i]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[0][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "a[1][i] = a[i][1] = b[i]",
      "mutated_line": "a[-1][i] = a[i][1] = b[i]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[-1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 2, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 2, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 0, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 0, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 0, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 0, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + -1, n + 1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + -1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 1, n + 2):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 2):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 1, n + 0):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 0):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 1, n + 0):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 0):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 1, n + -1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + -1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] + b[j] + x + b[2] - b[3]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x + b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = (b[i] + b[j] + x) * b[2] - b[3]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = (b[i] + b[j] + x) * b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(2, n + 1)] for i in range(1, n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(2, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(0, n + 1)] for i in range(1, n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(0, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(0, n + 1)] for i in range(1, n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(0, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(-1, n + 1)] for i in range(1, n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(-1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n - 1)] for i in range(1, n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n - 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n * 1)] for i in range(1, n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n * 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 2)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 2)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 0)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 0)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 0)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 0)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + -1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + -1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = [0 for i in range(n + 1)]",
      "mutated_line": "b = [0 for i in range(n + 2)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 2)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = [0 for i in range(n + 1)]",
      "mutated_line": "b = [0 for i in range(n + 0)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 0)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = [0 for i in range(n + 1)]",
      "mutated_line": "b = [0 for i in range(n + 0)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 0)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = [0 for i in range(n + 1)]",
      "mutated_line": "b = [0 for i in range(n + -1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + -1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b[k] = b[k - 1] + 1",
      "mutated_line": "b[k] = b[k - 2] + 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 2] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b[k] = b[k - 1] + 1",
      "mutated_line": "b[k] = b[k - 0] + 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 0] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b[k] = b[k - 1] + 1",
      "mutated_line": "b[k] = b[k - 0] + 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 0] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b[k] = b[k - 1] + 1",
      "mutated_line": "b[k] = b[k - -1] + 1",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - -1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "can[b[k] + b[p] - b[i]] = 0",
      "mutated_line": "can[b[k] + b[p] + b[i]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] + b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "can[b[k] + b[p] - b[i]] = 0",
      "mutated_line": "can[(b[k] + b[p]) * b[i]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[(b[k] + b[p]) * b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for p in range(2, n + 1):",
      "mutated_line": "for p in range(2, n + 2):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 2):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for p in range(2, n + 1):",
      "mutated_line": "for p in range(2, n + 0):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 0):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for p in range(2, n + 1):",
      "mutated_line": "for p in range(2, n + 0):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 0):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for p in range(2, n + 1):",
      "mutated_line": "for p in range(2, n + -1):",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + -1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[2] + b[3] + b[p] - b[i] + b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] + b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[(b[2] + b[3] + b[p] - b[i]) * b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[(b[2] + b[3] + b[p] - b[i]) * b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[0 for j in range(n - 1)] for i in range(n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n - 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[0 for j in range(n * 1)] for i in range(n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n * 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[0 for j in range(n + 1)] for i in range(n + 2)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 2)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[0 for j in range(n + 1)] for i in range(n + 0)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 0)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[0 for j in range(n + 1)] for i in range(n + 0)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 0)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[0 for j in range(n + 1)] for i in range(n + -1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + -1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] + b[j] - x - b[2] - b[3]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] - x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = (b[i] + b[j]) * x - b[2] - b[3]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = (b[i] + b[j]) * x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[4]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[4]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[2]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[2]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[0]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[0]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[1]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[1]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[-3]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[-3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n + 2)] for i in range(1, n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 2)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n + 0)] for i in range(1, n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 0)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n + 0)] for i in range(1, n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 0)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]",
      "mutated_line": "result = [[a[i][j] for j in range(1, n + -1)] for i in range(1, n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + -1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "can[b[k] + b[p] - b[i]] = 0",
      "mutated_line": "can[b[k] - b[p] - b[i]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] - b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "can[b[k] + b[p] - b[i]] = 0",
      "mutated_line": "can[b[k] * b[p] - b[i]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] * b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[2] + b[3] + b[p] + b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] + b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[(b[2] + b[3] + b[p]) * b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[(b[2] + b[3] + b[p]) * b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[0 for j in range(n + 2)] for i in range(n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 2)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[0 for j in range(n + 0)] for i in range(n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 0)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[0 for j in range(n + 0)] for i in range(n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 0)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "a = [[0 for j in range(n + 1)] for i in range(n + 1)]",
      "mutated_line": "a = [[0 for j in range(n + -1)] for i in range(n + 1)]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + -1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] - b[j] + x - b[2] - b[3]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] - b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] * b[j] + x - b[2] - b[3]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] * b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[3] - b[3]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[3] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[1] - b[3]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[1] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[0] - b[3]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[0] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[1] - b[3]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[1] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]",
      "mutated_line": "a[i][j] = a[j][i] = b[i] + b[j] + x - b[-2] - b[3]",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[-2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[2] + b[3] - b[p] - b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[3] - b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[(b[2] + b[3]) * b[p] - b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[(b[2] + b[3]) * b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[2] - b[3] + b[p] - b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] - b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[2] * b[3] + b[p] - b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] * b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[3] + b[3] + b[p] - b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[3] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[1] + b[3] + b[p] - b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[1] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[0] + b[3] + b[p] - b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[0] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[1] + b[3] + b[p] - b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[1] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[-2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[-2] + b[3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[2] + b[4] + b[p] - b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[4] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[2] + b[2] + b[p] - b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[2] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[2] + b[0] + b[p] - b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[0] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[2] + b[1] + b[p] - b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[1] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "can[b[2] + b[3] + b[p] - b[i] - b[j]] = 0",
      "mutated_line": "can[b[2] + b[-3] + b[p] - b[i] - b[j]] = 0",
      "code": "def generate_tourist_attraction_matrix(n):\n    \"\"\"\n    Generates an adjacency matrix for a graph of n tourist attractions where each cycle visiting all attractions exactly once has the same total price.\n\n    Parameters:\n    n (int): The number of tourist attractions (3 ≤ n ≤ 20).\n\n    Returns:\n    list: A 2D list representing the adjacency matrix of the graph.\n    \"\"\"\n\n    def constructRow(n):\n        can = [1 for i in range(1001)]\n        b = [0 for i in range(n + 1)]\n        b[2] = 1\n        b[3] = 2\n        can[1] = 0\n        can[2] = 0\n        for k in range(4, n + 1):\n            b[k] = b[k - 1] + 1\n            while not can[b[k]]:\n                b[k] += 1\n            can[b[k]] = 0\n            for i in range(2, k):\n                for p in range(2, k):\n                    can[b[k] + b[p] - b[i]] = 0\n        return b\n\n    def constructMatrix(b, n):\n        can = [1 for i in range(1001)]\n        for i in range(2, n + 1):\n            for j in range(2, n + 1):\n                for p in range(2, n + 1):\n                    can[b[2] + b[-3] + b[p] - b[i] - b[j]] = 0\n        x = 1\n        while not can[x]:\n            x += 1\n        a = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        for i in range(n + 1):\n            a[1][i] = a[i][1] = b[i]\n        for i in range(2, n + 1):\n            for j in range(i + 1, n + 1):\n                a[i][j] = a[j][i] = b[i] + b[j] + x - b[2] - b[3]\n        return a\n    b = constructRow(n)\n    a = constructMatrix(b, n)\n    result = [[a[i][j] for j in range(1, n + 1)] for i in range(1, n + 1)]\n    return result"
    }
  ]
}