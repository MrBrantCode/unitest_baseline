{
  "task_id": "taco_6983",
  "entry_point": "max_black_rectangle_area",
  "mutant_count": 122,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "T = [[0] * (W - 1)]",
      "mutated_line": "T = [[0] / (W - 1)]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] / (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "T = [[0] * (W - 1)]",
      "mutated_line": "T = [[0] + (W - 1)]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] + (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "T = [[0] * (W - 1)]",
      "mutated_line": "T = [[0] ** (W - 1)]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] ** (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(H - 1):",
      "mutated_line": "(t, ts) = ([], [])",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H + 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(H - 1):",
      "mutated_line": "(t, ts) = ([], [])",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H * 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "T = [[0] * (W - 1)]",
      "mutated_line": "T = [[0] * (W + 1)]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W + 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "T = [[0] * (W - 1)]",
      "mutated_line": "T = [[0] * (W * 1)]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W * 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(H - 1):",
      "mutated_line": "(t, ts) = ([], [])",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 2):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(H - 1):",
      "mutated_line": "(t, ts) = ([], [])",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 0):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(H - 1):",
      "mutated_line": "(t, ts) = ([], [])",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 0):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(H - 1):",
      "mutated_line": "(t, ts) = ([], [])",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - -1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for j in range(W - 1):",
      "mutated_line": "for j in range(W + 1):",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W + 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for j in range(W - 1):",
      "mutated_line": "for j in range(W * 1):",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W * 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] - S[i + 1][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] - S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] * S[i + 1][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] * S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if t[j] == 0:",
      "mutated_line": "if t[j] != 0:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] != 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for L in T[1:]:",
      "mutated_line": "for L in T[2:]:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[2:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for L in T[1:]:",
      "mutated_line": "for L in T[0:]:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[0:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for L in T[1:]:",
      "mutated_line": "for L in T[0:]:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[0:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for L in T[1:]:",
      "mutated_line": "for L in T[-1:]:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[-1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i, l in enumerate(L + [0]):",
      "mutated_line": "for (i, l) in enumerate(L - [0]):",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L - [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i, l in enumerate(L + [0]):",
      "mutated_line": "for (i, l) in enumerate(L * [0]):",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L * [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "w = -1",
      "mutated_line": "w = +1",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = +1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "while stack and stack[-1][1] >= l:",
      "mutated_line": "while stack or stack[-1][1] >= l:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack or stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if w != -1:",
      "mutated_line": "if w == -1:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w == -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "T = [[0] * (W - 1)]",
      "mutated_line": "T = [[1] * (W - 1)]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[1] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "T = [[0] * (W - 1)]",
      "mutated_line": "T = [[-1] * (W - 1)]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[-1] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "T = [[0] * (W - 1)]",
      "mutated_line": "T = [[1] * (W - 1)]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[1] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "T = [[0] * (W - 1)]",
      "mutated_line": "T = [[0] * (W - 2)]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 2)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "T = [[0] * (W - 1)]",
      "mutated_line": "T = [[0] * (W - 0)]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 0)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "T = [[0] * (W - 1)]",
      "mutated_line": "T = [[0] * (W - 0)]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 0)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "T = [[0] * (W - 1)]",
      "mutated_line": "T = [[0] * (W - -1)]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - -1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(W - 1):",
      "mutated_line": "for j in range(W - 2):",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 2):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(W - 1):",
      "mutated_line": "for j in range(W - 0):",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 0):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(W - 1):",
      "mutated_line": "for j in range(W - 0):",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 0):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(W - 1):",
      "mutated_line": "for j in range(W - -1):",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - -1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "t.append(r.count('.') % 2)",
      "mutated_line": "t.append(r.count('.') * 2)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') * 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "t.append(r.count('.') % 2)",
      "mutated_line": "t.append(r.count('.') + 2)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') + 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if t[j] == 0:",
      "mutated_line": "if t[j] == 1:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 1:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if t[j] == 0:",
      "mutated_line": "if t[j] == -1:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == -1:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if t[j] == 0:",
      "mutated_line": "if t[j] == 1:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 1:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "w = -1",
      "mutated_line": "w = -2",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -2\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "w = -1",
      "mutated_line": "w = -0",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -0\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "w = -1",
      "mutated_line": "w = -0",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -0\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "w = -1",
      "mutated_line": "w = --1",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = --1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while stack and stack[-1][1] >= l:",
      "mutated_line": "while stack and stack[-1][1] > l:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] > l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while stack and stack[-1][1] >= l:",
      "mutated_line": "while stack and stack[-1][1] < l:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] < l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while stack and stack[-1][1] >= l:",
      "mutated_line": "while stack and stack[-1][1] == l:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] == l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "if w != -1:",
      "mutated_line": "if w != +1:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != +1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t.append(r.count('.') % 2)",
      "mutated_line": "t.append(r.count('.') % 3)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 3)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t.append(r.count('.') % 2)",
      "mutated_line": "t.append(r.count('.') % 1)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 1)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t.append(r.count('.') % 2)",
      "mutated_line": "t.append(r.count('.') % 0)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 0)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t.append(r.count('.') % 2)",
      "mutated_line": "t.append(r.count('.') % 1)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 1)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t.append(r.count('.') % 2)",
      "mutated_line": "t.append(r.count('.') % -2)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % -2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ts.append(T[-1][j] + 1)",
      "mutated_line": "ts.append(T[-1][j] - 1)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] - 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ts.append(T[-1][j] + 1)",
      "mutated_line": "ts.append(T[-1][j] * 1)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] * 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ts.append(0)",
      "mutated_line": "ts.append(1)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(1)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ts.append(0)",
      "mutated_line": "ts.append(-1)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(-1)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ts.append(0)",
      "mutated_line": "ts.append(1)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(1)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i, l in enumerate(L + [0]):",
      "mutated_line": "for (i, l) in enumerate(L + [1]):",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [1]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i, l in enumerate(L + [0]):",
      "mutated_line": "for (i, l) in enumerate(L + [-1]):",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [-1]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i, l in enumerate(L + [0]):",
      "mutated_line": "for (i, l) in enumerate(L + [1]):",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [1]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h + 1) / (i - w + 1))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) / (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, h + 1 + (i - w + 1))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, h + 1 + (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h + 1) ** (i - w + 1))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) ** (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if w != -1:",
      "mutated_line": "if w != -2:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -2:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if w != -1:",
      "mutated_line": "if w != -0:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -0:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if w != -1:",
      "mutated_line": "if w != -0:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -0:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if w != -1:",
      "mutated_line": "if w != --1:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != --1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j - 2] + S[i + 1][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j - 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j * 2] + S[i + 1][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j * 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] + S[i - 1][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i - 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] + S[i * 1][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i * 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] + S[i + 1][j:j - 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j - 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] + S[i + 1][j:j * 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j * 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "t.append(r.count('.') % 2)",
      "mutated_line": "t.append(r.count('') % 2)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ts.append(T[-1][j] + 1)",
      "mutated_line": "ts.append(T[-1][j] + 2)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 2)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ts.append(T[-1][j] + 1)",
      "mutated_line": "ts.append(T[-1][j] + 0)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 0)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ts.append(T[-1][j] + 1)",
      "mutated_line": "ts.append(T[-1][j] + 0)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 0)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ts.append(T[-1][j] + 1)",
      "mutated_line": "ts.append(T[-1][j] + -1)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + -1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while stack and stack[-1][1] >= l:",
      "mutated_line": "while stack and stack[-1][2] >= l:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][2] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while stack and stack[-1][1] >= l:",
      "mutated_line": "while stack and stack[-1][0] >= l:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][0] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while stack and stack[-1][1] >= l:",
      "mutated_line": "while stack and stack[-1][0] >= l:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][0] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while stack and stack[-1][1] >= l:",
      "mutated_line": "while stack and stack[-1][-1] >= l:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][-1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h - 1) * (i - w + 1))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h - 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, h * 1 * (i - w + 1))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, h * 1 * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h + 1) * (i - w - 1))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w - 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h + 1) * ((i - w) * 1))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * ((i - w) * 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 3] + S[i + 1][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 3] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 1] + S[i + 1][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 1] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 0] + S[i + 1][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 0] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 1] + S[i + 1][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 1] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + -2] + S[i + 1][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + -2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] + S[i + 2][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 2][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] + S[i + 0][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 0][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] + S[i + 0][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 0][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] + S[i + -1][j:j + 2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + -1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 3]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 3]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 1]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 1]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 0]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 0]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 1]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 1]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "r = S[i][j:j + 2] + S[i + 1][j:j + 2]",
      "mutated_line": "r = S[i][j:j + 2] + S[i + 1][j:j + -2]",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + -2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "while stack and stack[-1][1] >= l:",
      "mutated_line": "while stack and stack[+1][1] >= l:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[+1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h + 2) * (i - w + 1))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 2) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h + 0) * (i - w + 1))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 0) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h + 0) * (i - w + 1))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 0) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h + -1) * (i - w + 1))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + -1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h + 1) * (i + w + 1))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i + w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h + 1) * (i * w + 1))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i * w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h + 1) * (i - w + 2))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 2))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h + 1) * (i - w + 0))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 0))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h + 1) * (i - w + 0))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 0))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = max(ans, (h + 1) * (i - w + 1))",
      "mutated_line": "ans = max(ans, (h + 1) * (i - w + -1))",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + -1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "ts.append(T[-1][j] + 1)",
      "mutated_line": "ts.append(T[+1][j] + 1)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[+1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while stack and stack[-1][1] >= l:",
      "mutated_line": "while stack and stack[-2][1] >= l:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-2][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while stack and stack[-1][1] >= l:",
      "mutated_line": "while stack and stack[-0][1] >= l:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-0][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while stack and stack[-1][1] >= l:",
      "mutated_line": "while stack and stack[-0][1] >= l:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-0][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while stack and stack[-1][1] >= l:",
      "mutated_line": "while stack and stack[--1][1] >= l:",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[--1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ts.append(T[-1][j] + 1)",
      "mutated_line": "ts.append(T[-2][j] + 1)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-2][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ts.append(T[-1][j] + 1)",
      "mutated_line": "ts.append(T[-0][j] + 1)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-0][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ts.append(T[-1][j] + 1)",
      "mutated_line": "ts.append(T[-0][j] + 1)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[-0][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ts.append(T[-1][j] + 1)",
      "mutated_line": "ts.append(T[--1][j] + 1)",
      "code": "def max_black_rectangle_area(H, W, S):\n    ans = max(H, W)\n    T = [[0] * (W - 1)]\n    for i in range(H - 1):\n        (t, ts) = ([], [])\n        for j in range(W - 1):\n            r = S[i][j:j + 2] + S[i + 1][j:j + 2]\n            t.append(r.count('.') % 2)\n            if t[j] == 0:\n                ts.append(T[--1][j] + 1)\n            else:\n                ts.append(0)\n        T.append(ts)\n    for L in T[1:]:\n        stack = []\n        for (i, l) in enumerate(L + [0]):\n            w = -1\n            while stack and stack[-1][1] >= l:\n                (w, h) = stack.pop()\n                ans = max(ans, (h + 1) * (i - w + 1))\n            if w != -1:\n                stack.append((w, l))\n                continue\n            stack.append((i, l))\n    return ans"
    }
  ]
}