{
  "task_id": "taco_2999",
  "entry_point": "sort_array_with_cyclic_shifts",
  "mutant_count": 97,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "for i in range(len(sliced) - 1):",
      "mutated_line": "for i in range(len(sliced) + 1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) + 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "for i in range(len(sliced) - 1):",
      "mutated_line": "for i in range(len(sliced) * 1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) * 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n + 1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n + 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n * 1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n * 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "end = 0",
      "mutated_line": "end = 1",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 1\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "end = 0",
      "mutated_line": "end = -1",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = -1\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "end = 0",
      "mutated_line": "end = 1",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 1\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "start = 0",
      "mutated_line": "start = 1",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 1\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "start = 0",
      "mutated_line": "start = -1",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = -1\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "start = 0",
      "mutated_line": "start = 1",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 1\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if a[j + 1] < a[j]:",
      "mutated_line": "if a[j + 1] <= a[j]:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] <= a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if a[j + 1] < a[j]:",
      "mutated_line": "if a[j + 1] >= a[j]:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] >= a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if a[j + 1] < a[j]:",
      "mutated_line": "if a[j + 1] != a[j]:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] != a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if end > start:",
      "mutated_line": "if end >= start:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end >= start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if end > start:",
      "mutated_line": "if end <= start:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end <= start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if end > start:",
      "mutated_line": "if end != start:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end != start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "rotated = [sliced[len(sliced) - 1]]",
      "mutated_line": "rotated = [sliced[len(sliced) + 1]]",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) + 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "rotated = [sliced[len(sliced) - 1]]",
      "mutated_line": "rotated = [sliced[len(sliced) * 1]]",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) * 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(sliced) - 1):",
      "mutated_line": "for i in range(len(sliced) - 2):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 2):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(sliced) - 1):",
      "mutated_line": "for i in range(len(sliced) - 0):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 0):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(sliced) - 1):",
      "mutated_line": "for i in range(len(sliced) - 0):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 0):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(sliced) - 1):",
      "mutated_line": "for i in range(len(sliced) - -1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - -1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n - 2):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 2):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n - 0):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 0):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n - 0):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 0):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n - -1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - -1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "end = j + 1",
      "mutated_line": "end = j - 1",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j - 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "end = j + 1",
      "mutated_line": "end = j * 1",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j * 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "rotated = [sliced[len(sliced) - 1]]",
      "mutated_line": "rotated = [sliced[len(sliced) - 2]]",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 2]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "rotated = [sliced[len(sliced) - 1]]",
      "mutated_line": "rotated = [sliced[len(sliced) - 0]]",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 0]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "rotated = [sliced[len(sliced) - 1]]",
      "mutated_line": "rotated = [sliced[len(sliced) - 0]]",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 0]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "rotated = [sliced[len(sliced) - 1]]",
      "mutated_line": "rotated = [sliced[len(sliced) - -1]]",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - -1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if a[j + 1] < a[j]:",
      "mutated_line": "if a[j - 1] < a[j]:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j - 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if a[j + 1] < a[j]:",
      "mutated_line": "if a[j * 1] < a[j]:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j * 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "end = j + 1",
      "mutated_line": "end = j + 2",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 2\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "end = j + 1",
      "mutated_line": "end = j + 0",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 0\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "end = j + 1",
      "mutated_line": "end = j + 0",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 0\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "end = j + 1",
      "mutated_line": "end = j + -1",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + -1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end + 1, -1, -1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end + 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end * 1, -1, -1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end * 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end - 1, +1, -1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, +1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end - 1, -1, +1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, +1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if a[x] >= a[end]:",
      "mutated_line": "if a[x] > a[end]:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] > a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if a[x] >= a[end]:",
      "mutated_line": "if a[x] < a[end]:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] < a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if a[x] >= a[end]:",
      "mutated_line": "if a[x] == a[end]:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] == a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "shifts.append(len(a[start:end + 1]) - 1)",
      "mutated_line": "shifts.append(len(a[start:end + 1]) + 1)",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) + 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "shifts.append(len(a[start:end + 1]) - 1)",
      "mutated_line": "shifts.append(len(a[start:end + 1]) * 1)",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) * 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if a[j + 1] < a[j]:",
      "mutated_line": "if a[j + 2] < a[j]:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 2] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if a[j + 1] < a[j]:",
      "mutated_line": "if a[j + 0] < a[j]:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 0] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if a[j + 1] < a[j]:",
      "mutated_line": "if a[j + 0] < a[j]:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 0] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if a[j + 1] < a[j]:",
      "mutated_line": "if a[j + -1] < a[j]:",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + -1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end - 2, -1, -1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 2, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end - 0, -1, -1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 0, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end - 0, -1, -1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 0, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end - -1, -1, -1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - -1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end - 1, -2, -1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -2, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end - 1, -0, -1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -0, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end - 1, -0, -1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -0, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end - 1, --1, -1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, --1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end - 1, -1, -2):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -2):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end - 1, -1, -0):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -0):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end - 1, -1, -0):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -0):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for x in range(end - 1, -1, -1):",
      "mutated_line": "for x in range(end - 1, -1, --1):",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, --1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans.append([start + 1, end + 1])",
      "mutated_line": "ans.append([start - 1, end + 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start - 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans.append([start + 1, end + 1])",
      "mutated_line": "ans.append([start * 1, end + 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start * 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans.append([start + 1, end + 1])",
      "mutated_line": "ans.append([start + 1, end - 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end - 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans.append([start + 1, end + 1])",
      "mutated_line": "ans.append([start + 1, end * 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end * 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "a[start:end + 1] = rotate(a[start:end + 1])",
      "mutated_line": "a[start:end - 1] = rotate(a[start:end + 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end - 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "a[start:end + 1] = rotate(a[start:end + 1])",
      "mutated_line": "a[start:end * 1] = rotate(a[start:end + 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end * 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "shifts.append(len(a[start:end + 1]) - 1)",
      "mutated_line": "shifts.append(len(a[start:end + 1]) - 2)",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 2)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "shifts.append(len(a[start:end + 1]) - 1)",
      "mutated_line": "shifts.append(len(a[start:end + 1]) - 0)",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 0)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "shifts.append(len(a[start:end + 1]) - 1)",
      "mutated_line": "shifts.append(len(a[start:end + 1]) - 0)",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 0)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "shifts.append(len(a[start:end + 1]) - 1)",
      "mutated_line": "shifts.append(len(a[start:end + 1]) - -1)",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - -1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans.append([start + 1, end + 1])",
      "mutated_line": "ans.append([start + 2, end + 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 2, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans.append([start + 1, end + 1])",
      "mutated_line": "ans.append([start + 0, end + 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 0, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans.append([start + 1, end + 1])",
      "mutated_line": "ans.append([start + 0, end + 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 0, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans.append([start + 1, end + 1])",
      "mutated_line": "ans.append([start + -1, end + 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + -1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans.append([start + 1, end + 1])",
      "mutated_line": "ans.append([start + 1, end + 2])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 2])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans.append([start + 1, end + 1])",
      "mutated_line": "ans.append([start + 1, end + 0])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 0])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans.append([start + 1, end + 1])",
      "mutated_line": "ans.append([start + 1, end + 0])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 0])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans.append([start + 1, end + 1])",
      "mutated_line": "ans.append([start + 1, end + -1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + -1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "a[start:end + 1] = rotate(a[start:end + 1])",
      "mutated_line": "a[start:end + 2] = rotate(a[start:end + 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 2] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "a[start:end + 1] = rotate(a[start:end + 1])",
      "mutated_line": "a[start:end + 0] = rotate(a[start:end + 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 0] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "a[start:end + 1] = rotate(a[start:end + 1])",
      "mutated_line": "a[start:end + 0] = rotate(a[start:end + 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 0] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "a[start:end + 1] = rotate(a[start:end + 1])",
      "mutated_line": "a[start:end + -1] = rotate(a[start:end + 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + -1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "a[start:end + 1] = rotate(a[start:end + 1])",
      "mutated_line": "a[start:end + 1] = rotate(a[start:end - 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end - 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "a[start:end + 1] = rotate(a[start:end + 1])",
      "mutated_line": "a[start:end + 1] = rotate(a[start:end * 1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end * 1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "a[start:end + 1] = rotate(a[start:end + 1])",
      "mutated_line": "a[start:end + 1] = rotate(a[start:end + 2])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 2])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "a[start:end + 1] = rotate(a[start:end + 1])",
      "mutated_line": "a[start:end + 1] = rotate(a[start:end + 0])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 0])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "a[start:end + 1] = rotate(a[start:end + 1])",
      "mutated_line": "a[start:end + 1] = rotate(a[start:end + 0])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 0])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "a[start:end + 1] = rotate(a[start:end + 1])",
      "mutated_line": "a[start:end + 1] = rotate(a[start:end + -1])",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + -1])\n                shifts.append(len(a[start:end + 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "shifts.append(len(a[start:end + 1]) - 1)",
      "mutated_line": "shifts.append(len(a[start:end - 1]) - 1)",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end - 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "shifts.append(len(a[start:end + 1]) - 1)",
      "mutated_line": "shifts.append(len(a[start:end * 1]) - 1)",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end * 1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "shifts.append(len(a[start:end + 1]) - 1)",
      "mutated_line": "shifts.append(len(a[start:end + 2]) - 1)",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 2]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "shifts.append(len(a[start:end + 1]) - 1)",
      "mutated_line": "shifts.append(len(a[start:end + 0]) - 1)",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 0]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "shifts.append(len(a[start:end + 1]) - 1)",
      "mutated_line": "shifts.append(len(a[start:end + 0]) - 1)",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + 0]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "shifts.append(len(a[start:end + 1]) - 1)",
      "mutated_line": "shifts.append(len(a[start:end + -1]) - 1)",
      "code": "def sort_array_with_cyclic_shifts(a, n):\n\n    def rotate(sliced):\n        rotated = [sliced[len(sliced) - 1]]\n        for i in range(len(sliced) - 1):\n            rotated.append(sliced[i])\n        return rotated\n    ans = []\n    shifts = []\n    for i in range(n):\n        for j in range(n - 1):\n            end = 0\n            start = 0\n            if a[j + 1] < a[j]:\n                end = j + 1\n                for x in range(end - 1, -1, -1):\n                    if a[x] >= a[end]:\n                        start = x\n                    else:\n                        break\n            if end > start:\n                ans.append([start + 1, end + 1])\n                a[start:end + 1] = rotate(a[start:end + 1])\n                shifts.append(len(a[start:end + -1]) - 1)\n                break\n    actions = []\n    for p in range(len(ans)):\n        ans[p].append(shifts[p])\n        actions.append(tuple(ans[p]))\n    return (len(actions), actions)"
    }
  ]
}