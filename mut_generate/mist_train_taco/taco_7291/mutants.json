{
  "task_id": "taco_7291",
  "entry_point": "calculate_treasure_distances",
  "mutant_count": 311,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] / (M + 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] / (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] + (M + 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] + (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] ** (M + 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] ** (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] / (M + 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] / (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] + (M + 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] + (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] ** (M + 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] ** (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mat[x][y] = 1",
      "mutated_line": "mat[x][y] = 2",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 2\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mat[x][y] = 1",
      "mutated_line": "mat[x][y] = 0",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 0\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mat[x][y] = 1",
      "mutated_line": "mat[x][y] = 0",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 0\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mat[x][y] = 1",
      "mutated_line": "mat[x][y] = -1",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = -1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans[x][y] = 0",
      "mutated_line": "ans[x][y] = 1",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 1\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans[x][y] = 0",
      "mutated_line": "ans[x][y] = -1",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = -1\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans[x][y] = 0",
      "mutated_line": "ans[x][y] = 1",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 1\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mat[u][v] = 1000000000",
      "mutated_line": "mat[u][v] = 1000000001",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000001\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mat[u][v] = 1000000000",
      "mutated_line": "mat[u][v] = 999999999",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 999999999\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mat[u][v] = 1000000000",
      "mutated_line": "mat[u][v] = 0",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 0\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mat[u][v] = 1000000000",
      "mutated_line": "mat[u][v] = 1",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mat[u][v] = 1000000000",
      "mutated_line": "mat[u][v] = -1000000000",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = -1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans[u][v] = 1000000000",
      "mutated_line": "ans[u][v] = 1000000001",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000001\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans[u][v] = 1000000000",
      "mutated_line": "ans[u][v] = 999999999",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 999999999\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans[u][v] = 1000000000",
      "mutated_line": "ans[u][v] = 0",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 0\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans[u][v] = 1000000000",
      "mutated_line": "ans[u][v] = 1",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans[u][v] = 1000000000",
      "mutated_line": "ans[u][v] = -1000000000",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = -1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(2, N + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(2, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(0, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(0, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(-1, N + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(-1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N - 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N - 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N * 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 1, -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 1, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, -1, -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, -1, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 1, -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 1, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, +1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, +1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(2, N + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(2, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(0, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(0, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(-1, N + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(-1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N - 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N - 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N * 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 1, -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 1, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, -1, -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, -1, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 1, -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 1, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, +1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, +1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(2, N + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(2, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(0, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(0, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(-1, N + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(-1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N - 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N - 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N * 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] * (M - 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M - 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] * (M * 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M * 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] * (M - 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M - 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] * (M * 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M * 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 2):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 2):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 0):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 0):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(2, M + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(2, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(0, M + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(0, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(0, M + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(0, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(-1, M + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(-1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M - 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M - 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M * 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M * 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 and mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 and mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, -2):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -2):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, -0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -0):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, -0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -0):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, --1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, --1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, 1, -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 1, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, -1, -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, -1, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, 1, -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 1, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, 0, +1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, +1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 and mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 and mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 2):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 2):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 0):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 0):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, 1, -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 1, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, -1, -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, -1, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, 1, -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 1, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, 0, +1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, +1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 and mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 and mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, -2):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -2):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, -0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -0):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, -0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -0):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, --1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, --1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(2, M + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(2, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(0, M + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(0, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(0, M + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(0, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(-1, M + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(-1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M - 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M - 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M * 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M * 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 and mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 and mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 2):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 2):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 0):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 0):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + -1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(2, M + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(2, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(0, M + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(0, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(0, M + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(0, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(-1, M + 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(-1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M - 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M - 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M * 1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M * 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] != 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] != 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[1] * (M + 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[1] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[-1] * (M + 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[-1] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[1] * (M + 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[1] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] * (M + 3) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 3) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] * (M + 1) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 1) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] * (M + 0) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 0) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] * (M + 1) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 1) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] * (M + -2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + -2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] * (M + 2) for _ in range(N - 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N - 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] * (M + 2) for _ in range(N * 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N * 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000001] * (M + 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000001] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[999999999] * (M + 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[999999999] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[0] * (M + 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[0] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1] * (M + 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[-1000000000] * (M + 2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[-1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] * (M + 3) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 3) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] * (M + 1) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 1) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] * (M + 0) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 0) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] * (M + 1) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 1) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] * (M + -2) for _ in range(N + 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + -2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] * (M + 2) for _ in range(N - 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N - 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] * (M + 2) for _ in range(N * 2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N * 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + 2):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 2):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + 0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 0):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + 0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 0):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] != 1 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] != 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] != 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] != 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, 0, -2):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -2):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, 0, -0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -0):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, 0, -0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -0):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, 0, --1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, --1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] != 1 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] != 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] != 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] != 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, 0, -2):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -2):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, 0, -0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -0):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, 0, -0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -0):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for j in range(M, 0, -1):",
      "mutated_line": "for j in range(M, 0, --1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, --1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] != 1 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] != 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] != 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] != 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + 2):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 2):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + 0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 0):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + 0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 0):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] != 1 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] != 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] != 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] != 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + 2):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 2):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + 0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 0):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + 0):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 0):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for j in range(1, M + 1):",
      "mutated_line": "for j in range(1, M + -1):",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + -1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1000000001:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000001:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 999999999:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 999999999:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 0:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 0:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == -1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == -1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "elif ans[i][j] >= 1000000000:",
      "mutated_line": "elif ans[i][j] > 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] > 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "elif ans[i][j] >= 1000000000:",
      "mutated_line": "elif ans[i][j] < 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] < 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "elif ans[i][j] >= 1000000000:",
      "mutated_line": "elif ans[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] == 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] * (M + 2) for _ in range(N + 3)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 3)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] * (M + 2) for _ in range(N + 1)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 1)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] * (M + 2) for _ in range(N + 0)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 0)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] * (M + 2) for _ in range(N + 1)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 1)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mat = [[0] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "mat = [[0] * (M + 2) for _ in range(N + -2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + -2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 3)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 3)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 1)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 1)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 0)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 0)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 1)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 1)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ans = [[1000000000] * (M + 2) for _ in range(N + 2)]",
      "mutated_line": "ans = [[1000000000] * (M + 2) for _ in range(N + -2)]",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + -2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 2 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 2 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 0 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 0 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 0 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 0 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == -1 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == -1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 1000000001:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000001:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 999999999:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 999999999:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 0:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 0:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 1:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == -1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == -1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] - 1, ans[i - 1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] - 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] * 1, ans[i - 1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] * 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] - 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] - 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] * 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] * 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 2 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 2 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 0 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 0 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 0 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 0 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == -1 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == -1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 1000000001:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000001:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 999999999:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 999999999:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 0:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 0:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 1:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == -1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == -1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] - 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] - 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] * 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] * 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] - 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] - 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] * 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] * 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 2 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 2 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 0 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 0 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 0 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 0 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == -1 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == -1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 1000000001:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000001:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 999999999:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 999999999:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 0:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 0:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 1:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == -1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == -1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] - 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] - 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] * 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] * 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] - 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] - 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] * 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] * 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 2 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 2 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 0 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 0 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 0 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 0 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == -1 or mat[i][j] == 1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == -1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 1000000001:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000001:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 999999999:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 999999999:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 0:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 0:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == 1:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mat[i][j] == 1 or mat[i][j] == 1000000000:",
      "mutated_line": "if mat[i][j] == 1 or mat[i][j] == -1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == -1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] - 1, ans[i][j - 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] - 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] * 1, ans[i][j - 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] * 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] - 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] - 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] * 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] * 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "row.append('X')",
      "mutated_line": "row.append('')",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif ans[i][j] >= 1000000000:",
      "mutated_line": "elif ans[i][j] >= 1000000001:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000001:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif ans[i][j] >= 1000000000:",
      "mutated_line": "elif ans[i][j] >= 999999999:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 999999999:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif ans[i][j] >= 1000000000:",
      "mutated_line": "elif ans[i][j] >= 0:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 0:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif ans[i][j] >= 1000000000:",
      "mutated_line": "elif ans[i][j] >= 1:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "elif ans[i][j] >= 1000000000:",
      "mutated_line": "elif ans[i][j] >= -1000000000:",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= -1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 2, ans[i - 1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 2, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 0, ans[i - 1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 0, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 0, ans[i - 1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 0, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + -1, ans[i - 1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + -1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 2)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 2)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 0)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 0)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 0)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 0)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + -1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + -1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 2, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 2, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 0, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 0, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 0, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 0, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + -1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + -1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 2)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 2)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 0)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 0)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 0)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 0)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + -1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + -1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 2, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 2, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 0, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 0, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 0, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 0, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + -1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + -1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 2)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 2)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 0)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 0)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 0)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 0)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + -1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + -1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 2, ans[i][j - 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 2, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 0, ans[i][j - 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 0, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 0, ans[i][j - 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 0, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + -1, ans[i][j - 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + -1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 2)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 2)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 0)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 0)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 0)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 0)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + -1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + -1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "row.append('-1')",
      "mutated_line": "row.append('')",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j + 1] + 1, ans[i - 1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j + 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j * 1] + 1, ans[i - 1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j * 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j * 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j * 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j - 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j - 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j * 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j * 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j * 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j * 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 2] + 1, ans[i - 1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 2] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 0] + 1, ans[i - 1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 0] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 0] + 1, ans[i - 1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 0] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - -1] + 1, ans[i - 1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - -1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i + 1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i + 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i * 1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i * 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i * 1][j] + 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i * 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 2] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 2] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 0] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 0] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 0] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 0] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + -1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + -1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i * 1][j] + 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i * 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 2] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 2] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 0] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 0] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 0] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 0] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + -1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + -1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j - 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i * 1][j] + 1, ans[i][j - 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i * 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 2] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 2] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 0] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 0] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 0] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 0] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - -1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - -1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 2][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 2][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 0][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 0][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 0][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 0][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - -1][j] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - -1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 2][j] + 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 2][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 0][j] + 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 0][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 0][j] + 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 0][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + -1][j] + 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + -1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 2][j] + 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 2][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 0][j] + 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 0][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - 0][j] + 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 0][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i - -1][j] + 1, ans[i][j + 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - -1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 2][j] + 1, ans[i][j - 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 2][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 0][j] + 1, ans[i][j - 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 0][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + 0][j] + 1, ans[i][j - 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 0][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j - 1] + 1)",
      "mutated_line": "ans[i][j] = min(ans[i][j], ans[i + -1][j] + 1, ans[i][j - 1] + 1)",
      "code": "def calculate_treasure_distances(N, M, treasures, blocked):\n    mat = [[0] * (M + 2) for _ in range(N + 2)]\n    ans = [[1000000000] * (M + 2) for _ in range(N + 2)]\n    for (x, y) in treasures:\n        mat[x][y] = 1\n        ans[x][y] = 0\n    for (u, v) in blocked:\n        mat[u][v] = 1000000000\n        ans[u][v] = 1000000000\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i][j - 1] + 1, ans[i - 1][j] + 1)\n    for i in range(N, 0, -1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i - 1][j] + 1, ans[i][j + 1] + 1)\n    for i in range(N, 0, -1):\n        for j in range(1, M + 1):\n            if mat[i][j] == 1 or mat[i][j] == 1000000000:\n                continue\n            else:\n                ans[i][j] = min(ans[i][j], ans[i + -1][j] + 1, ans[i][j - 1] + 1)\n    result = []\n    for i in range(1, N + 1):\n        row = []\n        for j in range(1, M + 1):\n            if mat[i][j] == 1000000000:\n                row.append('X')\n            elif ans[i][j] >= 1000000000:\n                row.append('-1')\n            else:\n                row.append(str(ans[i][j]))\n        result.append(row)\n    return result"
    }
  ]
}