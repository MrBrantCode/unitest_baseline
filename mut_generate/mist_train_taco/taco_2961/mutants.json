{
  "task_id": "taco_2961",
  "entry_point": "count_valid_tuples",
  "mutant_count": 93,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (1 << 31) + 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) + 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (1 << 31) * 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) * 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "OFFSET = 10 ** 6",
      "mutated_line": "OFFSET = 10 * 6",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 * 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "OFFSET = 10 ** 6",
      "mutated_line": "OFFSET = 10 + 6",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 + 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "u -= 1",
      "mutated_line": "u += 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u += 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "v -= 1",
      "mutated_line": "v += 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v += 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "zob_all = 0",
      "mutated_line": "zob_all = 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 1\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "zob_all = 0",
      "mutated_line": "zob_all = -1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = -1\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "zob_all = 0",
      "mutated_line": "zob_all = 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 1\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (1 << 31) - 2",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 2\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (1 << 31) - 0",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 0\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (1 << 31) - 0",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 0\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (1 << 31) - -1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - -1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OFFSET = 10 ** 6",
      "mutated_line": "OFFSET = 11 ** 6",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 11 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OFFSET = 10 ** 6",
      "mutated_line": "OFFSET = 9 ** 6",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 9 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OFFSET = 10 ** 6",
      "mutated_line": "OFFSET = 0 ** 6",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 0 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OFFSET = 10 ** 6",
      "mutated_line": "OFFSET = 1 ** 6",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 1 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OFFSET = 10 ** 6",
      "mutated_line": "OFFSET = -10 ** 6",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = -10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OFFSET = 10 ** 6",
      "mutated_line": "OFFSET = 10 ** 7",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 7\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OFFSET = 10 ** 6",
      "mutated_line": "OFFSET = 10 ** 5",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 5\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OFFSET = 10 ** 6",
      "mutated_line": "OFFSET = 10 ** 0",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 0\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OFFSET = 10 ** 6",
      "mutated_line": "OFFSET = 10 ** 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 1\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "OFFSET = 10 ** 6",
      "mutated_line": "OFFSET = 10 ** -6",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** -6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "u -= 1",
      "mutated_line": "u -= 2",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 2\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 0\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 0\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "u -= 1",
      "mutated_line": "u -= -1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= -1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v -= 1",
      "mutated_line": "v -= 2",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 2\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 0\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 0\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "v -= 1",
      "mutated_line": "v -= -1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= -1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "zob = [[0] * k for _ in range(k)]",
      "mutated_line": "zob = [[0] / k for _ in range(k)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] / k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "zob = [[0] * k for _ in range(k)]",
      "mutated_line": "zob = [[0] + k for _ in range(k)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] + k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "zob = [[0] * k for _ in range(k)]",
      "mutated_line": "zob = [[0] ** k for _ in range(k)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] ** k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 1\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = -1\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 1\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if digit == k:",
      "mutated_line": "if digit != k:",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit != k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "ans += solve(digit + 1, res ^ zob[digit][i])",
      "mutated_line": "ans -= solve(digit + 1, res ^ zob[digit][i])",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans -= solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return solve(0, 0)",
      "mutated_line": "return solve(1, 0)",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return solve(0, 0)",
      "mutated_line": "return solve(-1, 0)",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(-1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return solve(0, 0)",
      "mutated_line": "return solve(1, 0)",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return solve(0, 0)",
      "mutated_line": "return solve(0, 1)",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return solve(0, 0)",
      "mutated_line": "return solve(0, -1)",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return solve(0, 0)",
      "mutated_line": "return solve(0, 1)",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (2 << 31) - 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (2 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (0 << 31) - 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (0 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (0 << 31) - 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (0 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (-1 << 31) - 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (-1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (1 << 32) - 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 32) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (1 << 30) - 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 30) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (1 << 0) - 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 0) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (1 << 1) - 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 1) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "LIMIT = (1 << 31) - 1",
      "mutated_line": "LIMIT = (1 << -31) - 1",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << -31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hashes = [randrange(0, LIMIT + 1) for _ in range(n)]",
      "mutated_line": "hashes = [randrange(1, LIMIT + 1) for _ in range(n)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(1, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hashes = [randrange(0, LIMIT + 1) for _ in range(n)]",
      "mutated_line": "hashes = [randrange(-1, LIMIT + 1) for _ in range(n)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(-1, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hashes = [randrange(0, LIMIT + 1) for _ in range(n)]",
      "mutated_line": "hashes = [randrange(1, LIMIT + 1) for _ in range(n)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(1, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "hashes = [randrange(0, LIMIT + 1) for _ in range(n)]",
      "mutated_line": "hashes = [randrange(0, LIMIT - 1) for _ in range(n)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT - 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "hashes = [randrange(0, LIMIT + 1) for _ in range(n)]",
      "mutated_line": "hashes = [randrange(0, LIMIT * 1) for _ in range(n)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT * 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "graph[u].append(cost * OFFSET + v)",
      "mutated_line": "graph[u].append(cost * OFFSET - v)",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET - v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "graph[u].append(cost * OFFSET + v)",
      "mutated_line": "graph[u].append(cost * OFFSET * v)",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET * v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "nxt_v = tmp % OFFSET",
      "mutated_line": "nxt_v = tmp * OFFSET",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp * OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "nxt_v = tmp % OFFSET",
      "mutated_line": "nxt_v = tmp + OFFSET",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp + OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for i in range(digit + 1):",
      "mutated_line": "for i in range(digit - 1):",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit - 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for i in range(digit + 1):",
      "mutated_line": "for i in range(digit * 1):",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit * 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hashes = [randrange(0, LIMIT + 1) for _ in range(n)]",
      "mutated_line": "hashes = [randrange(0, LIMIT + 2) for _ in range(n)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 2) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hashes = [randrange(0, LIMIT + 1) for _ in range(n)]",
      "mutated_line": "hashes = [randrange(0, LIMIT + 0) for _ in range(n)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 0) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hashes = [randrange(0, LIMIT + 1) for _ in range(n)]",
      "mutated_line": "hashes = [randrange(0, LIMIT + 0) for _ in range(n)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 0) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hashes = [randrange(0, LIMIT + 1) for _ in range(n)]",
      "mutated_line": "hashes = [randrange(0, LIMIT + -1) for _ in range(n)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + -1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "graph[u].append(cost * OFFSET + v)",
      "mutated_line": "graph[u].append(cost / OFFSET + v)",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost / OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "graph[u].append(cost * OFFSET + v)",
      "mutated_line": "graph[u].append(cost + OFFSET + v)",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost + OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "graph[u].append(cost * OFFSET + v)",
      "mutated_line": "graph[u].append(cost ** OFFSET + v)",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost ** OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "zob = [[0] * k for _ in range(k)]",
      "mutated_line": "zob = [[1] * k for _ in range(k)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[1] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "zob = [[0] * k for _ in range(k)]",
      "mutated_line": "zob = [[-1] * k for _ in range(k)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[-1] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "zob = [[0] * k for _ in range(k)]",
      "mutated_line": "zob = [[1] * k for _ in range(k)]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[1] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "return int(res == zob_all)",
      "mutated_line": "return int(res != zob_all)",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res != zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(digit + 1):",
      "mutated_line": "for i in range(digit + 2):",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 2):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(digit + 1):",
      "mutated_line": "for i in range(digit + 0):",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 0):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(digit + 1):",
      "mutated_line": "for i in range(digit + 0):",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 0):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(digit + 1):",
      "mutated_line": "for i in range(digit + -1):",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + -1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans += solve(digit + 1, res ^ zob[digit][i])",
      "mutated_line": "ans += solve(digit - 1, res ^ zob[digit][i])",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit - 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans += solve(digit + 1, res ^ zob[digit][i])",
      "mutated_line": "ans += solve(digit * 1, res ^ zob[digit][i])",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit * 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans += solve(digit + 1, res ^ zob[digit][i])",
      "mutated_line": "ans += solve(digit + 1, res | zob[digit][i])",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res | zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "zob[deg - 1][i] ^= hashes[nxt_v]",
      "mutated_line": "zob[deg + 1][i] ^= hashes[nxt_v]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg + 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "zob[deg - 1][i] ^= hashes[nxt_v]",
      "mutated_line": "zob[deg * 1][i] ^= hashes[nxt_v]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg * 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans += solve(digit + 1, res ^ zob[digit][i])",
      "mutated_line": "ans += solve(digit + 2, res ^ zob[digit][i])",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 2, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans += solve(digit + 1, res ^ zob[digit][i])",
      "mutated_line": "ans += solve(digit + 0, res ^ zob[digit][i])",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 0, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans += solve(digit + 1, res ^ zob[digit][i])",
      "mutated_line": "ans += solve(digit + 0, res ^ zob[digit][i])",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 0, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans += solve(digit + 1, res ^ zob[digit][i])",
      "mutated_line": "ans += solve(digit + -1, res ^ zob[digit][i])",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + -1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "zob[deg - 1][i] ^= hashes[nxt_v]",
      "mutated_line": "zob[deg - 2][i] ^= hashes[nxt_v]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 2][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "zob[deg - 1][i] ^= hashes[nxt_v]",
      "mutated_line": "zob[deg - 0][i] ^= hashes[nxt_v]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 0][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "zob[deg - 1][i] ^= hashes[nxt_v]",
      "mutated_line": "zob[deg - 0][i] ^= hashes[nxt_v]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - 0][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "zob[deg - 1][i] ^= hashes[nxt_v]",
      "mutated_line": "zob[deg - -1][i] ^= hashes[nxt_v]",
      "code": "from random import randrange\n\ndef count_valid_tuples(n, m, k, edges):\n    LIMIT = (1 << 31) - 1\n    OFFSET = 10 ** 6\n    graph = [[] for _ in range(n)]\n    hashes = [randrange(0, LIMIT + 1) for _ in range(n)]\n    for (u, v, cost) in edges:\n        u -= 1\n        v -= 1\n        graph[u].append(cost * OFFSET + v)\n    zob = [[0] * k for _ in range(k)]\n    zob_all = 0\n    for i in range(n):\n        zob_all ^= hashes[i]\n    for v in range(n):\n        deg = len(graph[v])\n        graph[v] = sorted(graph[v])\n        for (i, tmp) in enumerate(graph[v]):\n            nxt_v = tmp % OFFSET\n            zob[deg - -1][i] ^= hashes[nxt_v]\n\n    def solve(digit, res):\n        ans = 0\n        if digit == k:\n            return int(res == zob_all)\n        for i in range(digit + 1):\n            ans += solve(digit + 1, res ^ zob[digit][i])\n        return ans\n    return solve(0, 0)"
    }
  ]
}