{
  "task_id": "taco_686",
  "entry_point": "has_subset_sum_divisible_by_m",
  "mutant_count": 75,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if rem == 0:",
      "mutated_line": "if rem != 0:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem != 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i >= len(nums):",
      "mutated_line": "if i > len(nums):",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i > len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i >= len(nums):",
      "mutated_line": "if i < len(nums):",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i < len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i >= len(nums):",
      "mutated_line": "if i == len(nums):",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i == len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if dp[i][rem] != -1:",
      "mutated_line": "if dp[i][rem] == -1:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] == -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if rem == -1:",
      "mutated_line": "if rem != -1:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem != -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "dp[i][rem] = take or ntake",
      "mutated_line": "dp[i][rem] = take and ntake",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take and ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "return take or ntake",
      "mutated_line": "return take and ntake",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take and ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp = [[-1] * (m + 1) for _ in range(len(nums))]",
      "mutated_line": "dp = [[-1] / (m + 1) for _ in range(len(nums))]",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] / (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp = [[-1] * (m + 1) for _ in range(len(nums))]",
      "mutated_line": "dp = [[-1] + (m + 1) for _ in range(len(nums))]",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] + (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp = [[-1] * (m + 1) for _ in range(len(nums))]",
      "mutated_line": "dp = [[-1] ** (m + 1) for _ in range(len(nums))]",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] ** (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if rem == 0:",
      "mutated_line": "if rem == 1:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 1:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if rem == 0:",
      "mutated_line": "if rem == -1:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == -1:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if rem == 0:",
      "mutated_line": "if rem == 1:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 1:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return False\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return True\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "if dp[i][rem] != -1:",
      "mutated_line": "if dp[i][rem] != +1:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != +1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "if rem == -1:",
      "mutated_line": "if rem == +1:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == +1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp = [[-1] * (m + 1) for _ in range(len(nums))]",
      "mutated_line": "dp = [[-1] * (m - 1) for _ in range(len(nums))]",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m - 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp = [[-1] * (m + 1) for _ in range(len(nums))]",
      "mutated_line": "dp = [[-1] * (m * 1) for _ in range(len(nums))]",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m * 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return int(f(0, -1, nums, dp))",
      "mutated_line": "return int(f(1, -1, nums, dp))",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(1, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return int(f(0, -1, nums, dp))",
      "mutated_line": "return int(f(-1, -1, nums, dp))",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(-1, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return int(f(0, -1, nums, dp))",
      "mutated_line": "return int(f(1, -1, nums, dp))",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(1, -1, nums, dp))"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "return int(f(0, -1, nums, dp))",
      "mutated_line": "return int(f(0, +1, nums, dp))",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, +1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if dp[i][rem] != -1:",
      "mutated_line": "if dp[i][rem] != -2:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -2:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if dp[i][rem] != -1:",
      "mutated_line": "if dp[i][rem] != -0:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -0:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if dp[i][rem] != -1:",
      "mutated_line": "if dp[i][rem] != -0:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -0:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if dp[i][rem] != -1:",
      "mutated_line": "if dp[i][rem] != --1:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != --1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if rem == -1:",
      "mutated_line": "if rem == -2:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -2:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if rem == -1:",
      "mutated_line": "if rem == -0:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -0:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if rem == -1:",
      "mutated_line": "if rem == -0:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -0:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if rem == -1:",
      "mutated_line": "if rem == --1:",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == --1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "take = f(i + 1, nums[i] % m, nums, dp)",
      "mutated_line": "take = f(i - 1, nums[i] % m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i - 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "take = f(i + 1, nums[i] % m, nums, dp)",
      "mutated_line": "take = f(i * 1, nums[i] % m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i * 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "take = f(i + 1, nums[i] % m, nums, dp)",
      "mutated_line": "take = f(i + 1, nums[i] * m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] * m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "take = f(i + 1, nums[i] % m, nums, dp)",
      "mutated_line": "take = f(i + 1, nums[i] + m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] + m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ntake = f(i + 1, rem, nums, dp)",
      "mutated_line": "ntake = f(i - 1, rem, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i - 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ntake = f(i + 1, rem, nums, dp)",
      "mutated_line": "ntake = f(i * 1, rem, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i * 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "take = f(i + 1, (rem + nums[i]) % m, nums, dp)",
      "mutated_line": "take = f(i - 1, (rem + nums[i]) % m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i - 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "take = f(i + 1, (rem + nums[i]) % m, nums, dp)",
      "mutated_line": "take = f(i * 1, (rem + nums[i]) % m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i * 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "take = f(i + 1, (rem + nums[i]) % m, nums, dp)",
      "mutated_line": "take = f(i + 1, (rem + nums[i]) * m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) * m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "take = f(i + 1, (rem + nums[i]) % m, nums, dp)",
      "mutated_line": "take = f(i + 1, rem + nums[i] + m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, rem + nums[i] + m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ntake = f(i + 1, rem, nums, dp)",
      "mutated_line": "ntake = f(i - 1, rem, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i - 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ntake = f(i + 1, rem, nums, dp)",
      "mutated_line": "ntake = f(i * 1, rem, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i * 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "dp = [[-1] * (m + 1) for _ in range(len(nums))]",
      "mutated_line": "dp = [[+1] * (m + 1) for _ in range(len(nums))]",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[+1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1] * (m + 1) for _ in range(len(nums))]",
      "mutated_line": "dp = [[-1] * (m + 2) for _ in range(len(nums))]",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 2) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1] * (m + 1) for _ in range(len(nums))]",
      "mutated_line": "dp = [[-1] * (m + 0) for _ in range(len(nums))]",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 0) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1] * (m + 1) for _ in range(len(nums))]",
      "mutated_line": "dp = [[-1] * (m + 0) for _ in range(len(nums))]",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 0) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1] * (m + 1) for _ in range(len(nums))]",
      "mutated_line": "dp = [[-1] * (m + -1) for _ in range(len(nums))]",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + -1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return int(f(0, -1, nums, dp))",
      "mutated_line": "return int(f(0, -2, nums, dp))",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -2, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return int(f(0, -1, nums, dp))",
      "mutated_line": "return int(f(0, -0, nums, dp))",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -0, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return int(f(0, -1, nums, dp))",
      "mutated_line": "return int(f(0, -0, nums, dp))",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -0, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return int(f(0, -1, nums, dp))",
      "mutated_line": "return int(f(0, --1, nums, dp))",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, --1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "take = f(i + 1, nums[i] % m, nums, dp)",
      "mutated_line": "take = f(i + 2, nums[i] % m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 2, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "take = f(i + 1, nums[i] % m, nums, dp)",
      "mutated_line": "take = f(i + 0, nums[i] % m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 0, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "take = f(i + 1, nums[i] % m, nums, dp)",
      "mutated_line": "take = f(i + 0, nums[i] % m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 0, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "take = f(i + 1, nums[i] % m, nums, dp)",
      "mutated_line": "take = f(i + -1, nums[i] % m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + -1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ntake = f(i + 1, rem, nums, dp)",
      "mutated_line": "ntake = f(i + 2, rem, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 2, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ntake = f(i + 1, rem, nums, dp)",
      "mutated_line": "ntake = f(i + 0, rem, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 0, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ntake = f(i + 1, rem, nums, dp)",
      "mutated_line": "ntake = f(i + 0, rem, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 0, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ntake = f(i + 1, rem, nums, dp)",
      "mutated_line": "ntake = f(i + -1, rem, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + -1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "take = f(i + 1, (rem + nums[i]) % m, nums, dp)",
      "mutated_line": "take = f(i + 2, (rem + nums[i]) % m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 2, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "take = f(i + 1, (rem + nums[i]) % m, nums, dp)",
      "mutated_line": "take = f(i + 0, (rem + nums[i]) % m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 0, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "take = f(i + 1, (rem + nums[i]) % m, nums, dp)",
      "mutated_line": "take = f(i + 0, (rem + nums[i]) % m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 0, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "take = f(i + 1, (rem + nums[i]) % m, nums, dp)",
      "mutated_line": "take = f(i + -1, (rem + nums[i]) % m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + -1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "take = f(i + 1, (rem + nums[i]) % m, nums, dp)",
      "mutated_line": "take = f(i + 1, (rem - nums[i]) % m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem - nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "take = f(i + 1, (rem + nums[i]) % m, nums, dp)",
      "mutated_line": "take = f(i + 1, rem * nums[i] % m, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, rem * nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ntake = f(i + 1, rem, nums, dp)",
      "mutated_line": "ntake = f(i + 2, rem, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 2, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ntake = f(i + 1, rem, nums, dp)",
      "mutated_line": "ntake = f(i + 0, rem, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 0, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ntake = f(i + 1, rem, nums, dp)",
      "mutated_line": "ntake = f(i + 0, rem, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 0, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ntake = f(i + 1, rem, nums, dp)",
      "mutated_line": "ntake = f(i + -1, rem, nums, dp)",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + -1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1] * (m + 1) for _ in range(len(nums))]",
      "mutated_line": "dp = [[-2] * (m + 1) for _ in range(len(nums))]",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-2] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1] * (m + 1) for _ in range(len(nums))]",
      "mutated_line": "dp = [[-0] * (m + 1) for _ in range(len(nums))]",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-0] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1] * (m + 1) for _ in range(len(nums))]",
      "mutated_line": "dp = [[-0] * (m + 1) for _ in range(len(nums))]",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[-0] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[-1] * (m + 1) for _ in range(len(nums))]",
      "mutated_line": "dp = [[--1] * (m + 1) for _ in range(len(nums))]",
      "code": "def has_subset_sum_divisible_by_m(nums, m):\n\n    def f(i, rem, nums, dp):\n        if rem == 0:\n            return True\n        if i >= len(nums):\n            return False\n        if dp[i][rem] != -1:\n            return dp[i][rem]\n        if rem == -1:\n            take = f(i + 1, nums[i] % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        else:\n            take = f(i + 1, (rem + nums[i]) % m, nums, dp)\n            ntake = f(i + 1, rem, nums, dp)\n        dp[i][rem] = take or ntake\n        return take or ntake\n    dp = [[--1] * (m + 1) for _ in range(len(nums))]\n    return int(f(0, -1, nums, dp))"
    }
  ]
}