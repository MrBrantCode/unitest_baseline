{
  "task_id": "taco_9410",
  "entry_point": "find_nth_element_in_sequence",
  "mutant_count": 116,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "n -= 1  # Adjust for 0-based indexing",
      "mutated_line": "n += 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n += 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "a += l",
      "mutated_line": "a -= l",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a -= l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if n < 1:",
      "mutated_line": "if n <= 1:",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n <= 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if n < 1:",
      "mutated_line": "if n >= 1:",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n >= 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if n < 1:",
      "mutated_line": "if n != 1:",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n != 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n -= 1  # Adjust for 0-based indexing",
      "mutated_line": "n -= 2",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 2\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n -= 1  # Adjust for 0-based indexing",
      "mutated_line": "n -= 0",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 0\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n -= 1  # Adjust for 0-based indexing",
      "mutated_line": "n -= 0",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 0\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n -= 1  # Adjust for 0-based indexing",
      "mutated_line": "n -= -1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= -1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 1\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = -1\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 1\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "s += 4 ** d",
      "mutated_line": "s -= 4 ** d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s -= 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l = i - s",
      "mutated_line": "l = i + s",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i + s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l = i - s",
      "mutated_line": "l = i * s",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i * s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "c = a ^ b",
      "mutated_line": "c = a | b",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a | b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n < 1:",
      "mutated_line": "if n < 2:",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 2:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n < 1:",
      "mutated_line": "if n < 0:",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 0:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n < 1:",
      "mutated_line": "if n < 0:",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 0:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n < 1:",
      "mutated_line": "if n < -1:",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < -1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(i, m) = divmod(n, 3)",
      "mutated_line": "(i, m) = divmod(n, 4)",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 4)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(i, m) = divmod(n, 3)",
      "mutated_line": "(i, m) = divmod(n, 2)",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 2)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(i, m) = divmod(n, 3)",
      "mutated_line": "(i, m) = divmod(n, 0)",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 0)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(i, m) = divmod(n, 3)",
      "mutated_line": "(i, m) = divmod(n, 1)",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 1)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "(i, m) = divmod(n, 3)",
      "mutated_line": "(i, m) = divmod(n, -3)",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, -3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for d in range(100):",
      "mutated_line": "for d in range(101):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(101):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for d in range(100):",
      "mutated_line": "for d in range(99):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(99):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for d in range(100):",
      "mutated_line": "for d in range(0):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(0):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for d in range(100):",
      "mutated_line": "for d in range(1):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(1):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for d in range(100):",
      "mutated_line": "for d in range(-100):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(-100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "s += 4 ** d",
      "mutated_line": "s += 4 * d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 * d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "s += 4 ** d",
      "mutated_line": "s += 4 + d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 + d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if s > i:",
      "mutated_line": "if s >= i:",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s >= i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if s > i:",
      "mutated_line": "if s <= i:",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s <= i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if s > i:",
      "mutated_line": "if s != i:",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s != i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "s -= 4 ** d",
      "mutated_line": "s += 4 ** d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s += 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = 1 << d * 2",
      "mutated_line": "a = 2 << d * 2",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 2 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = 1 << d * 2",
      "mutated_line": "a = 0 << d * 2",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 0 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = 1 << d * 2",
      "mutated_line": "a = 0 << d * 2",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 0 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = 1 << d * 2",
      "mutated_line": "a = -1 << d * 2",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = -1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "a = 1 << d * 2",
      "mutated_line": "a = 1 << d / 2",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d / 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "a = 1 << d * 2",
      "mutated_line": "a = 1 << d + 2",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d + 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "a = 1 << d * 2",
      "mutated_line": "a = 1 << d ** 2",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d ** 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 2 << d * 2 + 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 2 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 0 << d * 2 + 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 0 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 0 << d * 2 + 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 0 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = -1 << d * 2 + 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = -1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 1 << d * 2 - 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 - 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 1 << d * 2 * 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 * 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for bit in range(0, 80, 2):",
      "mutated_line": "for bit in range(1, 80, 2):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(1, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for bit in range(0, 80, 2):",
      "mutated_line": "for bit in range(-1, 80, 2):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(-1, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for bit in range(0, 80, 2):",
      "mutated_line": "for bit in range(1, 80, 2):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(1, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for bit in range(0, 80, 2):",
      "mutated_line": "for bit in range(0, 81, 2):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 81, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for bit in range(0, 80, 2):",
      "mutated_line": "for bit in range(0, 79, 2):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 79, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for bit in range(0, 80, 2):",
      "mutated_line": "for bit in range(0, 0, 2):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 0, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for bit in range(0, 80, 2):",
      "mutated_line": "for bit in range(0, 1, 2):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 1, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for bit in range(0, 80, 2):",
      "mutated_line": "for bit in range(0, -80, 2):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, -80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for bit in range(0, 80, 2):",
      "mutated_line": "for bit in range(0, 80, 3):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 3):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for bit in range(0, 80, 2):",
      "mutated_line": "for bit in range(0, 80, 1):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 1):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for bit in range(0, 80, 2):",
      "mutated_line": "for bit in range(0, 80, 0):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 0):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for bit in range(0, 80, 2):",
      "mutated_line": "for bit in range(0, 80, 1):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 1):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for bit in range(0, 80, 2):",
      "mutated_line": "for bit in range(0, 80, -2):",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, -2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "raise ValueError(\"n must be a positive integer\")",
      "mutated_line": "raise ValueError('')",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "s += 4 ** d",
      "mutated_line": "s += 5 ** d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 5 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "s += 4 ** d",
      "mutated_line": "s += 3 ** d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 3 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "s += 4 ** d",
      "mutated_line": "s += 0 ** d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 0 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "s += 4 ** d",
      "mutated_line": "s += 1 ** d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 1 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "s += 4 ** d",
      "mutated_line": "s += -4 ** d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += -4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s -= 4 ** d",
      "mutated_line": "s -= 4 * d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 * d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s -= 4 ** d",
      "mutated_line": "s -= 4 + d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 + d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = 1 << d * 2",
      "mutated_line": "a = 1 << d * 3",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 3\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = 1 << d * 2",
      "mutated_line": "a = 1 << d * 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 1\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = 1 << d * 2",
      "mutated_line": "a = 1 << d * 0",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 0\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = 1 << d * 2",
      "mutated_line": "a = 1 << d * 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 1\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "a = 1 << d * 2",
      "mutated_line": "a = 1 << d * -2",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * -2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 1 << d / 2 + 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d / 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 1 << d + 2 + 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d + 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 1 << d ** 2 + 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d ** 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 1 << d * 2 + 2",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 2\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 1 << d * 2 + 0",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 0\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 1 << d * 2 + 0",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 0\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 1 << d * 2 + -1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + -1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s -= 4 ** d",
      "mutated_line": "s -= 5 ** d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 5 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s -= 4 ** d",
      "mutated_line": "s -= 3 ** d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 3 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s -= 4 ** d",
      "mutated_line": "s -= 0 ** d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 0 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s -= 4 ** d",
      "mutated_line": "s -= 1 ** d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 1 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s -= 4 ** d",
      "mutated_line": "s -= -4 ** d",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= -4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 1 << d * 3 + 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 3 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 1 << d * 1 + 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 1 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 1 << d * 0 + 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 0 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 1 << d * 1 + 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 1 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "b = 1 << d * 2 + 1",
      "mutated_line": "b = 1 << d * -2 + 1",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * -2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, 3, 1][l >> bit | 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit | 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [1, 2, 3, 1][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [1, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [-1, 2, 3, 1][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [-1, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [1, 2, 3, 1][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [1, 2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 3, 3, 1][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 3, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 1, 3, 1][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 1, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 0, 3, 1][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 0, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 1, 3, 1][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 1, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, -2, 3, 1][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, -2, 3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, 4, 1][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 4, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, 2, 1][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 2, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, 0, 1][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 0, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, 1, 1][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 1, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, -3, 1][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, -3, 1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, 3, 2][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 2][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, 3, 0][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 0][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, 3, 0][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 0][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, 3, -1][l >> bit & 3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, -1][l >> bit & 3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, 3, 1][l >> bit & 4] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 4] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, 3, 1][l >> bit & 2] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 2] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, 3, 1][l >> bit & 0] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 0] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, 3, 1][l >> bit & 1] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & 1] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b |= [0, 2, 3, 1][l >> bit & 3] << bit",
      "mutated_line": "b |= [0, 2, 3, 1][l >> bit & -3] << bit",
      "code": "def find_nth_element_in_sequence(n: int) -> int:\n    \"\"\"\n    Finds the n-th element in the infinite sequence s of positive integers.\n\n    The sequence s is created by repeating the following steps:\n    1. Find the lexicographically smallest triple of positive integers (a, b, c) such that a ⊕ b ⊕ c = 0.\n    2. Append a, b, c to s in this order.\n    3. Go back to the first step.\n\n    Parameters:\n    n (int): The position of the element in the sequence s.\n\n    Returns:\n    int: The n-th element of the sequence s.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be a positive integer')\n    n -= 1\n    (i, m) = divmod(n, 3)\n    s = 0\n    for d in range(100):\n        s += 4 ** d\n        if s > i:\n            s -= 4 ** d\n            break\n    a = 1 << d * 2\n    l = i - s\n    a += l\n    b = 1 << d * 2 + 1\n    for bit in range(0, 80, 2):\n        b |= [0, 2, 3, 1][l >> bit & -3] << bit\n    c = a ^ b\n    return [a, b, c][m]"
    }
  ]
}