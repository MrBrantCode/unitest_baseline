{
  "task_id": "taco_3871",
  "entry_point": "predict_bear_position",
  "mutant_count": 242,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "sx -= 1",
      "mutated_line": "sx += 1",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx += 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "sy -= 1",
      "mutated_line": "sy += 1",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy += 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "sx -= 1",
      "mutated_line": "sx -= 2",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 2\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "sx -= 1",
      "mutated_line": "sx -= 0",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 0\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "sx -= 1",
      "mutated_line": "sx -= 0",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 0\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "sx -= 1",
      "mutated_line": "sx -= -1",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= -1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "sy -= 1",
      "mutated_line": "sy -= 2",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 2\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "sy -= 1",
      "mutated_line": "sy -= 0",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 0\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "sy -= 1",
      "mutated_line": "sy -= 0",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 0\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "sy -= 1",
      "mutated_line": "sy -= -1",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= -1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r = M ** t",
      "mutated_line": "r = M * t",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M * t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r = M ** t",
      "mutated_line": "r = M + t",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M + t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "M = Matrix(6)",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(7)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "M = Matrix(6)",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(5)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "M = Matrix(6)",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(0)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "M = Matrix(6)",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(1)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "M = Matrix(6)",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(-6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n - 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n * 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[3, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[3, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[1, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[1, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[0, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[0, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[1, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[1, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[-2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[-2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 2, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 2, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 0, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 0, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 0, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 0, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, -1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, -1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 2, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 2, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 0, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 0, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 0, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 0, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, -1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, -1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 1, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 1, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, -1, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, -1, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 1, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 1, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 2, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 2, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 0, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 0, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 0, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 0, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, -1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, -1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 3], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 3], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 1], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 1], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 0], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 0], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 1], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 1], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "[2, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, -2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, -2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [2, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [2, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [0, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [0, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [0, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [0, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [-1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [-1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 3, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 3, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 0, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 0, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, -2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, -2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 1, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 1, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, -1, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, -1, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 1, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 1, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 2, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 2, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 0, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 0, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 0, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 0, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, -1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, -1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 2, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 2, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 0, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 0, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 0, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 0, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, -1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, -1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 3], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 3], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 1], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 1], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 0], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 0], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 1], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 1], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "[1, 2, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, -2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, -2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [2, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [2, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [0, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [0, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [0, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [0, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [-1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [-1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 2, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 2, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 0, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 0, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 0, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 0, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, -1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, -1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 2, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 2, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 0, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 0, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 0, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 0, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, -1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, -1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 1, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 1, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, -1, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, -1, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 1, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 1, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 2, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 2, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 0, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 0, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 0, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 0, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, -1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, -1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 3], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 3], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 0], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 0], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "[1, 1, 1, 0, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, -2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, -2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [2, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [2, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [0, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [0, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [0, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [0, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [-1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [-1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 0, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 0, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 0, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 0, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, -1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, -1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 1, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 1, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, -1, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, -1, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 1, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 1, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 2, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 2, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 0, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 0, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 0, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 0, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, -1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, -1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 2, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 2, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 0, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 0, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 0, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 0, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, -1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, -1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 3], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 3], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 1], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 1], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 0], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 0], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 1], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 1], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "[1, 1, 0, 1, 1, 2],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, -2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, -2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [-1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [-1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, -1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, -1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, -1, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, -1, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, -1, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, -1, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 2, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 2, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, -1, 1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, -1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 2], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 2], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "[0, 0, 0, 0, 1, 1],",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, -1], [0, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, -1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [-1, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [-1, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 1, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 1, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, -1, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, -1, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 1, 0, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 1, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, -1, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, -1, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, -1, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, -1, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, -1, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, -1, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 2]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 2]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "[0, 0, 0, 0, 0, 1]",
      "mutated_line": "M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, -1]]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, -1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) * n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5] + n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 2\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 0\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 0\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + -1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return f(0), f(1)",
      "mutated_line": "return (f(1), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(1), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return f(0), f(1)",
      "mutated_line": "return (f(-1), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(-1), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return f(0), f(1)",
      "mutated_line": "return (f(1), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(1), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return f(0), f(1)",
      "mutated_line": "return (f(0), f(2))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(2))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return f(0), f(1)",
      "mutated_line": "return (f(0), f(0))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(0))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return f(0), f(1)",
      "mutated_line": "return (f(0), f(0))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(0))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return f(0), f(1)",
      "mutated_line": "return (f(0), f(-1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(-1))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.a = [[0] * n for _ in range(n)]",
      "mutated_line": "self.a = [[0] / n for _ in range(n)]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] / n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.a = [[0] * n for _ in range(n)]",
      "mutated_line": "self.a = [[0] + n for _ in range(n)]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] + n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.a = [[0] * n for _ in range(n)]",
      "mutated_line": "self.a = [[0] ** n for _ in range(n)]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] ** n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res.a[i][i] = 1",
      "mutated_line": "res.a[i][i] = 2",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 2\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res.a[i][i] = 1",
      "mutated_line": "res.a[i][i] = 0",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 0\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res.a[i][i] = 1",
      "mutated_line": "res.a[i][i] = 0",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 0\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "res.a[i][i] = 1",
      "mutated_line": "res.a[i][i] = -1",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = -1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if e & 1:",
      "mutated_line": "if e | 1:",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e | 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "e >>= 1",
      "mutated_line": "e >>= 2",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 2\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "e >>= 1",
      "mutated_line": "e >>= 0",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 0\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "e >>= 1",
      "mutated_line": "e >>= 0",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 0\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "e >>= 1",
      "mutated_line": "e >>= -1",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= -1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "tmp = tmp * tmp",
      "mutated_line": "tmp = tmp / tmp",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp / tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "tmp = tmp * tmp",
      "mutated_line": "tmp = tmp + tmp",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp + tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "tmp = tmp * tmp",
      "mutated_line": "tmp = tmp ** tmp",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp ** tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy - r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy) * r.a[i][5] % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "res.a[i][j] += self.a[i][k] * b.a[k][j] % n",
      "mutated_line": "res.a[i][j] -= self.a[i][k] * b.a[k][j] % n",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] -= self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if e & 1:",
      "mutated_line": "if e & 2:",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 2:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if e & 1:",
      "mutated_line": "if e & 0:",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 0:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if e & 1:",
      "mutated_line": "if e & 0:",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 0:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if e & 1:",
      "mutated_line": "if e & -1:",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & -1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "res = res * tmp",
      "mutated_line": "res = res / tmp",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res / tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "res = res * tmp",
      "mutated_line": "res = res + tmp",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res + tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "res = res * tmp",
      "mutated_line": "res = res ** tmp",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res ** tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx - r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: ((r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx) * (r.a[i][3] * dy) + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.a = [[0] * n for _ in range(n)]",
      "mutated_line": "self.a = [[1] * n for _ in range(n)]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[1] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.a = [[0] * n for _ in range(n)]",
      "mutated_line": "self.a = [[-1] * n for _ in range(n)]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[-1] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.a = [[0] * n for _ in range(n)]",
      "mutated_line": "self.a = [[1] * n for _ in range(n)]",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[1] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res.a[i][j] += self.a[i][k] * b.a[k][j] % n",
      "mutated_line": "res.a[i][j] += self.a[i][k] * b.a[k][j] * n",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] * n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res.a[i][j] += self.a[i][k] * b.a[k][j] % n",
      "mutated_line": "res.a[i][j] += self.a[i][k] * b.a[k][j] + n",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] + n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy - r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: ((r.a[i][0] * sx + r.a[i][1] * sy) * (r.a[i][2] * dx) + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] / dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + (r.a[i][3] + dy) + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] ** dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][6]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][4]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][0]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][1]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][-5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res.a[i][j] += self.a[i][k] * b.a[k][j] % n",
      "mutated_line": "res.a[i][j] += self.a[i][k] / b.a[k][j] % n",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] / b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res.a[i][j] += self.a[i][k] * b.a[k][j] % n",
      "mutated_line": "res.a[i][j] += (self.a[i][k] + b.a[k][j]) % n",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += (self.a[i][k] + b.a[k][j]) % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res.a[i][j] += self.a[i][k] * b.a[k][j] % n",
      "mutated_line": "res.a[i][j] += self.a[i][k] ** b.a[k][j] % n",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] ** b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx - r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx * (r.a[i][1] * sy) + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] / dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + (r.a[i][2] + dx) + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] ** dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] / sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] + sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] ** sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] / sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + (r.a[i][1] + sy) + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] ** sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][4] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][2] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][0] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][1] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][-3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][3] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][1] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][0] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][1] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][-2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][1] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][-1] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][1] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][2] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][0] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][0] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "f = lambda i: (r.a[i][0] * sx + r.a[i][1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1",
      "mutated_line": "return (f(0), f(1))",
      "code": "def predict_bear_position(n, sx, sy, dx, dy, t):\n\n    class Matrix:\n\n        def __init__(self, n):\n            self.n = n\n            self.a = [[0] * n for _ in range(n)]\n\n        def __mul__(self, b):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                for j in range(self.n):\n                    for k in range(self.n):\n                        res.a[i][j] += self.a[i][k] * b.a[k][j] % n\n                        res.a[i][j] %= n\n            return res\n\n        def __pow__(self, e):\n            res = Matrix(self.n)\n            for i in range(self.n):\n                res.a[i][i] = 1\n            tmp = self\n            while e:\n                if e & 1:\n                    res = res * tmp\n                e >>= 1\n                tmp = tmp * tmp\n            return res\n    M = Matrix(6)\n    M.a = [[2, 1, 1, 0, 1, 2], [1, 2, 0, 1, 1, 2], [1, 1, 1, 0, 1, 2], [1, 1, 0, 1, 1, 2], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1]]\n    sx -= 1\n    sy -= 1\n    r = M ** t\n    f = lambda i: (r.a[i][0] * sx + r.a[i][-1] * sy + r.a[i][2] * dx + r.a[i][3] * dy + r.a[i][5]) % n + 1\n    return (f(0), f(1))"
    }
  ]
}