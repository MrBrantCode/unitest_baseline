{
  "task_id": "taco_10327",
  "entry_point": "findPar",
  "mutant_count": 127,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if node == parent[node]:",
      "mutated_line": "if node != parent[node]:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node != parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if ult_u == ult_v:",
      "mutated_line": "if ult_u != ult_v:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u != ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if rank[ult_u] < rank[ult_v]:",
      "mutated_line": "if rank[ult_u] <= rank[ult_v]:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] <= rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if rank[ult_u] < rank[ult_v]:",
      "mutated_line": "if rank[ult_u] >= rank[ult_v]:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] >= rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if rank[ult_u] < rank[ult_v]:",
      "mutated_line": "if rank[ult_u] != rank[ult_v]:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] != rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return True\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "rank = [0] * (rows * cols)",
      "mutated_line": "rank = [0] / (rows * cols)",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] / (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "rank = [0] * (rows * cols)",
      "mutated_line": "rank = [0] + rows * cols",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] + rows * cols\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "rank = [0] * (rows * cols)",
      "mutated_line": "rank = [0] ** (rows * cols)",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] ** (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 1\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = -1\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 1\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt -= 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return False\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif rank[ult_v] < rank[ult_u]:",
      "mutated_line": "elif rank[ult_v] <= rank[ult_u]:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] <= rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif rank[ult_v] < rank[ult_u]:",
      "mutated_line": "elif rank[ult_v] >= rank[ult_u]:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] >= rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif rank[ult_v] < rank[ult_u]:",
      "mutated_line": "elif rank[ult_v] != rank[ult_u]:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] != rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "rank[ult_u] += 1",
      "mutated_line": "rank[ult_u] -= 1",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] -= 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "rank = [0] * (rows * cols)",
      "mutated_line": "rank = [0] * (rows / cols)",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows / cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "rank = [0] * (rows * cols)",
      "mutated_line": "rank = [0] * (rows + cols)",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows + cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "rank = [0] * (rows * cols)",
      "mutated_line": "rank = [0] * rows ** cols",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * rows ** cols\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if vis[r][c] == 1:",
      "mutated_line": "if vis[r][c] != 1:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] != 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "vis[r][c] = 1",
      "mutated_line": "vis[r][c] = 2",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 2\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "vis[r][c] = 1",
      "mutated_line": "vis[r][c] = 0",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 0\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "vis[r][c] = 1",
      "mutated_line": "vis[r][c] = 0",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 0\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "vis[r][c] = 1",
      "mutated_line": "vis[r][c] = -1",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = -1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 2\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 0\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 0\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += -1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "u = r * cols + c",
      "mutated_line": "u = r * cols - c",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols - c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "u = r * cols + c",
      "mutated_line": "u = r * cols * c",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols * c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "rank[ult_u] += 1",
      "mutated_line": "rank[ult_u] += 2",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 2\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "rank[ult_u] += 1",
      "mutated_line": "rank[ult_u] += 0",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 0\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "rank[ult_u] += 1",
      "mutated_line": "rank[ult_u] += 0",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 0\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "rank[ult_u] += 1",
      "mutated_line": "rank[ult_u] += -1",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += -1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "rank = [0] * (rows * cols)",
      "mutated_line": "rank = [1] * (rows * cols)",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [1] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "rank = [0] * (rows * cols)",
      "mutated_line": "rank = [-1] * (rows * cols)",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [-1] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "rank = [0] * (rows * cols)",
      "mutated_line": "rank = [1] * (rows * cols)",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [1] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vis = [[0 for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "vis = [[1 for _ in range(cols)] for _ in range(rows)]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[1 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vis = [[0 for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "vis = [[-1 for _ in range(cols)] for _ in range(rows)]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[-1 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vis = [[0 for _ in range(cols)] for _ in range(rows)]",
      "mutated_line": "vis = [[1 for _ in range(cols)] for _ in range(rows)]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[1 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[+1, 0], [1, 0], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[+1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 1], [1, 0], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 1], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, -1], [1, 0], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, -1], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 1], [1, 0], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 1], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [2, 0], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [2, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [0, 0], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [0, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [0, 0], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [0, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [-1, 0], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [-1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 1], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 1], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, -1], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, -1], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 1], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 1], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [1, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [1, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [-1, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [-1, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [1, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [1, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [0, 2], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 2], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [0, 0], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 0], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [0, 0], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 0], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [0, -1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, -1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [0, 1], [1, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [1, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [0, 1], [-1, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [-1, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [0, 1], [1, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [1, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, +1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, +1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if vis[r][c] == 1:",
      "mutated_line": "if vis[r][c] == 2:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 2:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if vis[r][c] == 1:",
      "mutated_line": "if vis[r][c] == 0:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 0:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if vis[r][c] == 1:",
      "mutated_line": "if vis[r][c] == 0:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 0:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if vis[r][c] == 1:",
      "mutated_line": "if vis[r][c] == -1:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == -1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "u = r * cols + c",
      "mutated_line": "u = r / cols + c",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r / cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "u = r * cols + c",
      "mutated_line": "u = r + cols + c",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r + cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "u = r * cols + c",
      "mutated_line": "u = r ** cols + c",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r ** cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 0 and y < 0 and (x >= rows) and (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 and y < 0 and (x >= rows) and (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if vis[x][y] == 1:",
      "mutated_line": "if vis[x][y] != 1:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] != 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "parent = [i for i in range(rows * cols)]",
      "mutated_line": "parent = [i for i in range(rows / cols)]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows / cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "parent = [i for i in range(rows * cols)]",
      "mutated_line": "parent = [i for i in range(rows + cols)]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows + cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "parent = [i for i in range(rows * cols)]",
      "mutated_line": "parent = [i for i in range(rows ** cols)]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows ** cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-2, 0], [1, 0], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-2, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-0, 0], [1, 0], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-0, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-0, 0], [1, 0], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-0, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[--1, 0], [1, 0], [0, 1], [0, -1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[--1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -2]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -2]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -0]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -0]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -0]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -0]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]",
      "mutated_line": "dirc = [[-1, 0], [1, 0], [0, 1], [0, --1]]",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, --1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "x, y = r + i[0], c + i[1]",
      "mutated_line": "(x, y) = (r - i[0], c + i[1])",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r - i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "x, y = r + i[0], c + i[1]",
      "mutated_line": "(x, y) = (r * i[0], c + i[1])",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r * i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "x, y = r + i[0], c + i[1]",
      "mutated_line": "(x, y) = (r + i[0], c - i[1])",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c - i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "x, y = r + i[0], c + i[1]",
      "mutated_line": "(x, y) = (r + i[0], c * i[1])",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c * i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x <= 0 or y < 0 or x >= rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x <= 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x >= 0 or y < 0 or x >= rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x >= 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x != 0 or y < 0 or x >= rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x != 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 0 or y <= 0 or x >= rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y <= 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 0 or y >= 0 or x >= rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y >= 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 0 or y != 0 or x >= rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y != 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 0 or y < 0 or x > rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x > rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 0 or y < 0 or x < rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x < rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 0 or y < 0 or x == rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x == rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 0 or y < 0 or x >= rows or (y > cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y > cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 0 or y < 0 or x >= rows or (y < cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y < cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 0 or y < 0 or x >= rows or (y == cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y == cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if vis[x][y] == 1:",
      "mutated_line": "if vis[x][y] == 2:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 2:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if vis[x][y] == 1:",
      "mutated_line": "if vis[x][y] == 0:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 0:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if vis[x][y] == 1:",
      "mutated_line": "if vis[x][y] == 0:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 0:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if vis[x][y] == 1:",
      "mutated_line": "if vis[x][y] == -1:",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == -1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "v = x * cols + y",
      "mutated_line": "v = x * cols - y",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols - y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "v = x * cols + y",
      "mutated_line": "v = x * cols * y",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols * y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt += 1",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt += 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 1 or y < 0 or x >= rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 1 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < -1 or y < 0 or x >= rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < -1 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 1 or y < 0 or x >= rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 1 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 0 or y < 1 or x >= rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 1 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 0 or y < -1 or x >= rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < -1 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if x < 0 or y < 0 or x >= rows or y >= cols:",
      "mutated_line": "if x < 0 or y < 1 or x >= rows or (y >= cols):",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 1 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "v = x * cols + y",
      "mutated_line": "v = x / cols + y",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x / cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "v = x * cols + y",
      "mutated_line": "v = x + cols + y",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x + cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "v = x * cols + y",
      "mutated_line": "v = x ** cols + y",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x ** cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 2",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 2\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 0",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 0\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 0",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 0\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= -1",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= -1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "x, y = r + i[0], c + i[1]",
      "mutated_line": "(x, y) = (r + i[1], c + i[1])",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[1], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "x, y = r + i[0], c + i[1]",
      "mutated_line": "(x, y) = (r + i[-1], c + i[1])",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[-1], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "x, y = r + i[0], c + i[1]",
      "mutated_line": "(x, y) = (r + i[1], c + i[1])",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[1], c + i[1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "x, y = r + i[0], c + i[1]",
      "mutated_line": "(x, y) = (r + i[0], c + i[2])",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[2])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "x, y = r + i[0], c + i[1]",
      "mutated_line": "(x, y) = (r + i[0], c + i[0])",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[0])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "x, y = r + i[0], c + i[1]",
      "mutated_line": "(x, y) = (r + i[0], c + i[0])",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[0])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "x, y = r + i[0], c + i[1]",
      "mutated_line": "(x, y) = (r + i[0], c + i[-1])",
      "code": "from typing import List\n\ndef findPar(node, parent):\n    if node == parent[node]:\n        return node\n    parent[node] = findPar(parent[node], parent)\n    return parent[node]\n\ndef union(u, v, rank, parent):\n    (ult_u, ult_v) = (findPar(u, parent), findPar(v, parent))\n    if ult_u == ult_v:\n        return True\n    if rank[ult_u] < rank[ult_v]:\n        parent[ult_u] = ult_v\n    elif rank[ult_v] < rank[ult_u]:\n        parent[ult_v] = ult_u\n    else:\n        parent[ult_v] = ult_u\n        rank[ult_u] += 1\n    return False\n\ndef num_of_islands(rows: int, cols: int, operators: List[List[int]]) -> List[int]:\n    rank = [0] * (rows * cols)\n    parent = [i for i in range(rows * cols)]\n    vis = [[0 for _ in range(cols)] for _ in range(rows)]\n    dirc = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n    res = []\n    cnt = 0\n    for pair in operators:\n        (r, c) = pair\n        if vis[r][c] == 1:\n            res.append(cnt)\n            continue\n        vis[r][c] = 1\n        cnt += 1\n        u = r * cols + c\n        for i in dirc:\n            (x, y) = (r + i[0], c + i[-1])\n            if x < 0 or y < 0 or x >= rows or (y >= cols):\n                continue\n            if vis[x][y] == 1:\n                v = x * cols + y\n                if not union(u, v, rank, parent):\n                    cnt -= 1\n        res.append(cnt)\n    return res"
    }
  ]
}