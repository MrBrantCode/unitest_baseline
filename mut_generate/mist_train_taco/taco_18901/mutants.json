{
  "task_id": "taco_18901",
  "entry_point": "count_valid_sequences",
  "mutant_count": 184,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_valid_sequences(N, X, MOD=998244353):",
      "mutated_line": "def count_valid_sequences(N, X, MOD=998244354):",
      "code": "def count_valid_sequences(N, X, MOD=998244354):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_valid_sequences(N, X, MOD=998244353):",
      "mutated_line": "def count_valid_sequences(N, X, MOD=998244352):",
      "code": "def count_valid_sequences(N, X, MOD=998244352):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_valid_sequences(N, X, MOD=998244353):",
      "mutated_line": "def count_valid_sequences(N, X, MOD=0):",
      "code": "def count_valid_sequences(N, X, MOD=0):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_valid_sequences(N, X, MOD=998244353):",
      "mutated_line": "def count_valid_sequences(N, X, MOD=1):",
      "code": "def count_valid_sequences(N, X, MOD=1):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_valid_sequences(N, X, MOD=998244353):",
      "mutated_line": "def count_valid_sequences(N, X, MOD=-998244353):",
      "code": "def count_valid_sequences(N, X, MOD=-998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 1\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = -1\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 1\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "f = 1",
      "mutated_line": "f = 2",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 2\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "f = 1",
      "mutated_line": "f = 0",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 0\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "f = 1",
      "mutated_line": "f = 0",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 0\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "f = 1",
      "mutated_line": "f = -1",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = -1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "f *= m",
      "mutated_line": "f /= m",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f /= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "invs = [1] * (n + 1)",
      "mutated_line": "invs = [1] / (n + 1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] / (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "invs = [1] * (n + 1)",
      "mutated_line": "invs = [1] + (n + 1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] + (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "invs = [1] * (n + 1)",
      "mutated_line": "invs = [1] ** (n + 1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] ** (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "inv *= m",
      "mutated_line": "inv /= m",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv /= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[n] * inv[n - r] * inv[r] % mod",
      "mutated_line": "return fac[n] * inv[n - r] * inv[r] * mod",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] * mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[n] * inv[n - r] * inv[r] % mod",
      "mutated_line": "return fac[n] * inv[n - r] * inv[r] + mod",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] + mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "(fac, inv) = modfac(N + 10, MOD)",
      "mutated_line": "(fac, inv) = modfac(N - 10, MOD)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N - 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "(fac, inv) = modfac(N + 10, MOD)",
      "mutated_line": "(fac, inv) = modfac(N * 10, MOD)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N * 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for two in range(N + 1):",
      "mutated_line": "for two in range(N - 1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N - 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for two in range(N + 1):",
      "mutated_line": "for two in range(N * 1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N * 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "ans += now",
      "mutated_line": "ans -= now",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans -= now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorials = [1]",
      "mutated_line": "factorials = [2]",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [2]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorials = [1]",
      "mutated_line": "factorials = [0]",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [0]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorials = [1]",
      "mutated_line": "factorials = [0]",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [0]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "factorials = [1]",
      "mutated_line": "factorials = [-1]",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [-1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for m in range(1, n + 1):",
      "mutated_line": "for m in range(2, n + 1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(2, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for m in range(1, n + 1):",
      "mutated_line": "for m in range(0, n + 1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(0, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for m in range(1, n + 1):",
      "mutated_line": "for m in range(0, n + 1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(0, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for m in range(1, n + 1):",
      "mutated_line": "for m in range(-1, n + 1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(-1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for m in range(1, n + 1):",
      "mutated_line": "for m in range(1, n - 1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n - 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for m in range(1, n + 1):",
      "mutated_line": "for m in range(1, n * 1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n * 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "inv = pow(f, MOD - 2, MOD)",
      "mutated_line": "inv = pow(f, MOD + 2, MOD)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD + 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "inv = pow(f, MOD - 2, MOD)",
      "mutated_line": "inv = pow(f, MOD * 2, MOD)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD * 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "invs = [1] * (n + 1)",
      "mutated_line": "invs = [1] * (n - 1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n - 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "invs = [1] * (n + 1)",
      "mutated_line": "invs = [1] * (n * 1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n * 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for m in range(n, 1, -1):",
      "mutated_line": "for m in range(n, 2, -1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 2, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for m in range(n, 1, -1):",
      "mutated_line": "for m in range(n, 0, -1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 0, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for m in range(n, 1, -1):",
      "mutated_line": "for m in range(n, 0, -1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 0, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for m in range(n, 1, -1):",
      "mutated_line": "for m in range(n, -1, -1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, -1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "for m in range(n, 1, -1):",
      "mutated_line": "for m in range(n, 1, +1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, +1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[n] * inv[n - r] * inv[r] % mod",
      "mutated_line": "return fac[n] * inv[n - r] / inv[r] % mod",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] / inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[n] * inv[n - r] * inv[r] % mod",
      "mutated_line": "return (fac[n] * inv[n - r] + inv[r]) % mod",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return (fac[n] * inv[n - r] + inv[r]) % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[n] * inv[n - r] * inv[r] % mod",
      "mutated_line": "return (fac[n] * inv[n - r]) ** inv[r] % mod",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return (fac[n] * inv[n - r]) ** inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(fac, inv) = modfac(N + 10, MOD)",
      "mutated_line": "(fac, inv) = modfac(N + 11, MOD)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 11, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(fac, inv) = modfac(N + 10, MOD)",
      "mutated_line": "(fac, inv) = modfac(N + 9, MOD)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 9, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(fac, inv) = modfac(N + 10, MOD)",
      "mutated_line": "(fac, inv) = modfac(N + 0, MOD)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 0, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(fac, inv) = modfac(N + 10, MOD)",
      "mutated_line": "(fac, inv) = modfac(N + 1, MOD)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 1, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(fac, inv) = modfac(N + 10, MOD)",
      "mutated_line": "(fac, inv) = modfac(N + -10, MOD)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + -10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for two in range(N + 1):",
      "mutated_line": "for two in range(N + 2):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 2):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for two in range(N + 1):",
      "mutated_line": "for two in range(N + 0):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 0):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for two in range(N + 1):",
      "mutated_line": "for two in range(N + 0):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 0):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for two in range(N + 1):",
      "mutated_line": "for two in range(N + -1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + -1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for one in range(N + 1):",
      "mutated_line": "for one in range(N - 1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N - 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for one in range(N + 1):",
      "mutated_line": "for one in range(N * 1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N * 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if one + two > N:",
      "mutated_line": "if one + two >= N:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two >= N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if one + two > N:",
      "mutated_line": "if one + two <= N:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two <= N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if one + two > N:",
      "mutated_line": "if one + two != N:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two != N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dist = one + two * 2",
      "mutated_line": "dist = one - two * 2",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one - two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dist = one + two * 2",
      "mutated_line": "dist = one * (two * 2)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one * (two * 2)\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "now = 0",
      "mutated_line": "now = 1",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 1\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "now = 0",
      "mutated_line": "now = -1",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = -1\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "now = 0",
      "mutated_line": "now = 1",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 1\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if dist < X:",
      "mutated_line": "if dist <= X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist <= X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if dist < X:",
      "mutated_line": "if dist >= X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist >= X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if dist < X:",
      "mutated_line": "if dist != X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist != X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for m in range(1, n + 1):",
      "mutated_line": "for m in range(1, n + 2):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 2):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for m in range(1, n + 1):",
      "mutated_line": "for m in range(1, n + 0):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 0):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for m in range(1, n + 1):",
      "mutated_line": "for m in range(1, n + 0):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 0):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for m in range(1, n + 1):",
      "mutated_line": "for m in range(1, n + -1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + -1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv = pow(f, MOD - 2, MOD)",
      "mutated_line": "inv = pow(f, MOD - 3, MOD)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 3, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv = pow(f, MOD - 2, MOD)",
      "mutated_line": "inv = pow(f, MOD - 1, MOD)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 1, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv = pow(f, MOD - 2, MOD)",
      "mutated_line": "inv = pow(f, MOD - 0, MOD)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 0, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv = pow(f, MOD - 2, MOD)",
      "mutated_line": "inv = pow(f, MOD - 1, MOD)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 1, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "inv = pow(f, MOD - 2, MOD)",
      "mutated_line": "inv = pow(f, MOD - -2, MOD)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - -2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "invs = [1] * (n + 1)",
      "mutated_line": "invs = [2] * (n + 1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [2] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "invs = [1] * (n + 1)",
      "mutated_line": "invs = [0] * (n + 1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [0] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "invs = [1] * (n + 1)",
      "mutated_line": "invs = [0] * (n + 1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [0] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "invs = [1] * (n + 1)",
      "mutated_line": "invs = [-1] * (n + 1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [-1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "invs = [1] * (n + 1)",
      "mutated_line": "invs = [1] * (n + 2)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 2)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "invs = [1] * (n + 1)",
      "mutated_line": "invs = [1] * (n + 0)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 0)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "invs = [1] * (n + 1)",
      "mutated_line": "invs = [1] * (n + 0)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 0)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "invs = [1] * (n + 1)",
      "mutated_line": "invs = [1] * (n + -1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + -1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for m in range(n, 1, -1):",
      "mutated_line": "for m in range(n, 1, -2):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -2):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for m in range(n, 1, -1):",
      "mutated_line": "for m in range(n, 1, -0):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -0):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for m in range(n, 1, -1):",
      "mutated_line": "for m in range(n, 1, -0):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -0):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for m in range(n, 1, -1):",
      "mutated_line": "for m in range(n, 1, --1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, --1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "invs[m - 1] = inv",
      "mutated_line": "invs[m + 1] = inv",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m + 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "invs[m - 1] = inv",
      "mutated_line": "invs[m * 1] = inv",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m * 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[n] * inv[n - r] * inv[r] % mod",
      "mutated_line": "return fac[n] / inv[n - r] * inv[r] % mod",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] / inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[n] * inv[n - r] * inv[r] % mod",
      "mutated_line": "return (fac[n] + inv[n - r]) * inv[r] % mod",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return (fac[n] + inv[n - r]) * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[n] * inv[n - r] * inv[r] % mod",
      "mutated_line": "return fac[n] ** inv[n - r] * inv[r] % mod",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] ** inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for one in range(N + 1):",
      "mutated_line": "for one in range(N + 2):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 2):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for one in range(N + 1):",
      "mutated_line": "for one in range(N + 0):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 0):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for one in range(N + 1):",
      "mutated_line": "for one in range(N + 0):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 0):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for one in range(N + 1):",
      "mutated_line": "for one in range(N + -1):",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + -1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if one + two > N:",
      "mutated_line": "if one - two > N:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one - two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if one + two > N:",
      "mutated_line": "if one * two > N:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one * two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dist = one + two * 2",
      "mutated_line": "dist = one + two / 2",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two / 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dist = one + two * 2",
      "mutated_line": "dist = one + (two + 2)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + (two + 2)\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dist = one + two * 2",
      "mutated_line": "dist = one + two ** 2",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two ** 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "zero = modnCr(N, one + two, MOD, fac, inv)",
      "mutated_line": "zero = modnCr(N, one - two, MOD, fac, inv)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one - two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "zero = modnCr(N, one + two, MOD, fac, inv)",
      "mutated_line": "zero = modnCr(N, one * two, MOD, fac, inv)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one * two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "now = modnCr(one + two, one, MOD, fac, inv) * zero",
      "mutated_line": "now = modnCr(one + two, one, MOD, fac, inv) / zero",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) / zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "now = modnCr(one + two, one, MOD, fac, inv) * zero",
      "mutated_line": "now = modnCr(one + two, one, MOD, fac, inv) + zero",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) + zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "now = modnCr(one + two, one, MOD, fac, inv) * zero",
      "mutated_line": "now = modnCr(one + two, one, MOD, fac, inv) ** zero",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) ** zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif dist == X:",
      "mutated_line": "elif dist != X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist != X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "invs[m - 1] = inv",
      "mutated_line": "invs[m - 2] = inv",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 2] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "invs[m - 1] = inv",
      "mutated_line": "invs[m - 0] = inv",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 0] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "invs[m - 1] = inv",
      "mutated_line": "invs[m - 0] = inv",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 0] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "invs[m - 1] = inv",
      "mutated_line": "invs[m - -1] = inv",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - -1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dist = one + two * 2",
      "mutated_line": "dist = one + two * 3",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 3\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dist = one + two * 2",
      "mutated_line": "dist = one + two * 1",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 1\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dist = one + two * 2",
      "mutated_line": "dist = one + two * 0",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 0\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dist = one + two * 2",
      "mutated_line": "dist = one + two * 1",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 1\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dist = one + two * 2",
      "mutated_line": "dist = one + two * -2",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * -2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif dist < 2 * X:",
      "mutated_line": "elif dist <= 2 * X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist <= 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif dist < 2 * X:",
      "mutated_line": "elif dist >= 2 * X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist >= 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif dist < 2 * X:",
      "mutated_line": "elif dist != 2 * X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist != 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[n] * inv[n - r] * inv[r] % mod",
      "mutated_line": "return fac[n] * inv[n + r] * inv[r] % mod",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n + r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return fac[n] * inv[n - r] * inv[r] % mod",
      "mutated_line": "return fac[n] * inv[n * r] * inv[r] % mod",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n * r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "now = modnCr(one + two, one, MOD, fac, inv) * zero",
      "mutated_line": "now = modnCr(one - two, one, MOD, fac, inv) * zero",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one - two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "now = modnCr(one + two, one, MOD, fac, inv) * zero",
      "mutated_line": "now = modnCr(one * two, one, MOD, fac, inv) * zero",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one * two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "elif dist < 2 * X:",
      "mutated_line": "elif dist < 2 / X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 / X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "elif dist < 2 * X:",
      "mutated_line": "elif dist < 2 + X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 + X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "elif dist < 2 * X:",
      "mutated_line": "elif dist < 2 ** X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 ** X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if (dist - X) % 2 == 0:",
      "mutated_line": "if (dist - X) % 2 != 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 != 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dtwo = two - (dist - X + 1)",
      "mutated_line": "dtwo = two + (dist - X + 1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two + (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dtwo = two - (dist - X + 1)",
      "mutated_line": "dtwo = two * (dist - X + 1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two * (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if dtwo >= 0:",
      "mutated_line": "if dtwo > 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo > 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if dtwo >= 0:",
      "mutated_line": "if dtwo < 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo < 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if dtwo >= 0:",
      "mutated_line": "if dtwo == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo == 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % 2 == 1 or one == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 or one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif dist < 2 * X:",
      "mutated_line": "elif dist < 3 * X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 3 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif dist < 2 * X:",
      "mutated_line": "elif dist < 1 * X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 1 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif dist < 2 * X:",
      "mutated_line": "elif dist < 0 * X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 0 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif dist < 2 * X:",
      "mutated_line": "elif dist < 1 * X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 1 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif dist < 2 * X:",
      "mutated_line": "elif dist < -2 * X:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < -2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (dist - X) % 2 == 0:",
      "mutated_line": "if (dist - X) * 2 == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) * 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (dist - X) % 2 == 0:",
      "mutated_line": "if dist - X + 2 == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if dist - X + 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (dist - X) % 2 == 0:",
      "mutated_line": "if (dist - X) % 2 == 1:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 1:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (dist - X) % 2 == 0:",
      "mutated_line": "if (dist - X) % 2 == -1:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == -1:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (dist - X) % 2 == 0:",
      "mutated_line": "if (dist - X) % 2 == 1:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 1:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dtwo = two - (dist - X + 1)",
      "mutated_line": "dtwo = two - (dist - X - 1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X - 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dtwo = two - (dist - X + 1)",
      "mutated_line": "dtwo = two - (dist - X) * 1",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X) * 1\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if dtwo >= 0:",
      "mutated_line": "if dtwo >= 1:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 1:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if dtwo >= 0:",
      "mutated_line": "if dtwo >= -1:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= -1:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if dtwo >= 0:",
      "mutated_line": "if dtwo >= 1:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 1:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "now = modnCr(one + dtwo, one, MOD, fac, inv) * zero",
      "mutated_line": "now = modnCr(one + dtwo, one, MOD, fac, inv) / zero",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) / zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "now = modnCr(one + dtwo, one, MOD, fac, inv) * zero",
      "mutated_line": "now = modnCr(one + dtwo, one, MOD, fac, inv) + zero",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) + zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "now = modnCr(one + dtwo, one, MOD, fac, inv) * zero",
      "mutated_line": "now = modnCr(one + dtwo, one, MOD, fac, inv) ** zero",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) ** zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % 2 != 1 and one == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 != 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % 2 == 1 and one != 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one != 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (dist - X) % 2 == 0:",
      "mutated_line": "if (dist + X) % 2 == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist + X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if (dist - X) % 2 == 0:",
      "mutated_line": "if dist * X % 2 == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if dist * X % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (dist - X) % 2 == 0:",
      "mutated_line": "if (dist - X) % 3 == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 3 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (dist - X) % 2 == 0:",
      "mutated_line": "if (dist - X) % 1 == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 1 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (dist - X) % 2 == 0:",
      "mutated_line": "if (dist - X) % 0 == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 0 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (dist - X) % 2 == 0:",
      "mutated_line": "if (dist - X) % 1 == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 1 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if (dist - X) % 2 == 0:",
      "mutated_line": "if (dist - X) % -2 == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % -2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dtwo = two - (dist - X + 1)",
      "mutated_line": "dtwo = two - (dist + X + 1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist + X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dtwo = two - (dist - X + 1)",
      "mutated_line": "dtwo = two - (dist * X + 1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist * X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dtwo = two - (dist - X + 1)",
      "mutated_line": "dtwo = two - (dist - X + 2)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 2)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dtwo = two - (dist - X + 1)",
      "mutated_line": "dtwo = two - (dist - X + 0)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 0)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dtwo = two - (dist - X + 1)",
      "mutated_line": "dtwo = two - (dist - X + 0)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 0)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dtwo = two - (dist - X + 1)",
      "mutated_line": "dtwo = two - (dist - X + -1)",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + -1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X * 2 == 1 and one == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X * 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X + 2 == 1 and one == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X + 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % 2 == 2 and one == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 2 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % 2 == 0 and one == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 0 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % 2 == 0 and one == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 0 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % 2 == -1 and one == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == -1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % 2 == 1 and one == 1:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 1:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % 2 == 1 and one == -1:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == -1:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % 2 == 1 and one == 1:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 1:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "now = modnCr(one + dtwo, one, MOD, fac, inv) * zero",
      "mutated_line": "now = modnCr(one - dtwo, one, MOD, fac, inv) * zero",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one - dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "now = modnCr(one + dtwo, one, MOD, fac, inv) * zero",
      "mutated_line": "now = modnCr(one * dtwo, one, MOD, fac, inv) * zero",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one * dtwo, one, MOD, fac, inv) * zero\n            elif X % 2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % 3 == 1 and one == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 3 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % 1 == 1 and one == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 1 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % 0 == 1 and one == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 0 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % 1 == 1 and one == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % 1 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif X % 2 == 1 and one == 0:",
      "mutated_line": "elif X % -2 == 1 and one == 0:",
      "code": "def count_valid_sequences(N, X, MOD=998244353):\n\n    def modfac(n, MOD):\n        f = 1\n        factorials = [1]\n        for m in range(1, n + 1):\n            f *= m\n            f %= MOD\n            factorials.append(f)\n        inv = pow(f, MOD - 2, MOD)\n        invs = [1] * (n + 1)\n        invs[n] = inv\n        for m in range(n, 1, -1):\n            inv *= m\n            inv %= MOD\n            invs[m - 1] = inv\n        return (factorials, invs)\n\n    def modnCr(n, r, mod, fac, inv):\n        return fac[n] * inv[n - r] * inv[r] % mod\n    (fac, inv) = modfac(N + 10, MOD)\n    ans = 0\n    for two in range(N + 1):\n        for one in range(N + 1):\n            if one + two > N:\n                break\n            dist = one + two * 2\n            zero = modnCr(N, one + two, MOD, fac, inv)\n            now = 0\n            if dist < X:\n                now = modnCr(one + two, one, MOD, fac, inv) * zero\n            elif dist == X:\n                continue\n            elif dist < 2 * X:\n                if (dist - X) % 2 == 0:\n                    continue\n                dtwo = two - (dist - X + 1)\n                if dtwo >= 0:\n                    now = modnCr(one + dtwo, one, MOD, fac, inv) * zero\n            elif X % -2 == 1 and one == 0:\n                now = zero\n            ans += now\n            ans %= MOD\n    return ans"
    }
  ]
}