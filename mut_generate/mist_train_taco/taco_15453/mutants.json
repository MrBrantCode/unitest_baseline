{
  "task_id": "taco_15453",
  "entry_point": "compute_matrix_determinant",
  "mutant_count": 47,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "import collections\nMOD = 1000000008\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "import collections\nMOD = 1000000006\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "import collections\nMOD = 0\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "import collections\nMOD = 1\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "import collections\nMOD = -1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "product = 1",
      "mutated_line": "product = 2",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 2\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "product = 1",
      "mutated_line": "product = 0",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 0\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "product = 1",
      "mutated_line": "product = 0",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 0\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "product = 1",
      "mutated_line": "product = -1",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = -1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return dfs_compute(tree, weights, 1)",
      "mutated_line": "return dfs_compute(tree, weights, 2)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 2)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return dfs_compute(tree, weights, 1)",
      "mutated_line": "return dfs_compute(tree, weights, 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return dfs_compute(tree, weights, 1)",
      "mutated_line": "return dfs_compute(tree, weights, 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return dfs_compute(tree, weights, 1)",
      "mutated_line": "return dfs_compute(tree, weights, -1)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, -1)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if node not in visited:",
      "mutated_line": "if node in visited:",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product /= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product /= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "stack = [(-1, root)]",
      "mutated_line": "stack = [(+1, root)]",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(+1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] + (weights[parent - 1] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] + (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] * (weights[parent - 1] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] * (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for child in tree[node] - visited:",
      "mutated_line": "for child in tree[node] + visited:",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] + visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for child in tree[node] - visited:",
      "mutated_line": "for child in tree[node] * visited:",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] * visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(-1, root)]",
      "mutated_line": "stack = [(-2, root)]",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-2, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(-1, root)]",
      "mutated_line": "stack = [(-0, root)]",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-0, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(-1, root)]",
      "mutated_line": "stack = [(-0, root)]",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-0, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "stack = [(-1, root)]",
      "mutated_line": "stack = [(--1, root)]",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(--1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node + 1] - (weights[parent - 1] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node + 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node * 1] - (weights[parent - 1] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node * 1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - 1] if parent >= -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent >= -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - 1] if parent <= -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent <= -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - 1] if parent != -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent != -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 1)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 1)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else -1)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else -1)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 1)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 1)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 2] - (weights[parent - 1] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 2] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 0] - (weights[parent - 1] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 0] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 0] - (weights[parent - 1] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 0] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - -1] - (weights[parent - 1] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - -1] - (weights[parent - 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > +1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > +1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent + 1] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent + 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent * 1] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent * 1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -2 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -2 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -0 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -0 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -0 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > -0 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > --1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 1] if parent > --1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - 2] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 2] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - 0] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 0] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - 0] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - 0] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "product *= weights[node - 1] - (weights[parent - 1] if parent > -1 else 0)",
      "mutated_line": "product *= weights[node - 1] - (weights[parent - -1] if parent > -1 else 0)",
      "code": "import collections\nMOD = 1000000007\n\ndef compute_matrix_determinant(N, weights, edges):\n    tree = collections.defaultdict(set)\n    for (x, y) in edges:\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def dfs_compute(tree, weights, root):\n        visited = set()\n        stack = [(-1, root)]\n        product = 1\n        while stack:\n            (parent, node) = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                product *= weights[node - 1] - (weights[parent - -1] if parent > -1 else 0)\n                product %= MOD\n                for child in tree[node] - visited:\n                    stack.append((node, child))\n        return product\n    return dfs_compute(tree, weights, 1)"
    }
  ]
}