{
  "task_id": "taco_1729",
  "entry_point": "max_knapsack_value",
  "mutant_count": 55,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [0] * (W + 1)",
      "mutated_line": "for (v, w, m) in items:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] / (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [0] * (W + 1)",
      "mutated_line": "for (v, w, m) in items:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] + (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [0] * (W + 1)",
      "mutated_line": "for (v, w, m) in items:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] ** (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [0] * (W + 1)",
      "mutated_line": "for (v, w, m) in items:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W - 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [0] * (W + 1)",
      "mutated_line": "for (v, w, m) in items:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W * 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [0] * (W + 1)",
      "mutated_line": "for (v, w, m) in items:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [1] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [0] * (W + 1)",
      "mutated_line": "for (v, w, m) in items:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [-1] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [0] * (W + 1)",
      "mutated_line": "for (v, w, m) in items:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [1] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [0] * (W + 1)",
      "mutated_line": "for (v, w, m) in items:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 2)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [0] * (W + 1)",
      "mutated_line": "for (v, w, m) in items:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 0)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [0] * (W + 1)",
      "mutated_line": "for (v, w, m) in items:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 0)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [0] * (W + 1)",
      "mutated_line": "for (v, w, m) in items:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + -1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for j in range(W + 1):",
      "mutated_line": "for j in range(W - 1):",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W - 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for j in range(W + 1):",
      "mutated_line": "for j in range(W * 1):",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W * 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "wj = ofs + j * w",
      "mutated_line": "wj = ofs - j * w",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs - j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "wj = ofs + j * w",
      "mutated_line": "wj = ofs * (j * w)",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs * (j * w)\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if wj > W:",
      "mutated_line": "if wj >= W:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj >= W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if wj > W:",
      "mutated_line": "if wj <= W:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj <= W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if wj > W:",
      "mutated_line": "if wj != W:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj != W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "src = dp[wj] - j * v",
      "mutated_line": "src = dp[wj] + j * v",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] + j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "src = dp[wj] - j * v",
      "mutated_line": "src = dp[wj] * (j * v)",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] * (j * v)\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "while q and q[-1][1] <= src:",
      "mutated_line": "while q or q[-1][1] <= src:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q or q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(W + 1):",
      "mutated_line": "for j in range(W + 2):",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 2):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(W + 1):",
      "mutated_line": "for j in range(W + 0):",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 0):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(W + 1):",
      "mutated_line": "for j in range(W + 0):",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 0):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(W + 1):",
      "mutated_line": "for j in range(W + -1):",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + -1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "wj = ofs + j * w",
      "mutated_line": "wj = ofs + j / w",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j / w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "wj = ofs + j * w",
      "mutated_line": "wj = ofs + (j + w)",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + (j + w)\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "wj = ofs + j * w",
      "mutated_line": "wj = ofs + j ** w",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j ** w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "src = dp[wj] - j * v",
      "mutated_line": "src = dp[wj] - j / v",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j / v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "src = dp[wj] - j * v",
      "mutated_line": "src = dp[wj] - (j + v)",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - (j + v)\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "src = dp[wj] - j * v",
      "mutated_line": "src = dp[wj] - j ** v",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j ** v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while q and q[-1][1] <= src:",
      "mutated_line": "while q and q[-1][1] < src:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] < src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while q and q[-1][1] <= src:",
      "mutated_line": "while q and q[-1][1] > src:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] > src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while q and q[-1][1] <= src:",
      "mutated_line": "while q and q[-1][1] == src:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] == src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[wj] = nv + j * v",
      "mutated_line": "dp[wj] = nv - j * v",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv - j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[wj] = nv + j * v",
      "mutated_line": "dp[wj] = nv * (j * v)",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv * (j * v)\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if ni == j - m:",
      "mutated_line": "if ni != j - m:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni != j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(ni, nv) = q[0]",
      "mutated_line": "(ni, nv) = q[1]",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[1]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(ni, nv) = q[0]",
      "mutated_line": "(ni, nv) = q[-1]",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[-1]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(ni, nv) = q[0]",
      "mutated_line": "(ni, nv) = q[1]",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[1]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[wj] = nv + j * v",
      "mutated_line": "dp[wj] = nv + j / v",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j / v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[wj] = nv + j * v",
      "mutated_line": "dp[wj] = nv + (j + v)",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + (j + v)\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[wj] = nv + j * v",
      "mutated_line": "dp[wj] = nv + j ** v",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j ** v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if ni == j - m:",
      "mutated_line": "if ni == j + m:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j + m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if ni == j - m:",
      "mutated_line": "if ni == j * m:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j * m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while q and q[-1][1] <= src:",
      "mutated_line": "while q and q[-1][2] <= src:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][2] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while q and q[-1][1] <= src:",
      "mutated_line": "while q and q[-1][0] <= src:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][0] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while q and q[-1][1] <= src:",
      "mutated_line": "while q and q[-1][0] <= src:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][0] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while q and q[-1][1] <= src:",
      "mutated_line": "while q and q[-1][-1] <= src:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-1][-1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "while q and q[-1][1] <= src:",
      "mutated_line": "while q and q[+1][1] <= src:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[+1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while q and q[-1][1] <= src:",
      "mutated_line": "while q and q[-2][1] <= src:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-2][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while q and q[-1][1] <= src:",
      "mutated_line": "while q and q[-0][1] <= src:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-0][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while q and q[-1][1] <= src:",
      "mutated_line": "while q and q[-0][1] <= src:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[-0][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while q and q[-1][1] <= src:",
      "mutated_line": "while q and q[--1][1] <= src:",
      "code": "def max_knapsack_value(N, W, items):\n    from collections import deque\n    dp = [0] * (W + 1)\n    for (v, w, m) in items:\n        for ofs in range(w):\n            q = deque()\n            for j in range(W + 1):\n                wj = ofs + j * w\n                if wj > W:\n                    break\n                src = dp[wj] - j * v\n                while q and q[--1][1] <= src:\n                    q.pop()\n                q.append((j, src))\n                if q:\n                    (ni, nv) = q[0]\n                    dp[wj] = nv + j * v\n                    if ni == j - m:\n                        q.popleft()\n    return max(dp)"
    }
  ]
}