{
  "task_id": "taco_9947",
  "entry_point": "can_form_three_circuits",
  "mutant_count": 145,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] / (N + 1)",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] / (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] + (N + 1)",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] + (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] ** (N + 1)",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] ** (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "D[a] += 1",
      "mutated_line": "D[a] -= 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] -= 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "D[b] += 1",
      "mutated_line": "D[b] -= 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] -= 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "E = [0] * 7",
      "mutated_line": "E = [0] / 7",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] / 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "E = [0] * 7",
      "mutated_line": "E = [0] + 7",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] + 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "E = [0] * 7",
      "mutated_line": "E = [0] ** 7",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] ** 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 0 and E[4] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 and E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] * (N - 1)",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N - 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] * (N * 1)",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N * 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "D[a] += 1",
      "mutated_line": "D[a] += 2",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 2\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "D[a] += 1",
      "mutated_line": "D[a] += 0",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 0\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "D[a] += 1",
      "mutated_line": "D[a] += 0",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 0\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "D[a] += 1",
      "mutated_line": "D[a] += -1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += -1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "D[b] += 1",
      "mutated_line": "D[b] += 2",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 2\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "D[b] += 1",
      "mutated_line": "D[b] += 0",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 0\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "D[b] += 1",
      "mutated_line": "D[b] += 0",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 0\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "D[b] += 1",
      "mutated_line": "D[b] += -1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += -1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "E = [0] * 7",
      "mutated_line": "E = [0] * 8",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 8\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "E = [0] * 7",
      "mutated_line": "E = [0] * 6",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 6\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "E = [0] * 7",
      "mutated_line": "E = [0] * 0",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 0\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "E = [0] * 7",
      "mutated_line": "E = [0] * 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 1\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "E = [0] * 7",
      "mutated_line": "E = [0] * -7",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * -7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 2 != 0:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 != 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] >= 0 or E[4] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] >= 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] <= 0 or E[4] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] <= 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] != 0 or E[4] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] != 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 0 or E[4] >= 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] >= 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 0 or E[4] <= 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] <= 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 0 or E[4] != 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] != 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 'Yes'",
      "mutated_line": "return ''",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return ''\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif E[4] < 2:",
      "mutated_line": "elif E[4] <= 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] <= 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif E[4] < 2:",
      "mutated_line": "elif E[4] >= 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] >= 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "elif E[4] < 2:",
      "mutated_line": "elif E[4] != 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] != 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [1] * (N + 1)",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [1] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [-1] * (N + 1)",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [-1] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [1] * (N + 1)",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [1] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] * (N + 2)",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 2)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] * (N + 0)",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 0)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] * (N + 0)",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 0)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "D = [0] * (N + 1)",
      "mutated_line": "D = [0] * (N + -1)",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + -1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "E = [0] * 7",
      "mutated_line": "E = [1] * 7",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [1] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "E = [0] * 7",
      "mutated_line": "E = [-1] * 7",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [-1] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "E = [0] * 7",
      "mutated_line": "E = [1] * 7",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [1] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for a, d in enumerate(D[1:], start=1):",
      "mutated_line": "for (a, d) in enumerate(D[1:], start=2):",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=2):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for a, d in enumerate(D[1:], start=1):",
      "mutated_line": "for (a, d) in enumerate(D[1:], start=0):",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=0):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for a, d in enumerate(D[1:], start=1):",
      "mutated_line": "for (a, d) in enumerate(D[1:], start=0):",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=0):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for a, d in enumerate(D[1:], start=1):",
      "mutated_line": "for (a, d) in enumerate(D[1:], start=-1):",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=-1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d * 2 == 0:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d * 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d + 2 == 0:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d + 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 2 == 1:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 1:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 2 == -1:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == -1:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 2 == 1:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 1:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if d >= 6:",
      "mutated_line": "if d > 6:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d > 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if d >= 6:",
      "mutated_line": "if d < 6:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d < 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if d >= 6:",
      "mutated_line": "if d == 6:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d == 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "E[6] += 1",
      "mutated_line": "E[6] -= 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] -= 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return 'No'",
      "mutated_line": "return ''",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return ''\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 1 or E[4] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 1 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > -1 or E[4] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > -1 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 1 or E[4] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 1 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 0 or E[4] > 3:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 3:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 0 or E[4] > 1:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 1:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 0 or E[4] > 0:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 0:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 0 or E[4] > 1:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 1:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 0 or E[4] > -2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > -2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif E[4] < 2:",
      "mutated_line": "elif E[4] < 3:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 3:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif E[4] < 2:",
      "mutated_line": "elif E[4] < 1:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 1:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif E[4] < 2:",
      "mutated_line": "elif E[4] < 0:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 0:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif E[4] < 2:",
      "mutated_line": "elif E[4] < 1:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 1:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif E[4] < 2:",
      "mutated_line": "elif E[4] < -2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < -2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 'No'",
      "mutated_line": "return ''",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return ''\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if set(F[x]) & R == set(F[x]):",
      "mutated_line": "if set(F[x]) & R != set(F[x]):",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R != set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "F = [list() for _ in range(N + 1)]",
      "mutated_line": "F = [list() for _ in range(N - 1)]",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N - 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "F = [list() for _ in range(N + 1)]",
      "mutated_line": "F = [list() for _ in range(N * 1)]",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N * 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for a, d in enumerate(D[1:], start=1):",
      "mutated_line": "for (a, d) in enumerate(D[2:], start=1):",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[2:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for a, d in enumerate(D[1:], start=1):",
      "mutated_line": "for (a, d) in enumerate(D[0:], start=1):",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[0:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for a, d in enumerate(D[1:], start=1):",
      "mutated_line": "for (a, d) in enumerate(D[0:], start=1):",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[0:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for a, d in enumerate(D[1:], start=1):",
      "mutated_line": "for (a, d) in enumerate(D[-1:], start=1):",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[-1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 3 == 0:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 3 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 1 == 0:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 1 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 0 == 0:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 0 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % 1 == 0:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 1 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if d % 2 == 0:",
      "mutated_line": "if d % -2 == 0:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % -2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if d >= 6:",
      "mutated_line": "if d >= 7:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 7:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if d >= 6:",
      "mutated_line": "if d >= 5:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 5:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if d >= 6:",
      "mutated_line": "if d >= 0:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 0:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if d >= 6:",
      "mutated_line": "if d >= 1:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 1:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if d >= 6:",
      "mutated_line": "if d >= -6:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= -6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "E[6] += 1",
      "mutated_line": "E[6] += 2",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 2\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "E[6] += 1",
      "mutated_line": "E[6] += 0",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 0\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "E[6] += 1",
      "mutated_line": "E[6] += 0",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 0\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "E[6] += 1",
      "mutated_line": "E[6] += -1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += -1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "elif d == 4:",
      "mutated_line": "elif d != 4:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d != 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "E[4] += 1",
      "mutated_line": "E[4] -= 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] -= 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "E[d] += 1",
      "mutated_line": "E[d] -= 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] -= 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[7] > 0 or E[4] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[7] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[5] > 0 or E[4] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[5] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[0] > 0 or E[4] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[0] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[1] > 0 or E[4] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[1] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[-6] > 0 or E[4] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[-6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 0 or E[5] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[5] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 0 or E[3] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[3] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 0 or E[0] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[0] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 0 or E[1] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[1] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if E[6] > 0 or E[4] > 2:",
      "mutated_line": "if E[6] > 0 or E[-4] > 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[-4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif E[4] < 2:",
      "mutated_line": "elif E[5] < 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[5] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif E[4] < 2:",
      "mutated_line": "elif E[3] < 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[3] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif E[4] < 2:",
      "mutated_line": "elif E[0] < 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[0] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif E[4] < 2:",
      "mutated_line": "elif E[1] < 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[1] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "elif E[4] < 2:",
      "mutated_line": "elif E[-4] < 2:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[-4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "q |= set(F[z]) - R",
      "mutated_line": "q |= set(F[z]) + R",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) + R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "q |= set(F[z]) - R",
      "mutated_line": "q |= set(F[z]) * R",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) * R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if set(F[x]) & R == set(F[x]):",
      "mutated_line": "if set(F[x]) | R == set(F[x]):",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) | R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return 'No'",
      "mutated_line": "return ''",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return ''\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return 'Yes'",
      "mutated_line": "return ''",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return ''"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "F = [list() for _ in range(N + 1)]",
      "mutated_line": "F = [list() for _ in range(N + 2)]",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 2)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "F = [list() for _ in range(N + 1)]",
      "mutated_line": "F = [list() for _ in range(N + 0)]",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 0)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "F = [list() for _ in range(N + 1)]",
      "mutated_line": "F = [list() for _ in range(N + 0)]",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 0)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "F = [list() for _ in range(N + 1)]",
      "mutated_line": "F = [list() for _ in range(N + -1)]",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + -1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "E[6] += 1",
      "mutated_line": "E[7] += 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[7] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "E[6] += 1",
      "mutated_line": "E[5] += 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[5] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "E[6] += 1",
      "mutated_line": "E[0] += 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[0] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "E[6] += 1",
      "mutated_line": "E[1] += 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[1] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "E[6] += 1",
      "mutated_line": "E[-6] += 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[-6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "elif d == 4:",
      "mutated_line": "elif d == 5:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 5:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "elif d == 4:",
      "mutated_line": "elif d == 3:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 3:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "elif d == 4:",
      "mutated_line": "elif d == 0:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 0:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "elif d == 4:",
      "mutated_line": "elif d == 1:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 1:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "elif d == 4:",
      "mutated_line": "elif d == -4:",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == -4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "E[4] += 1",
      "mutated_line": "E[4] += 2",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 2\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "E[4] += 1",
      "mutated_line": "E[4] += 0",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 0\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "E[4] += 1",
      "mutated_line": "E[4] += 0",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 0\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "E[4] += 1",
      "mutated_line": "E[4] += -1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += -1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "E[d] += 1",
      "mutated_line": "E[d] += 2",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 2\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "E[d] += 1",
      "mutated_line": "E[d] += 0",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 0\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "E[d] += 1",
      "mutated_line": "E[d] += 0",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += 0\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "E[d] += 1",
      "mutated_line": "E[d] += -1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[4] += 1\n                X.append(a)\n            else:\n                E[d] += -1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "E[4] += 1",
      "mutated_line": "E[5] += 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[5] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "E[4] += 1",
      "mutated_line": "E[3] += 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[3] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "E[4] += 1",
      "mutated_line": "E[0] += 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[0] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "E[4] += 1",
      "mutated_line": "E[1] += 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[1] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "E[4] += 1",
      "mutated_line": "E[-4] += 1",
      "code": "def can_form_three_circuits(N, M, edges):\n    \"\"\"\n    Determines if three circuits can be formed using each of the edges exactly once in a given simple connected undirected graph.\n\n    Parameters:\n    - N (int): The number of vertices in the graph.\n    - M (int): The number of edges in the graph.\n    - edges (list of tuples): A list of tuples where each tuple represents an edge between two vertices.\n\n    Returns:\n    - str: 'Yes' if three circuits can be formed, otherwise 'No'.\n    \"\"\"\n    F = [list() for _ in range(N + 1)]\n    D = [0] * (N + 1)\n    for (a, b) in edges:\n        D[a] += 1\n        D[b] += 1\n        F[a].append(b)\n        F[b].append(a)\n    E = [0] * 7\n    X = []\n    for (a, d) in enumerate(D[1:], start=1):\n        if d % 2 == 0:\n            if d >= 6:\n                E[6] += 1\n            elif d == 4:\n                E[-4] += 1\n                X.append(a)\n            else:\n                E[d] += 1\n        else:\n            return 'No'\n    if E[6] > 0 or E[4] > 2:\n        return 'Yes'\n    elif E[4] < 2:\n        return 'No'\n    else:\n        (x, y) = X\n        q = set([y])\n        R = set([x])\n        while q:\n            z = q.pop()\n            R.add(z)\n            q |= set(F[z]) - R\n        if set(F[x]) & R == set(F[x]):\n            return 'No'\n        else:\n            return 'Yes'"
    }
  ]
}