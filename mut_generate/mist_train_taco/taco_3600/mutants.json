{
  "task_id": "taco_3600",
  "entry_point": "calculate_niceness",
  "mutant_count": 108,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "parent = [0] * (N + N)",
      "mutated_line": "parent = [0] / (N + N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] / (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "parent = [0] * (N + N)",
      "mutated_line": "parent = [0] + (N + N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] + (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "parent = [0] * (N + N)",
      "mutated_line": "parent = [0] ** (N + N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] ** (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "value = [0] * (N + N)",
      "mutated_line": "value = [0] / (N + N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] / (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "value = [0] * (N + N)",
      "mutated_line": "value = [0] + (N + N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] + (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "value = [0] * (N + N)",
      "mutated_line": "value = [0] ** (N + N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] ** (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] * N - [0] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N - [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = ([0] + [1] * N) * ([0] * (N - 1))",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = ([0] + [1] * N) * ([0] * (N - 1))\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "size[p] += size[n]",
      "mutated_line": "size[p] -= size[n]",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] -= size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "value[n] += value[p]",
      "mutated_line": "value[n] -= value[p]",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] -= value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while root[x] != x:",
      "mutated_line": "while root[x] == x:",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] == x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if x == y:",
      "mutated_line": "if x != y:",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x != y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < y:",
      "mutated_line": "if x <= y:",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x <= y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < y:",
      "mutated_line": "if x >= y:",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x >= y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if x < y:",
      "mutated_line": "if x != y:",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x != y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "uf = UnionFind(N + N)",
      "mutated_line": "uf = UnionFind(N - N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N - N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "uf = UnionFind(N + N)",
      "mutated_line": "uf = UnionFind(N * N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N * N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "parent = [0] * (N + N)",
      "mutated_line": "parent = [0] * (N - N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N - N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "parent = [0] * (N + N)",
      "mutated_line": "parent = [0] * (N * N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N * N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "value = [0] * (N + N)",
      "mutated_line": "value = [0] * (N - N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N - N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "value = [0] * (N + N)",
      "mutated_line": "value = [0] * (N * N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N * N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for (n, (a, b, c)) in enumerate(ABC, N + 1):",
      "mutated_line": "for (n, (a, b, c)) in enumerate(ABC, N - 1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N - 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for (n, (a, b, c)) in enumerate(ABC, N + 1):",
      "mutated_line": "for (n, (a, b, c)) in enumerate(ABC, N * 1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N * 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] - [1] * N + [0] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] - [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] * ([1] * N) + [0] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] * ([1] * N) + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] * N + [0] / (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] / (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] * N + ([0] + (N - 1))",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + ([0] + (N - 1))\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] * N + [0] ** (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] ** (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for n in range(N + N):",
      "mutated_line": "for n in range(N - N):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N - N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for n in range(N + N):",
      "mutated_line": "for n in range(N * N):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N * N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "for n in range(N + N):",
      "mutated_line": "for n in range(N - N):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N - N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "for n in range(N + N):",
      "mutated_line": "for n in range(N * N):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N * N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "value[n] = 0",
      "mutated_line": "value[n] = 1",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 1\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "value[n] = 0",
      "mutated_line": "value[n] = -1",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = -1\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "value[n] = 0",
      "mutated_line": "value[n] = 1",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 1\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "value[n] = value[p] * (size[p] - size[n])",
      "mutated_line": "value[n] = value[p] / (size[p] - size[n])",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] / (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "value[n] = value[p] * (size[p] - size[n])",
      "mutated_line": "value[n] = value[p] + (size[p] - size[n])",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] + (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "value[n] = value[p] * (size[p] - size[n])",
      "mutated_line": "value[n] = value[p] ** (size[p] - size[n])",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] ** (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N + N + 2, 0, -1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N + 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range((N + N) * 2, 0, -1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range((N + N) * 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N + N - 2, 1, -1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 1, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N + N - 2, -1, -1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, -1, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N + N - 2, 1, -1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 1, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "UOI",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N + N - 2, 0, +1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, +1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ABC = sorted(edges, key=itemgetter(2), reverse=True)",
      "mutated_line": "ABC = sorted(edges, key=itemgetter(2), reverse=False)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=False)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "parent = [0] * (N + N)",
      "mutated_line": "parent = [1] * (N + N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [1] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "parent = [0] * (N + N)",
      "mutated_line": "parent = [-1] * (N + N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [-1] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "parent = [0] * (N + N)",
      "mutated_line": "parent = [1] * (N + N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [1] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "value = [0] * (N + N)",
      "mutated_line": "value = [1] * (N + N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [1] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "value = [0] * (N + N)",
      "mutated_line": "value = [-1] * (N + N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [-1] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "value = [0] * (N + N)",
      "mutated_line": "value = [1] * (N + N)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [1] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for (n, (a, b, c)) in enumerate(ABC, N + 1):",
      "mutated_line": "for (n, (a, b, c)) in enumerate(ABC, N + 2):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 2):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for (n, (a, b, c)) in enumerate(ABC, N + 1):",
      "mutated_line": "for (n, (a, b, c)) in enumerate(ABC, N + 0):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 0):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for (n, (a, b, c)) in enumerate(ABC, N + 1):",
      "mutated_line": "for (n, (a, b, c)) in enumerate(ABC, N + 0):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 0):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for (n, (a, b, c)) in enumerate(ABC, N + 1):",
      "mutated_line": "for (n, (a, b, c)) in enumerate(ABC, N + -1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + -1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] / N + [0] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] / N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + ([1] + N) + [0] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + ([1] + N) + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] ** N + [0] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] ** N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] * N + [0] * (N + 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N + 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] * N + [0] * (N * 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N * 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "value[n] = value[p] * (size[p] - size[n])",
      "mutated_line": "value[n] = value[p] * (size[p] + size[n])",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] + size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "value[n] = value[p] * (size[p] - size[n])",
      "mutated_line": "value[n] = value[p] * (size[p] * size[n])",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] * size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N - N - 2, 0, -1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N - N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N * N - 2, 0, -1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N * N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N + N - 3, 0, -1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 3, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N + N - 1, 0, -1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 1, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N + N - 0, 0, -1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 0, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N + N - 1, 0, -1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 1, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N + N - -2, 0, -1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - -2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N + N - 2, 0, -2):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -2):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N + N - 2, 0, -0):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -0):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N + N - 2, 0, -0):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -0):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "for n in range(N + N - 2, 0, -1):",
      "mutated_line": "for n in range(N + N - 2, 0, --1):",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, --1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return value[1:N + 1]",
      "mutated_line": "return value[2:N + 1]",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[2:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return value[1:N + 1]",
      "mutated_line": "return value[0:N + 1]",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[0:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return value[1:N + 1]",
      "mutated_line": "return value[0:N + 1]",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[0:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return value[1:N + 1]",
      "mutated_line": "return value[-1:N + 1]",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[-1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return value[1:N + 1]",
      "mutated_line": "return value[1:N - 1]",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "return value[1:N + 1]",
      "mutated_line": "return value[1:N * 1]",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N * 1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.root = list(range(N + 1))",
      "mutated_line": "self.root = list(range(N - 1))",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N - 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.root = list(range(N + 1))",
      "mutated_line": "self.root = list(range(N * 1))",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N * 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ABC = sorted(edges, key=itemgetter(2), reverse=True)",
      "mutated_line": "ABC = sorted(edges, key=itemgetter(3), reverse=True)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(3), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ABC = sorted(edges, key=itemgetter(2), reverse=True)",
      "mutated_line": "ABC = sorted(edges, key=itemgetter(1), reverse=True)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(1), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ABC = sorted(edges, key=itemgetter(2), reverse=True)",
      "mutated_line": "ABC = sorted(edges, key=itemgetter(0), reverse=True)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(0), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ABC = sorted(edges, key=itemgetter(2), reverse=True)",
      "mutated_line": "ABC = sorted(edges, key=itemgetter(1), reverse=True)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(1), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ABC = sorted(edges, key=itemgetter(2), reverse=True)",
      "mutated_line": "ABC = sorted(edges, key=itemgetter(-2), reverse=True)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(-2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [1] + [1] * N + [0] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [1] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [-1] + [1] * N + [0] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [-1] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [1] + [1] * N + [0] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [1] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] * N + [1] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [1] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] * N + [-1] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [-1] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] * N + [1] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [1] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] * N + [0] * (N - 2)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 2)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] * N + [0] * (N - 0)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 0)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] * N + [0] * (N - 0)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 0)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [1] * N + [0] * (N - -1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - -1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return value[1:N + 1]",
      "mutated_line": "return value[1:N + 2]",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 2]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return value[1:N + 1]",
      "mutated_line": "return value[1:N + 0]",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 0]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return value[1:N + 1]",
      "mutated_line": "return value[1:N + 0]",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 0]"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return value[1:N + 1]",
      "mutated_line": "return value[1:N + -1]",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + -1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.root = list(range(N + 1))",
      "mutated_line": "self.root = list(range(N + 2))",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 2))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.root = list(range(N + 1))",
      "mutated_line": "self.root = list(range(N + 0))",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 0))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.root = list(range(N + 1))",
      "mutated_line": "self.root = list(range(N + 0))",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 0))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.root = list(range(N + 1))",
      "mutated_line": "self.root = list(range(N + -1))",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + -1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [2] * N + [0] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [2] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [0] * N + [0] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [0] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [0] * N + [0] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [0] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "size = [0] + [1] * N + [0] * (N - 1)",
      "mutated_line": "size = [0] + [-1] * N + [0] * (N - 1)",
      "code": "import sys\nfrom operator import itemgetter\n\nclass UnionFind:\n\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        if x < y:\n            (x, y) = (y, x)\n        self.root[y] = x\n\ndef calculate_niceness(N, edges):\n    ABC = sorted(edges, key=itemgetter(2), reverse=True)\n    uf = UnionFind(N + N)\n    parent = [0] * (N + N)\n    value = [0] * (N + N)\n    for (n, (a, b, c)) in enumerate(ABC, N + 1):\n        ra = uf[a]\n        rb = uf[b]\n        parent[ra] = n\n        parent[rb] = n\n        value[n] = c\n        uf.merge(ra, n)\n        uf.merge(rb, n)\n    size = [0] + [-1] * N + [0] * (N - 1)\n    for n in range(N + N):\n        p = parent[n]\n        size[p] += size[n]\n    for n in range(N + N):\n        p = parent[n]\n        value[n] = 0\n        if not p:\n            continue\n        value[n] = value[p] * (size[p] - size[n])\n    for n in range(N + N - 2, 0, -1):\n        p = parent[n]\n        value[n] += value[p]\n    return value[1:N + 1]"
    }
  ]
}