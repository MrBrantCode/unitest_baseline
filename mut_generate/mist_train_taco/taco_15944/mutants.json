{
  "task_id": "taco_15944",
  "entry_point": "minimum_strokes",
  "mutant_count": 129,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = float('inf')",
      "mutated_line": "INF = float('')",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sx, sy = x1 - 1, y1 - 1",
      "mutated_line": "(gx, gy) = (x2 - 1, y2 - 1)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 + 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sx, sy = x1 - 1, y1 - 1",
      "mutated_line": "(gx, gy) = (x2 - 1, y2 - 1)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 * 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sx, sy = x1 - 1, y1 - 1",
      "mutated_line": "(gx, gy) = (x2 - 1, y2 - 1)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 + 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sx, sy = x1 - 1, y1 - 1",
      "mutated_line": "(gx, gy) = (x2 - 1, y2 - 1)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 * 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "gx, gy = x2 - 1, y2 - 1",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 + 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "gx, gy = x2 - 1, y2 - 1",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 * 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "gx, gy = x2 - 1, y2 - 1",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 + 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "gx, gy = x2 - 1, y2 - 1",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 * 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist[sh][sw] = 0",
      "mutated_line": "dist[sh][sw] = 1",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 1\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist[sh][sw] = 0",
      "mutated_line": "dist[sh][sw] = -1",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = -1\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist[sh][sw] = 0",
      "mutated_line": "dist[sh][sw] = 1",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 1\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans == INF else -1",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans == INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else +1",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else +1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sx, sy = x1 - 1, y1 - 1",
      "mutated_line": "(gx, gy) = (x2 - 1, y2 - 1)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 2, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sx, sy = x1 - 1, y1 - 1",
      "mutated_line": "(gx, gy) = (x2 - 1, y2 - 1)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 0, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sx, sy = x1 - 1, y1 - 1",
      "mutated_line": "(gx, gy) = (x2 - 1, y2 - 1)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 0, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sx, sy = x1 - 1, y1 - 1",
      "mutated_line": "(gx, gy) = (x2 - 1, y2 - 1)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - -1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sx, sy = x1 - 1, y1 - 1",
      "mutated_line": "(gx, gy) = (x2 - 1, y2 - 1)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 2)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sx, sy = x1 - 1, y1 - 1",
      "mutated_line": "(gx, gy) = (x2 - 1, y2 - 1)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 0)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sx, sy = x1 - 1, y1 - 1",
      "mutated_line": "(gx, gy) = (x2 - 1, y2 - 1)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 0)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sx, sy = x1 - 1, y1 - 1",
      "mutated_line": "(gx, gy) = (x2 - 1, y2 - 1)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - -1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "gx, gy = x2 - 1, y2 - 1",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 2, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "gx, gy = x2 - 1, y2 - 1",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 0, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "gx, gy = x2 - 1, y2 - 1",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 0, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "gx, gy = x2 - 1, y2 - 1",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - -1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "gx, gy = x2 - 1, y2 - 1",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 2)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "gx, gy = x2 - 1, y2 - 1",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 0)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "gx, gy = x2 - 1, y2 - 1",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 0)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "gx, gy = x2 - 1, y2 - 1",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - -1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dist = [[INF] * W for _ in range(H)]",
      "mutated_line": "dist = [[INF] / W for _ in range(H)]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] / W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dist = [[INF] * W for _ in range(H)]",
      "mutated_line": "dist = [[INF] + W for _ in range(H)]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] + W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dist = [[INF] * W for _ in range(H)]",
      "mutated_line": "dist = [[INF] ** W for _ in range(H)]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] ** W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [2, 0, -1, 0]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [2, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [0, 0, -1, 0]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [0, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [0, 0, -1, 0]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [0, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [-1, 0, -1, 0]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [-1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [1, 1, -1, 0]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 1, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [1, -1, -1, 0]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, -1, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [1, 1, -1, 0]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 1, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [1, 0, +1, 0]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, +1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [1, 0, -1, 1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 1]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [1, 0, -1, -1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, -1]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [1, 0, -1, 1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 1]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [1, 1, 0, -1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [1, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [-1, 1, 0, -1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [-1, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [1, 1, 0, -1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [1, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [0, 2, 0, -1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 2, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [0, 0, 0, -1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 0, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [0, 0, 0, -1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 0, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [0, -1, 0, -1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, -1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [0, 1, 1, -1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 1, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [0, 1, -1, -1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, -1, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [0, 1, 1, -1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 1, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [0, 1, 0, +1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, +1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else -2",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -2"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else -0",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else -0",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -0"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return ans if ans != INF else -1",
      "mutated_line": "return ans if ans != INF else --1",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else --1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [1, 0, -2, 0]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -2, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [1, 0, -0, 0]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -0, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [1, 0, -0, 0]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -0, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dx = [1, 0, -1, 0]",
      "mutated_line": "dx = [1, 0, --1, 0]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, --1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [0, 1, 0, -2]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -2]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [0, 1, 0, -0]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -0]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [0, 1, 0, -0]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -0]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dy = [0, 1, 0, -1]",
      "mutated_line": "dy = [0, 1, 0, --1]",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, --1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for dir in range(4):",
      "mutated_line": "for dir in range(5):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(5):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for dir in range(4):",
      "mutated_line": "for dir in range(3):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(3):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for dir in range(4):",
      "mutated_line": "for dir in range(0):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(0):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for dir in range(4):",
      "mutated_line": "for dir in range(1):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(1):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for dir in range(4):",
      "mutated_line": "for dir in range(-4):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(-4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(2, K + 1):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(2, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(0, K + 1):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(0, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(0, K + 1):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(0, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(-1, K + 1):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(-1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K - 1):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K - 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K * 1):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K * 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nh = h + dx[dir] * k",
      "mutated_line": "nh = h - dx[dir] * k",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h - dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nh = h + dx[dir] * k",
      "mutated_line": "nh = h * (dx[dir] * k)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h * (dx[dir] * k)\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "nw = w + dy[dir] * k",
      "mutated_line": "nw = w - dy[dir] * k",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w - dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "nw = w + dy[dir] * k",
      "mutated_line": "nw = w * (dy[dir] * k)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w * (dy[dir] * k)\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 0 and nh >= H and (nw < 0) and (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 and nh >= H and (nw < 0) and (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if G[nh][nw] == '@':",
      "mutated_line": "if G[nh][nw] != '@':",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] != '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if dist[nh][nw] <= dist[h][w]:",
      "mutated_line": "if dist[nh][nw] < dist[h][w]:",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] < dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if dist[nh][nw] <= dist[h][w]:",
      "mutated_line": "if dist[nh][nw] > dist[h][w]:",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] > dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if dist[nh][nw] <= dist[h][w]:",
      "mutated_line": "if dist[nh][nw] == dist[h][w]:",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] == dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if dist[nh][nw] == dist[h][w] + 1:",
      "mutated_line": "if dist[nh][nw] != dist[h][w] + 1:",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] != dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dist[nh][nw] = dist[h][w] + 1",
      "mutated_line": "dist[nh][nw] = dist[h][w] - 1",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] - 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dist[nh][nw] = dist[h][w] + 1",
      "mutated_line": "dist[nh][nw] = dist[h][w] * 1",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] * 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K + 2):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 2):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K + 0):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 0):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K + 0):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 0):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for k in range(1, K + 1):",
      "mutated_line": "for k in range(1, K + -1):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + -1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nh = h + dx[dir] * k",
      "mutated_line": "nh = h + dx[dir] / k",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] / k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nh = h + dx[dir] * k",
      "mutated_line": "nh = h + (dx[dir] + k)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + (dx[dir] + k)\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "nh = h + dx[dir] * k",
      "mutated_line": "nh = h + dx[dir] ** k",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] ** k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "nw = w + dy[dir] * k",
      "mutated_line": "nw = w + dy[dir] / k",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] / k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "nw = w + dy[dir] * k",
      "mutated_line": "nw = w + (dy[dir] + k)",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + (dy[dir] + k)\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "nw = w + dy[dir] * k",
      "mutated_line": "nw = w + dy[dir] ** k",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] ** k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh <= 0 or nh >= H or nw < 0 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh <= 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh >= 0 or nh >= H or nw < 0 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh >= 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh != 0 or nh >= H or nw < 0 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh != 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 0 or nh > H or nw < 0 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh > H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 0 or nh < H or nw < 0 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh < H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 0 or nh == H or nw < 0 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh == H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 0 or nh >= H or nw <= 0 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw <= 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 0 or nh >= H or nw >= 0 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw >= 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 0 or nh >= H or nw != 0 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw != 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 0 or nh >= H or nw < 0 or (nw > W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw > W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 0 or nh >= H or nw < 0 or (nw < W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw < W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 0 or nh >= H or nw < 0 or (nw == W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw == W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if G[nh][nw] == '@':",
      "mutated_line": "if G[nh][nw] == '':",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if dist[nh][nw] == dist[h][w] + 1:",
      "mutated_line": "if dist[nh][nw] == dist[h][w] - 1:",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] - 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if dist[nh][nw] == dist[h][w] + 1:",
      "mutated_line": "if dist[nh][nw] == dist[h][w] * 1:",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] * 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[nh][nw] = dist[h][w] + 1",
      "mutated_line": "dist[nh][nw] = dist[h][w] + 2",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 2\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[nh][nw] = dist[h][w] + 1",
      "mutated_line": "dist[nh][nw] = dist[h][w] + 0",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 0\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[nh][nw] = dist[h][w] + 1",
      "mutated_line": "dist[nh][nw] = dist[h][w] + 0",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 0\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[nh][nw] = dist[h][w] + 1",
      "mutated_line": "dist[nh][nw] = dist[h][w] + -1",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + -1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 1 or nh >= H or nw < 0 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 1 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < -1 or nh >= H or nw < 0 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < -1 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 1 or nh >= H or nw < 0 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 1 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 0 or nh >= H or nw < 1 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 1 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 0 or nh >= H or nw < -1 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < -1 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if nh < 0 or nh >= H or nw < 0 or nw >= W:",
      "mutated_line": "if nh < 0 or nh >= H or nw < 1 or (nw >= W):",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 1 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if dist[nh][nw] == dist[h][w] + 1:",
      "mutated_line": "if dist[nh][nw] == dist[h][w] + 2:",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 2:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if dist[nh][nw] == dist[h][w] + 1:",
      "mutated_line": "if dist[nh][nw] == dist[h][w] + 0:",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 0:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if dist[nh][nw] == dist[h][w] + 1:",
      "mutated_line": "if dist[nh][nw] == dist[h][w] + 0:",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + 0:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if dist[nh][nw] == dist[h][w] + 1:",
      "mutated_line": "if dist[nh][nw] == dist[h][w] + -1:",
      "code": "from collections import deque\n\ndef minimum_strokes(H, W, K, x1, y1, x2, y2, grid):\n    INF = float('inf')\n    (sx, sy) = (x1 - 1, y1 - 1)\n    (gx, gy) = (x2 - 1, y2 - 1)\n\n    def mbfs(G, sh, sw, H, W):\n        dist = [[INF] * W for _ in range(H)]\n        dist[sh][sw] = 0\n        d = deque()\n        d.append([sh, sw])\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        while d:\n            (h, w) = d.popleft()\n            for dir in range(4):\n                for k in range(1, K + 1):\n                    nh = h + dx[dir] * k\n                    nw = w + dy[dir] * k\n                    if nh < 0 or nh >= H or nw < 0 or (nw >= W):\n                        break\n                    if G[nh][nw] == '@':\n                        break\n                    if dist[nh][nw] <= dist[h][w]:\n                        break\n                    if dist[nh][nw] == dist[h][w] + -1:\n                        continue\n                    dist[nh][nw] = dist[h][w] + 1\n                    d.append([nh, nw])\n        return dist\n    dist = mbfs(grid, sx, sy, H, W)\n    ans = dist[gx][gy]\n    return ans if ans != INF else -1"
    }
  ]
}