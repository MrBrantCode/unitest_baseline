{
  "task_id": "taco_15439",
  "entry_point": "calculate_minimum_fare",
  "mutant_count": 69,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "costs = [None] * n",
      "mutated_line": "costs = [None] / n",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] / n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "costs = [None] * n",
      "mutated_line": "costs = [None] + n",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] + n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "costs = [None] * n",
      "mutated_line": "costs = [None] ** n",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] ** n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "used = [False] * n",
      "mutated_line": "used = [False] / n",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] / n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "used = [False] * n",
      "mutated_line": "used = [False] + n",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] + n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "used = [False] * n",
      "mutated_line": "used = [False] ** n",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] ** n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "used[0] = True",
      "mutated_line": "used[0] = False",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = False\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "costs[0] = 0",
      "mutated_line": "costs[0] = 1",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 1\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "costs[0] = 0",
      "mutated_line": "costs[0] = -1",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = -1\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "costs[0] = 0",
      "mutated_line": "costs[0] = 1",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 1\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "while loop and temp:",
      "mutated_line": "while loop or temp:",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop or temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "loop -= 1",
      "mutated_line": "loop += 1",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop += 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "used[0] = True",
      "mutated_line": "used[1] = True",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[1] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "used[0] = True",
      "mutated_line": "used[-1] = True",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[-1] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "used[0] = True",
      "mutated_line": "used[1] = True",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[1] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "costs[0] = 0",
      "mutated_line": "costs[1] = 0",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[1] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "costs[0] = 0",
      "mutated_line": "costs[-1] = 0",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[-1] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "costs[0] = 0",
      "mutated_line": "costs[1] = 0",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[1] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "edges[a - 1].append(b - 1)",
      "mutated_line": "edges[a - 1].append(b + 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b + 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "edges[a - 1].append(b - 1)",
      "mutated_line": "edges[a - 1].append(b * 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b * 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edges[b - 1].append(a - 1)",
      "mutated_line": "edges[b - 1].append(a + 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a + 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edges[b - 1].append(a - 1)",
      "mutated_line": "edges[b - 1].append(a * 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a * 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "used = [False] * n",
      "mutated_line": "used = [True] * n",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [True] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ret = ret | temp",
      "mutated_line": "ret = ret & temp",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret & temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ret = ret | temp",
      "mutated_line": "ret = ret ^ temp",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret ^ temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = new - ret",
      "mutated_line": "temp = new + ret",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new + ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "temp = new - ret",
      "mutated_line": "temp = new * ret",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new * ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "loop -= 1",
      "mutated_line": "loop -= 2",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 2\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "loop -= 1",
      "mutated_line": "loop -= 0",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 0\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "loop -= 1",
      "mutated_line": "loop -= 0",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 0\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "loop -= 1",
      "mutated_line": "loop -= -1",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= -1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "que = [(taxi_fares[0], 0)]",
      "mutated_line": "que = [(taxi_fares[0], 1)]",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 1)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "que = [(taxi_fares[0], 0)]",
      "mutated_line": "que = [(taxi_fares[0], -1)]",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], -1)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "que = [(taxi_fares[0], 0)]",
      "mutated_line": "que = [(taxi_fares[0], 1)]",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 1)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if num == n - 1:",
      "mutated_line": "if num != n - 1:",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num != n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append(b - 1)",
      "mutated_line": "edges[a - 1].append(b - 2)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 2)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append(b - 1)",
      "mutated_line": "edges[a - 1].append(b - 0)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 0)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append(b - 1)",
      "mutated_line": "edges[a - 1].append(b - 0)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 0)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append(b - 1)",
      "mutated_line": "edges[a - 1].append(b - -1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - -1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append(a - 1)",
      "mutated_line": "edges[b - 1].append(a - 2)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 2)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append(a - 1)",
      "mutated_line": "edges[b - 1].append(a - 0)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 0)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append(a - 1)",
      "mutated_line": "edges[b - 1].append(a - 0)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 0)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append(a - 1)",
      "mutated_line": "edges[b - 1].append(a - -1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - -1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "new = new | pto",
      "mutated_line": "new = new & pto",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new & pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "new = new | pto",
      "mutated_line": "new = new ^ pto",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new ^ pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "que = [(taxi_fares[0], 0)]",
      "mutated_line": "que = [(taxi_fares[1], 0)]",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[1], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "que = [(taxi_fares[0], 0)]",
      "mutated_line": "que = [(taxi_fares[-1], 0)]",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[-1], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "que = [(taxi_fares[0], 0)]",
      "mutated_line": "que = [(taxi_fares[1], 0)]",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[1], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if num == n - 1:",
      "mutated_line": "if num == n + 1:",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n + 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if num == n - 1:",
      "mutated_line": "if num == n * 1:",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n * 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "used[num] = True",
      "mutated_line": "used[num] = False",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = False\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "edges[a - 1].append(b - 1)",
      "mutated_line": "edges[a + 1].append(b - 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a + 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "edges[a - 1].append(b - 1)",
      "mutated_line": "edges[a * 1].append(b - 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a * 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edges[b - 1].append(a - 1)",
      "mutated_line": "edges[b + 1].append(a - 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b + 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edges[b - 1].append(a - 1)",
      "mutated_line": "edges[b * 1].append(a - 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b * 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if num == n - 1:",
      "mutated_line": "if num == n - 2:",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 2:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if num == n - 1:",
      "mutated_line": "if num == n - 0:",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 0:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if num == n - 1:",
      "mutated_line": "if num == n - 0:",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 0:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if num == n - 1:",
      "mutated_line": "if num == n - -1:",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - -1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append(b - 1)",
      "mutated_line": "edges[a - 2].append(b - 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 2].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append(b - 1)",
      "mutated_line": "edges[a - 0].append(b - 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 0].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append(b - 1)",
      "mutated_line": "edges[a - 0].append(b - 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 0].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append(b - 1)",
      "mutated_line": "edges[a - -1].append(b - 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - -1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append(a - 1)",
      "mutated_line": "edges[b - 2].append(a - 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 2].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append(a - 1)",
      "mutated_line": "edges[b - 0].append(a - 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 0].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append(a - 1)",
      "mutated_line": "edges[b - 0].append(a - 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 0].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append(a - 1)",
      "mutated_line": "edges[b - -1].append(a - 1)",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - -1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost + taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "push(que, (next_cost + taxi_fares[num], num))",
      "mutated_line": "push(que, (next_cost - taxi_fares[num], num))",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost - taxi_fares[num], num))\n                used[num] = True\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "push(que, (next_cost + taxi_fares[num], num))",
      "mutated_line": "push(que, (next_cost * taxi_fares[num], num))",
      "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef calculate_minimum_fare(n, k, taxi_fares, max_roads, roads):\n    edges = [[] for _ in range(n)]\n    for (a, b) in roads:\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    costs = [None] * n\n    used = [False] * n\n\n    def make_to_lst(s_num):\n        loop = max_roads[s_num]\n        temp = set(edges[s_num])\n        ret = set()\n        while loop and temp:\n            new = set()\n            for p in temp:\n                pto = set(edges[p])\n                new = new | pto\n            ret = ret | temp\n            temp = new - ret\n            loop -= 1\n        return ret\n    used[0] = True\n    costs[0] = 0\n    que = [(taxi_fares[0], 0)]\n    while que:\n        (next_cost, s_num) = pop(que)\n        to_lst = make_to_lst(s_num)\n        for num in to_lst:\n            if num == n - 1:\n                return next_cost\n            costs[num] = next_cost\n            if not used[num]:\n                push(que, (next_cost * taxi_fares[num], num))\n                used[num] = True\n    return None"
    }
  ]
}