{
  "task_id": "taco_6418",
  "entry_point": "calculate_expected_colorfulness",
  "mutant_count": 183,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 1\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = -1\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 1\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if s < 0:",
      "mutated_line": "if s <= 0:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s <= 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if s < 0:",
      "mutated_line": "if s >= 0:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s >= 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if s < 0:",
      "mutated_line": "if s != 0:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s != 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if s == 0:",
      "mutated_line": "if s != 0:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s != 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i == N:",
      "mutated_line": "if i != N:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i != N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if i == x or i == y:",
      "mutated_line": "if i == x and i == y:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x and i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if (i, s, x, y, cnt) in Mem:",
      "mutated_line": "if (i, s, x, y, cnt) not in Mem:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) not in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) - Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) - Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) * Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) * Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "F = [1, 1]",
      "mutated_line": "F = [2, 1]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [2, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "F = [1, 1]",
      "mutated_line": "F = [0, 1]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [0, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "F = [1, 1]",
      "mutated_line": "F = [0, 1]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [0, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "F = [1, 1]",
      "mutated_line": "F = [-1, 1]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [-1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "F = [1, 1]",
      "mutated_line": "F = [1, 2]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 2]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "F = [1, 1]",
      "mutated_line": "F = [1, 0]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 0]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "F = [1, 1]",
      "mutated_line": "F = [1, 0]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 0]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "F = [1, 1]",
      "mutated_line": "F = [1, -1]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, -1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2, 21):",
      "mutated_line": "for i in range(3, 21):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(3, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2, 21):",
      "mutated_line": "for i in range(1, 21):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(1, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2, 21):",
      "mutated_line": "for i in range(0, 21):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(0, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2, 21):",
      "mutated_line": "for i in range(1, 21):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(1, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2, 21):",
      "mutated_line": "for i in range(-2, 21):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(-2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2, 21):",
      "mutated_line": "for i in range(2, 22):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 22):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2, 21):",
      "mutated_line": "for i in range(2, 20):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 20):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2, 21):",
      "mutated_line": "for i in range(2, 0):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 0):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2, 21):",
      "mutated_line": "for i in range(2, 1):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 1):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2, 21):",
      "mutated_line": "for i in range(2, -21):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, -21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if A[i] > k:",
      "mutated_line": "if A[i] >= k:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] >= k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if A[i] > k:",
      "mutated_line": "if A[i] <= k:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] <= k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if A[i] > k:",
      "mutated_line": "if A[i] != k:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] != k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "ans += A[i] - k",
      "mutated_line": "ans -= A[i] - k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans -= A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if s < 0:",
      "mutated_line": "if s < 1:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 1:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if s < 0:",
      "mutated_line": "if s < -1:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < -1:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if s < 0:",
      "mutated_line": "if s < 1:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 1:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 1\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return -1\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 1\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if s == 0:",
      "mutated_line": "if s == 1:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 1:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if s == 0:",
      "mutated_line": "if s == -1:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == -1:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if s == 0:",
      "mutated_line": "if s == 1:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 1:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - 2] / (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] / (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - 2] + (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] + (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return (F[cnt] * 2 * F[N - cnt - 2]) ** (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return (F[cnt] * 2 * F[N - cnt - 2]) ** (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 1\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return -1\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 1\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if i == x or i == y:",
      "mutated_line": "if i != x or i == y:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i != x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if i == x or i == y:",
      "mutated_line": "if i == x or i != y:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i != y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "F.append(F[-1] * i)",
      "mutated_line": "F.append(F[-1] / i)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] / i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "F.append(F[-1] * i)",
      "mutated_line": "F.append(F[-1] + i)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] + i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "F.append(F[-1] * i)",
      "mutated_line": "F.append(F[-1] ** i)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] ** i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "A = [block[0] for block in blocks]",
      "mutated_line": "A = [block[1] for block in blocks]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[1] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "A = [block[0] for block in blocks]",
      "mutated_line": "A = [block[-1] for block in blocks]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[-1] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "A = [block[0] for block in blocks]",
      "mutated_line": "A = [block[1] for block in blocks]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[1] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "C = [block[1] for block in blocks]",
      "mutated_line": "C = [block[2] for block in blocks]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[2] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "C = [block[1] for block in blocks]",
      "mutated_line": "C = [block[0] for block in blocks]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[0] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "C = [block[1] for block in blocks]",
      "mutated_line": "C = [block[0] for block in blocks]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[0] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "C = [block[1] for block in blocks]",
      "mutated_line": "C = [block[-1] for block in blocks]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[-1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans += A[i] - k",
      "mutated_line": "ans += A[i] + k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] + k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans += A[i] - k",
      "mutated_line": "ans += A[i] * k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] * k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i - 1, N):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i - 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i * 1, N):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i * 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if C[i] == C[j]:",
      "mutated_line": "if C[i] != C[j]:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] != C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "x = p[0]",
      "mutated_line": "x = p[1]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[1]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "x = p[0]",
      "mutated_line": "x = p[-1]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[-1]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "x = p[0]",
      "mutated_line": "x = p[1]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[1]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "y = p[1]",
      "mutated_line": "y = p[2]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[2]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "y = p[1]",
      "mutated_line": "y = p[0]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[0]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "y = p[1]",
      "mutated_line": "y = p[0]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[0]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "y = p[1]",
      "mutated_line": "y = p[-1]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[-1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for j in range(0, k):",
      "mutated_line": "for j in range(1, k):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(1, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for j in range(0, k):",
      "mutated_line": "for j in range(-1, k):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(-1, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for j in range(0, k):",
      "mutated_line": "for j in range(1, k):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(1, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "f = Lx + Ly + j - k",
      "mutated_line": "f = Lx + Ly + j + k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j + k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "f = Lx + Ly + j - k",
      "mutated_line": "f = (Lx + Ly + j) * k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = (Lx + Ly + j) * k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if j + Ly > k:",
      "mutated_line": "if j + Ly >= k:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly >= k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if j + Ly > k:",
      "mutated_line": "if j + Ly <= k:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly <= k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if j + Ly > k:",
      "mutated_line": "if j + Ly != k:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly != k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "f -= j + Ly - k",
      "mutated_line": "f += j + Ly - k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f += j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if j + Lx > k:",
      "mutated_line": "if j + Lx >= k:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx >= k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if j + Lx > k:",
      "mutated_line": "if j + Lx <= k:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx <= k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if j + Lx > k:",
      "mutated_line": "if j + Lx != k:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx != k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "f -= j + Lx - k",
      "mutated_line": "f += j + Lx - k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f += j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if f > 0:",
      "mutated_line": "if f >= 0:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f >= 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if f > 0:",
      "mutated_line": "if f <= 0:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f <= 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if f > 0:",
      "mutated_line": "if f != 0:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f != 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 50,
      "original_line": "ans += f * (e / F[N])",
      "mutated_line": "ans -= f * (e / F[N])",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans -= f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 / F[N - cnt - 2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 / F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return (F[cnt] * 2 + F[N - cnt - 2]) * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return (F[cnt] * 2 + F[N - cnt - 2]) * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return (F[cnt] * 2) ** F[N - cnt - 2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return (F[cnt] * 2) ** F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt + 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt + 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - 2] * ((N - cnt) * 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * ((N - cnt) * 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "return Choose(i - 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i - 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "return Choose(i * 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i * 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i - 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i - 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i * 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i * 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s + A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s + A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s * A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s * A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s - A[i], x, y, cnt - 1) + Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt - 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s - A[i], x, y, cnt * 1) + Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt * 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i - 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i - 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i * 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i * 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i + 2, N):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 2, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i + 0, N):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 0, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i + 0, N):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 0, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(i + 1, N):",
      "mutated_line": "for j in range(i + -1, N):",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + -1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "e = Choose(0, j, x, y, 0)",
      "mutated_line": "e = Choose(1, j, x, y, 0)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(1, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "e = Choose(0, j, x, y, 0)",
      "mutated_line": "e = Choose(-1, j, x, y, 0)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(-1, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "e = Choose(0, j, x, y, 0)",
      "mutated_line": "e = Choose(1, j, x, y, 0)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(1, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "e = Choose(0, j, x, y, 0)",
      "mutated_line": "e = Choose(0, j, x, y, 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 1)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "e = Choose(0, j, x, y, 0)",
      "mutated_line": "e = Choose(0, j, x, y, -1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, -1)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "e = Choose(0, j, x, y, 0)",
      "mutated_line": "e = Choose(0, j, x, y, 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 1)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "f = Lx + Ly + j - k",
      "mutated_line": "f = Lx + Ly - j - k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly - j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "f = Lx + Ly + j - k",
      "mutated_line": "f = (Lx + Ly) * j - k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = (Lx + Ly) * j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if j + Ly > k:",
      "mutated_line": "if j - Ly > k:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j - Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if j + Ly > k:",
      "mutated_line": "if j * Ly > k:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j * Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "f -= j + Ly - k",
      "mutated_line": "f -= j + Ly + k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly + k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "f -= j + Ly - k",
      "mutated_line": "f -= (j + Ly) * k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= (j + Ly) * k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if j + Lx > k:",
      "mutated_line": "if j - Lx > k:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j - Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if j + Lx > k:",
      "mutated_line": "if j * Lx > k:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j * Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "f -= j + Lx - k",
      "mutated_line": "f -= j + Lx + k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx + k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "f -= j + Lx - k",
      "mutated_line": "f -= (j + Lx) * k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= (j + Lx) * k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if f > 0:",
      "mutated_line": "if f > 1:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 1:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if f > 0:",
      "mutated_line": "if f > -1:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > -1:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if f > 0:",
      "mutated_line": "if f > 1:",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 1:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ans += f * (e / F[N])",
      "mutated_line": "ans += f / (e / F[N])",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f / (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ans += f * (e / F[N])",
      "mutated_line": "ans += f + e / F[N]",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f + e / F[N]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ans += f * (e / F[N])",
      "mutated_line": "ans += f ** (e / F[N])",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f ** (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] / 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] / 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return (F[cnt] + 2) * F[N - cnt - 2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return (F[cnt] + 2) * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] ** 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] ** 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N + cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N + cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N * cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N * cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 2)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 2)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 0)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 0)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 0)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 0)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - -1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - -1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "return Choose(i + 2, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 2, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "return Choose(i + 0, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 0, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "return Choose(i + 0, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 0, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "return Choose(i + -1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + -1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 2, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 2, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 0, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 0, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 0, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 0, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + -1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + -1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 2) + Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 2) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 0) + Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 0) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 0) + Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 0) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + -1) + Choose(i + 1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + -1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 2, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 2, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 0, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 0, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 0, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 0, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)",
      "mutated_line": "ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + -1, s, x, y, cnt)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + -1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "F.append(F[-1] * i)",
      "mutated_line": "F.append(F[+1] * i)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[+1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "f = Lx + Ly + j - k",
      "mutated_line": "f = Lx - Ly + j - k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx - Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "f = Lx + Ly + j - k",
      "mutated_line": "f = Lx * Ly + j - k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx * Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "f -= j + Ly - k",
      "mutated_line": "f -= j - Ly - k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j - Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "f -= j + Ly - k",
      "mutated_line": "f -= j * Ly - k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j * Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "f -= j + Lx - k",
      "mutated_line": "f -= j - Lx - k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j - Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "f -= j + Lx - k",
      "mutated_line": "f -= j * Lx - k",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j * Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ans += f * (e / F[N])",
      "mutated_line": "ans += f * (e * F[N])",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e * F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ans += f * (e / F[N])",
      "mutated_line": "ans += f * (e // F[N])",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e // F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 3 * F[N - cnt - 2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 3 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 1 * F[N - cnt - 2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 1 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 0 * F[N - cnt - 2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 0 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 1 * F[N - cnt - 2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 1 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * -2 * F[N - cnt - 2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * -2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt + 2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt + 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[(N - cnt) * 2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[(N - cnt) * 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "F.append(F[-1] * i)",
      "mutated_line": "F.append(F[-2] * i)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-2] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "F.append(F[-1] * i)",
      "mutated_line": "F.append(F[-0] * i)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-0] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "F.append(F[-1] * i)",
      "mutated_line": "F.append(F[-0] * i)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-0] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "F.append(F[-1] * i)",
      "mutated_line": "F.append(F[--1] * i)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[--1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N + cnt - 2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N + cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N * cnt - 2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N * cnt - 2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - 3] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 3] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - 1] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 1] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - 0] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 0] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - 1] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - 1] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return F[cnt] * 2 * F[N - cnt - 2] * (N - cnt - 1)",
      "mutated_line": "return F[cnt] * 2 * F[N - cnt - -2] * (N - cnt - 1)",
      "code": "def calculate_expected_colorfulness(n, k, blocks):\n\n    def Choose(i, s, x, y, cnt):\n        if s < 0:\n            return 0\n        if s == 0:\n            return F[cnt] * 2 * F[N - cnt - -2] * (N - cnt - 1)\n        if i == N:\n            return 0\n        if i == x or i == y:\n            return Choose(i + 1, s, x, y, cnt)\n        if (i, s, x, y, cnt) in Mem:\n            return Mem[i, s, x, y, cnt]\n        ans = Choose(i + 1, s - A[i], x, y, cnt + 1) + Choose(i + 1, s, x, y, cnt)\n        Mem[i, s, x, y, cnt] = ans\n        return ans\n    F = [1, 1]\n    for i in range(2, 21):\n        F.append(F[-1] * i)\n    Mem = {}\n    ans = 0\n    N = n\n    A = [block[0] for block in blocks]\n    C = [block[1] for block in blocks]\n    for i in range(N):\n        if A[i] > k:\n            ans += A[i] - k\n    P = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if C[i] == C[j]:\n                P.append((i, j))\n    for p in P:\n        x = p[0]\n        y = p[1]\n        Lx = A[x]\n        Ly = A[y]\n        for j in range(0, k):\n            e = Choose(0, j, x, y, 0)\n            f = Lx + Ly + j - k\n            if j + Ly > k:\n                f -= j + Ly - k\n            if j + Lx > k:\n                f -= j + Lx - k\n            if f > 0:\n                ans += f * (e / F[N])\n    return ans"
    }
  ]
}