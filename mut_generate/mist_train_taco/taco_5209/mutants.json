{
  "task_id": "taco_5209",
  "entry_point": "divisorGenerator",
  "mutant_count": 83,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "Last -= i",
      "mutated_line": "Last += i",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last += i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "k -= 1",
      "mutated_line": "k += 1",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k += 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k ** 2 + k) / 2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) / 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k ** 2 + k) * 2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) * 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if n < kk:",
      "mutated_line": "if n <= kk:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n <= kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if n < kk:",
      "mutated_line": "if n >= kk:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n >= kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if n < kk:",
      "mutated_line": "if n != kk:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n != kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, int(math.sqrt(n) + 1)):",
      "mutated_line": "for i in range(2, int(math.sqrt(n) + 1)):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(2, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, int(math.sqrt(n) + 1)):",
      "mutated_line": "for i in range(0, int(math.sqrt(n) + 1)):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(0, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, int(math.sqrt(n) + 1)):",
      "mutated_line": "for i in range(0, int(math.sqrt(n) + 1)):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(0, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, int(math.sqrt(n) + 1)):",
      "mutated_line": "for i in range(-1, int(math.sqrt(n) + 1)):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(-1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i != 0:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i != 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n * 2):",
      "mutated_line": "for i in range(2, n * 2):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(2, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n * 2):",
      "mutated_line": "for i in range(0, n * 2):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(0, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n * 2):",
      "mutated_line": "for i in range(0, n * 2):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(0, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n * 2):",
      "mutated_line": "for i in range(-1, n * 2):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(-1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(1, n * 2):",
      "mutated_line": "for i in range(1, n / 2):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n / 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(1, n * 2):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n + 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(1, n * 2):",
      "mutated_line": "for i in range(1, n ** 2):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n ** 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if k == 1:",
      "mutated_line": "if k != 1:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k != 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k -= 1",
      "mutated_line": "k -= 2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 2\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 0\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 0\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "k -= 1",
      "mutated_line": "k -= -1",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= -1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k ** 2 - k) // 2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 - k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = k ** 2 * k // 2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = k ** 2 * k // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k ** 2 + k) // 3",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 3\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k ** 2 + k) // 1",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 1\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k ** 2 + k) // 0",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 0\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k ** 2 + k) // 1",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 1\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k ** 2 + k) // -2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // -2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return +1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "oo = n // kk",
      "mutated_line": "oo = n / kk",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n / kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "oo = n // kk",
      "mutated_line": "oo = n * kk",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n * kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pp = 1",
      "mutated_line": "pp = 2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 2\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pp = 1",
      "mutated_line": "pp = 0",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 0\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pp = 1",
      "mutated_line": "pp = 0",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 0\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pp = 1",
      "mutated_line": "pp = -1",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = -1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(1, int(math.sqrt(n) + 1)):",
      "mutated_line": "for i in range(1, int(math.sqrt(n) - 1)):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) - 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(1, int(math.sqrt(n) + 1)):",
      "mutated_line": "for i in range(1, int(math.sqrt(n) * 1)):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) * 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n * i == 0:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n * i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n + i == 0:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n + i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == 1:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 1:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == -1:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == -1:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == 1:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 1:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if i * i != n:",
      "mutated_line": "if i * i == n:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i == n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n * 2):",
      "mutated_line": "for i in range(1, n * 3):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 3):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n * 2):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 1):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n * 2):",
      "mutated_line": "for i in range(1, n * 0):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 0):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n * 2):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 1):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, n * 2):",
      "mutated_line": "for i in range(1, n * -2):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * -2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 2:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 2:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 0:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 0:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if k == 1:",
      "mutated_line": "if k == -1:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == -1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k * 2 + k) // 2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k * 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k + 2 + k) // 2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k + 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -2\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -0\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -0\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return --1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if i <= oo:",
      "mutated_line": "if i < oo:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i < oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if i <= oo:",
      "mutated_line": "if i > oo:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i > oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if i <= oo:",
      "mutated_line": "if i == oo:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i == oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "w = result(n // oo, k)",
      "mutated_line": "w = result(n / oo, k)",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n / oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "w = result(n // oo, k)",
      "mutated_line": "w = result(n * oo, k)",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n * oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return [i * oo for i in w]",
      "mutated_line": "return [i / oo for i in w]",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i / oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return [i * oo for i in w]",
      "mutated_line": "return [i + oo for i in w]",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i + oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return [i * oo for i in w]",
      "mutated_line": "return [i ** oo for i in w]",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i ** oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, int(math.sqrt(n) + 1)):",
      "mutated_line": "for i in range(1, int(math.sqrt(n) + 2)):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 2)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, int(math.sqrt(n) + 1)):",
      "mutated_line": "for i in range(1, int(math.sqrt(n) + 0)):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 0)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, int(math.sqrt(n) + 1)):",
      "mutated_line": "for i in range(1, int(math.sqrt(n) + 0)):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 0)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, int(math.sqrt(n) + 1)):",
      "mutated_line": "for i in range(1, int(math.sqrt(n) + -1)):",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + -1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if i * i != n:",
      "mutated_line": "if i / i != n:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i / i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if i * i != n:",
      "mutated_line": "if i + i != n:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i + i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if i * i != n:",
      "mutated_line": "if i ** i != n:",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i ** i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k ** 3 + k) // 2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 3 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k ** 1 + k) // 2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 1 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k ** 0 + k) // 2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 0 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k ** 1 + k) // 2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 1 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "kk = (k ** 2 + k) // 2",
      "mutated_line": "kk = (k ** -2 + k) // 2",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n // i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** -2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "large_divisors.append(n // i)",
      "mutated_line": "large_divisors.append(n / i)",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n / i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "large_divisors.append(n // i)",
      "mutated_line": "large_divisors.append(n * i)",
      "code": "import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in range(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i * i != n:\n                large_divisors.append(n * i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\ndef result(n, k):\n    Main = []\n    Last = n\n    for i in range(1, n * 2):\n        if k == 1:\n            break\n        Main.append(i)\n        Last -= i\n        k -= 1\n    Main.append(Last)\n    return Main\n\ndef generate_gcd_sequence(n, k):\n    divisors = list(divisorGenerator(n))\n    for i in range(len(divisors)):\n        divisors[i] = int(divisors[i])\n    kk = (k ** 2 + k) // 2\n    if n < kk:\n        return -1\n    else:\n        oo = n // kk\n        pp = 1\n        for i in divisors:\n            if i <= oo:\n                pp = i\n        oo = pp\n        w = result(n // oo, k)\n        return [i * oo for i in w]"
    }
  ]
}