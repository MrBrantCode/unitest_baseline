{
  "task_id": "taco_17798",
  "entry_point": "count_different_strings",
  "mutant_count": 431,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 - 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 * 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if A > B:",
      "mutated_line": "(A, B) = (B, A)",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A >= B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if A > B:",
      "mutated_line": "(A, B) = (B, A)",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A <= B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if A > B:",
      "mutated_line": "(A, B) = (B, A)",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A != B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp_1s = [0] * B",
      "mutated_line": "dp_1s = [0] / B",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] / B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp_1s = [0] * B",
      "mutated_line": "dp_1s = [0] + B",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] + B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp_1s = [0] * B",
      "mutated_line": "dp_1s = [0] ** B",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] ** B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp_0s_edge = [0] * B",
      "mutated_line": "dp_0s_edge = [0] / B",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] / B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp_0s_edge = [0] * B",
      "mutated_line": "dp_0s_edge = [0] + B",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] + B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp_0s_edge = [0] * B",
      "mutated_line": "dp_0s_edge = [0] ** B",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] ** B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return (pow(2, N, MOD) - sum(dp[N])) % MOD",
      "mutated_line": "return (pow(2, N, MOD) - sum(dp[N])) * MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return (pow(2, N, MOD) - sum(dp[N])) % MOD",
      "mutated_line": "return pow(2, N, MOD) - sum(dp[N]) + MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return pow(2, N, MOD) - sum(dp[N]) + MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 * 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 + 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 8\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 6\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 0\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 1\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + -7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for l in range(A + 2, B):",
      "mutated_line": "for l in range(A - 2, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A - 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for l in range(A + 2, B):",
      "mutated_line": "for l in range(A * 2, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A * 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[1][1] = 1",
      "mutated_line": "dp[1][1] = 2",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 2\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[1][1] = 1",
      "mutated_line": "dp[1][1] = 0",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 0\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[1][1] = 1",
      "mutated_line": "dp[1][1] = 0",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 0\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[1][1] = 1",
      "mutated_line": "dp[1][1] = -1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = -1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp_1s[l] = dp[l][1] - 1",
      "mutated_line": "dp_1s[l] = dp[l][1] + 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] + 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "dp_1s[l] = dp[l][1] - 1",
      "mutated_line": "dp_1s[l] = dp[l][1] * 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] * 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A - 1, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A - 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A * 1, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A * 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[A][0] = 1",
      "mutated_line": "dp[A][0] = 2",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 2\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[A][0] = 1",
      "mutated_line": "dp[A][0] = 0",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 0\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[A][0] = 1",
      "mutated_line": "dp[A][0] = 0",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 0\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[A][0] = 1",
      "mutated_line": "dp[A][0] = -1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = -1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[0] = [1, 1]",
      "mutated_line": "dp[1] = [1, 1]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[1] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[0] = [1, 1]",
      "mutated_line": "dp[-1] = [1, 1]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[-1] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[0] = [1, 1]",
      "mutated_line": "dp[1] = [1, 1]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[1] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[0] = [1, 1]",
      "mutated_line": "dp[0] = [2, 1]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [2, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[0] = [1, 1]",
      "mutated_line": "dp[0] = [0, 1]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [0, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[0] = [1, 1]",
      "mutated_line": "dp[0] = [0, 1]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [0, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[0] = [1, 1]",
      "mutated_line": "dp[0] = [-1, 1]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [-1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[0] = [1, 1]",
      "mutated_line": "dp[0] = [1, 2]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 2]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[0] = [1, 1]",
      "mutated_line": "dp[0] = [1, 0]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 0]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[0] = [1, 1]",
      "mutated_line": "dp[0] = [1, 0]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 0]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dp[0] = [1, 1]",
      "mutated_line": "dp[0] = [1, -1]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, -1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A - 1, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A - 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A * 1, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A * 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A - 1, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A - 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A * 1, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A * 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) * MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) * MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = dp[N][0] + dp[N - l][0] * dp_0s_edge[l] + MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = dp[N][0] + dp[N - l][0] * dp_0s_edge[l] + MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return (pow(2, N, MOD) - sum(dp[N])) % MOD",
      "mutated_line": "return (pow(2, N, MOD) + sum(dp[N])) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) + sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return (pow(2, N, MOD) - sum(dp[N])) % MOD",
      "mutated_line": "return pow(2, N, MOD) * sum(dp[N]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return pow(2, N, MOD) * sum(dp[N]) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def count_different_strings(N, A, B):\n    MOD = 11 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def count_different_strings(N, A, B):\n    MOD = 9 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def count_different_strings(N, A, B):\n    MOD = 0 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def count_different_strings(N, A, B):\n    MOD = 1 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def count_different_strings(N, A, B):\n    MOD = -10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 10 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 8 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 0 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 1 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** -9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp_1s = [0] * B",
      "mutated_line": "dp_1s = [1] * B",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [1] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp_1s = [0] * B",
      "mutated_line": "dp_1s = [-1] * B",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [-1] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp_1s = [0] * B",
      "mutated_line": "dp_1s = [1] * B",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [1] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for l in range(A + 2, B):",
      "mutated_line": "for l in range(A + 3, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 3, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for l in range(A + 2, B):",
      "mutated_line": "for l in range(A + 1, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for l in range(A + 2, B):",
      "mutated_line": "for l in range(A + 0, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 0, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for l in range(A + 2, B):",
      "mutated_line": "for l in range(A + 1, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for l in range(A + 2, B):",
      "mutated_line": "for l in range(A + -2, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + -2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[1][1] = 1",
      "mutated_line": "dp[1][2] = 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][2] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[1][1] = 1",
      "mutated_line": "dp[1][0] = 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[1][1] = 1",
      "mutated_line": "dp[1][0] = 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[1][1] = 1",
      "mutated_line": "dp[1][-1] = 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][-1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, l):",
      "mutated_line": "for i in range(2, l):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(2, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, l):",
      "mutated_line": "for i in range(0, l):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(0, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, l):",
      "mutated_line": "for i in range(0, l):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(0, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, l):",
      "mutated_line": "for i in range(-1, l):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(-1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) * MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) * MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = dp[i + 1][0] + dp[i][0] + MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = dp[i + 1][0] + dp[i][0] + MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) * MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) * MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = dp[i + 1][1] + dp[i][0] + dp[i][1] + MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = dp[i + 1][1] + dp[i][0] + dp[i][1] + MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i + A < l:",
      "mutated_line": "if i + A <= l:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A <= l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i + A < l:",
      "mutated_line": "if i + A >= l:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A >= l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i + A < l:",
      "mutated_line": "if i + A != l:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A != l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp_1s[l] = dp[l][1] - 1",
      "mutated_line": "dp_1s[l] = dp[l][1] - 2",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 2\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp_1s[l] = dp[l][1] - 1",
      "mutated_line": "dp_1s[l] = dp[l][1] - 0",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 0\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp_1s[l] = dp[l][1] - 1",
      "mutated_line": "dp_1s[l] = dp[l][1] - 0",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 0\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp_1s[l] = dp[l][1] - 1",
      "mutated_line": "dp_1s[l] = dp[l][1] - -1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - -1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp_0s_edge = [0] * B",
      "mutated_line": "dp_0s_edge = [1] * B",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [1] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp_0s_edge = [0] * B",
      "mutated_line": "dp_0s_edge = [-1] * B",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [-1] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp_0s_edge = [0] * B",
      "mutated_line": "dp_0s_edge = [1] * B",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [1] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A + 2, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A + 0, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 0, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A + 0, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 0, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A + -1, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + -1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[A][0] = 1",
      "mutated_line": "dp[A][1] = 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[A][0] = 1",
      "mutated_line": "dp[A][-1] = 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][-1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dp[A][0] = 1",
      "mutated_line": "dp[A][1] = 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, l):",
      "mutated_line": "for i in range(2, l):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(2, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, l):",
      "mutated_line": "for i in range(0, l):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(0, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, l):",
      "mutated_line": "for i in range(0, l):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(0, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, l):",
      "mutated_line": "for i in range(-1, l):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(-1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) * MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) * MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = dp[i + 1][0] + dp[i][0] + MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = dp[i + 1][0] + dp[i][0] + MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) * MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) * MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = dp[i + 1][1] + dp[i][0] + dp[i][1] + MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = dp[i + 1][1] + dp[i][0] + dp[i][1] + MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if i + A < l:",
      "mutated_line": "if i + A <= l:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A <= l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if i + A < l:",
      "mutated_line": "if i + A >= l:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A >= l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if i + A < l:",
      "mutated_line": "if i + A != l:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A != l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp_0s_edge[l] = dp[l][1]",
      "mutated_line": "dp_0s_edge[l] = dp[l][2]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][2]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp_0s_edge[l] = dp[l][1]",
      "mutated_line": "dp_0s_edge[l] = dp[l][0]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][0]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp_0s_edge[l] = dp[l][1]",
      "mutated_line": "dp_0s_edge[l] = dp[l][0]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][0]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp_0s_edge[l] = dp[l][1]",
      "mutated_line": "dp_0s_edge[l] = dp[l][-1]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][-1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp = [[0, 0] for _ in range(N + 1)]",
      "mutated_line": "dp = [[1, 0] for _ in range(N + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[1, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp = [[0, 0] for _ in range(N + 1)]",
      "mutated_line": "dp = [[-1, 0] for _ in range(N + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[-1, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp = [[0, 0] for _ in range(N + 1)]",
      "mutated_line": "dp = [[1, 0] for _ in range(N + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[1, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp = [[0, 0] for _ in range(N + 1)]",
      "mutated_line": "dp = [[0, 1] for _ in range(N + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 1] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp = [[0, 0] for _ in range(N + 1)]",
      "mutated_line": "dp = [[0, -1] for _ in range(N + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, -1] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp = [[0, 0] for _ in range(N + 1)]",
      "mutated_line": "dp = [[0, 1] for _ in range(N + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 1] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A + 2, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 2, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A + 0, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 0, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A + 0, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 0, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A + -1, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + -1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[l][1] = dp_0s_edge[l]",
      "mutated_line": "dp[l][2] = dp_0s_edge[l]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][2] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[l][1] = dp_0s_edge[l]",
      "mutated_line": "dp[l][0] = dp_0s_edge[l]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][0] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[l][1] = dp_0s_edge[l]",
      "mutated_line": "dp[l][0] = dp_0s_edge[l]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][0] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[l][1] = dp_0s_edge[l]",
      "mutated_line": "dp[l][-1] = dp_0s_edge[l]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][-1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(i + 1, min(N + 1, i + B)):",
      "mutated_line": "for j in range(i - 1, min(N + 1, i + B)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i - 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(i + 1, min(N + 1, i + B)):",
      "mutated_line": "for j in range(i * 1, min(N + 1, i + B)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i * 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][1] = (dp[j][1] + dp[i][0]) * MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) * MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][1] = dp[j][1] + dp[i][0] + MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = dp[j][1] + dp[i][0] + MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for j in range(i + 1, min(N + 1, i + A)):",
      "mutated_line": "for j in range(i - 1, min(N + 1, i + A)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i - 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for j in range(i + 1, min(N + 1, i + A)):",
      "mutated_line": "for j in range(i * 1, min(N + 1, i + A)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i * 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp[j][0] = (dp[j][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[j][0] = (dp[j][0] + dp[i][1]) * MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) * MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp[j][0] = (dp[j][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[j][0] = dp[j][0] + dp[i][1] + MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = dp[j][0] + dp[i][1] + MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for l in range(A + 2, B):",
      "mutated_line": "for l in range(A - 2, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A - 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for l in range(A + 2, B):",
      "mutated_line": "for l in range(A * 2, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A * 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if i + l <= N:",
      "mutated_line": "if i + l < N:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l < N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if i + l <= N:",
      "mutated_line": "if i + l > N:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l > N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if i + l <= N:",
      "mutated_line": "if i + l == N:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l == N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A + 2, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 2, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A + 0, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 0, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A + 0, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 0, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for l in range(A + 1, B):",
      "mutated_line": "for l in range(A + -1, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + -1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][1] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][1] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][-1] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][-1] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][1] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][1] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = (dp[N][0] - dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] - dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = dp[N][0] * (dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = dp[N][0] * (dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[1, 0] for _ in range(l + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[1, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[-1, 0] for _ in range(l + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[-1, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[1, 0] for _ in range(l + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[1, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 1] for _ in range(l + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 1] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, -1] for _ in range(l + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, -1] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 1] for _ in range(l + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 1] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[1][1] = 1",
      "mutated_line": "dp[2][1] = 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[2][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[1][1] = 1",
      "mutated_line": "dp[0][1] = 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[0][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[1][1] = 1",
      "mutated_line": "dp[0][1] = 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[0][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp[1][1] = 1",
      "mutated_line": "dp[-1][1] = 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[-1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][1] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][-1] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][-1] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][1] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][0] - dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] - dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = dp[i + 1][0] * dp[i][0] % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = dp[i + 1][0] * dp[i][0] % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][2] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][2] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][0] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][0] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][-1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][-1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] - dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] - dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0]) * dp[i][1] % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0]) * dp[i][1] % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if i + A < l:",
      "mutated_line": "if i - A < l:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i - A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if i + A < l:",
      "mutated_line": "if i * A < l:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i * A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) * MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) * MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = dp[i + A][0] + dp[i][1] + MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = dp[i + A][0] + dp[i][1] + MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp_1s[l] = dp[l][1] - 1",
      "mutated_line": "dp_1s[l] = dp[l][2] - 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][2] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp_1s[l] = dp[l][1] - 1",
      "mutated_line": "dp_1s[l] = dp[l][0] - 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][0] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp_1s[l] = dp[l][1] - 1",
      "mutated_line": "dp_1s[l] = dp[l][0] - 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][0] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp_1s[l] = dp[l][1] - 1",
      "mutated_line": "dp_1s[l] = dp[l][-1] - 1",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][-1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[1, 0] for _ in range(l + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[1, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[-1, 0] for _ in range(l + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[-1, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[1, 0] for _ in range(l + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[1, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 1] for _ in range(l + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 1] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, -1] for _ in range(l + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, -1] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 1] for _ in range(l + 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 1] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][1] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][-1] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][-1] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][1] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][0] - dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] - dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = dp[i + 1][0] * dp[i][0] % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = dp[i + 1][0] * dp[i][0] % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][2] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][2] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][0] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][0] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][-1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][-1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] - dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] - dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0]) * dp[i][1] % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0]) * dp[i][1] % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i + A < l:",
      "mutated_line": "if i - A < l:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i - A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i + A < l:",
      "mutated_line": "if i * A < l:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i * A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) * MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) * MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = dp[i + A][0] + dp[i][1] + MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = dp[i + A][0] + dp[i][1] + MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp = [[0, 0] for _ in range(N + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(N - 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N - 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp = [[0, 0] for _ in range(N + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(N * 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N * 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, min(N + 1, i + B)):",
      "mutated_line": "for j in range(i + 2, min(N + 1, i + B)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 2, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, min(N + 1, i + B)):",
      "mutated_line": "for j in range(i + 0, min(N + 1, i + B)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 0, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, min(N + 1, i + B)):",
      "mutated_line": "for j in range(i + 0, min(N + 1, i + B)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 0, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, min(N + 1, i + B)):",
      "mutated_line": "for j in range(i + -1, min(N + 1, i + B)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + -1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(i + 1, min(N + 1, i + B)):",
      "mutated_line": "for j in range(i + 1, min(N - 1, i + B)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N - 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(i + 1, min(N + 1, i + B)):",
      "mutated_line": "for j in range(i + 1, min(N * 1, i + B)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N * 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(i + 1, min(N + 1, i + B)):",
      "mutated_line": "for j in range(i + 1, min(N + 1, i - B)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i - B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(i + 1, min(N + 1, i + B)):",
      "mutated_line": "for j in range(i + 1, min(N + 1, i * B)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i * B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][2] = (dp[j][1] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][2] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][0] = (dp[j][1] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][0] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][0] = (dp[j][1] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][0] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][-1] = (dp[j][1] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][-1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][1] = (dp[j][1] - dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] - dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][1] = dp[j][1] * dp[i][0] % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = dp[j][1] * dp[i][0] % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(i + 1, min(N + 1, i + A)):",
      "mutated_line": "for j in range(i + 2, min(N + 1, i + A)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 2, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(i + 1, min(N + 1, i + A)):",
      "mutated_line": "for j in range(i + 0, min(N + 1, i + A)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 0, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(i + 1, min(N + 1, i + A)):",
      "mutated_line": "for j in range(i + 0, min(N + 1, i + A)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 0, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(i + 1, min(N + 1, i + A)):",
      "mutated_line": "for j in range(i + -1, min(N + 1, i + A)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + -1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for j in range(i + 1, min(N + 1, i + A)):",
      "mutated_line": "for j in range(i + 1, min(N - 1, i + A)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N - 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for j in range(i + 1, min(N + 1, i + A)):",
      "mutated_line": "for j in range(i + 1, min(N * 1, i + A)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N * 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for j in range(i + 1, min(N + 1, i + A)):",
      "mutated_line": "for j in range(i + 1, min(N + 1, i - A)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i - A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for j in range(i + 1, min(N + 1, i + A)):",
      "mutated_line": "for j in range(i + 1, min(N + 1, i * A)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i * A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[j][0] = (dp[j][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[j][1] = (dp[j][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][1] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[j][0] = (dp[j][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[j][-1] = (dp[j][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][-1] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[j][0] = (dp[j][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[j][1] = (dp[j][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][1] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp[j][0] = (dp[j][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[j][0] = (dp[j][0] - dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] - dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp[j][0] = (dp[j][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[j][0] = dp[j][0] * dp[i][1] % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = dp[j][0] * dp[i][1] % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for l in range(A + 2, B):",
      "mutated_line": "for l in range(A + 3, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 3, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for l in range(A + 2, B):",
      "mutated_line": "for l in range(A + 1, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 1, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for l in range(A + 2, B):",
      "mutated_line": "for l in range(A + 0, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 0, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for l in range(A + 2, B):",
      "mutated_line": "for l in range(A + 1, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 1, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for l in range(A + 2, B):",
      "mutated_line": "for l in range(A + -2, B):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + -2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if i + l <= N:",
      "mutated_line": "if i - l <= N:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i - l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if i + l <= N:",
      "mutated_line": "if i * l <= N:",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i * l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) * MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) * MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = dp[i + l][1] + dp[i][0] * dp_1s[l] + MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = dp[i + l][1] + dp[i][0] * dp_1s[l] + MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] / dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] / dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = (dp[N][0] + (dp[N - l][0] + dp_0s_edge[l])) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + (dp[N - l][0] + dp_0s_edge[l])) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] ** dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] ** dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return (pow(2, N, MOD) - sum(dp[N])) % MOD",
      "mutated_line": "return (pow(3, N, MOD) - sum(dp[N])) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(3, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return (pow(2, N, MOD) - sum(dp[N])) % MOD",
      "mutated_line": "return (pow(1, N, MOD) - sum(dp[N])) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(1, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return (pow(2, N, MOD) - sum(dp[N])) % MOD",
      "mutated_line": "return (pow(0, N, MOD) - sum(dp[N])) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(0, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return (pow(2, N, MOD) - sum(dp[N])) % MOD",
      "mutated_line": "return (pow(1, N, MOD) - sum(dp[N])) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(1, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return (pow(2, N, MOD) - sum(dp[N])) % MOD",
      "mutated_line": "return (pow(-2, N, MOD) - sum(dp[N])) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(-2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(l - 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l - 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(l * 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l * 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i - 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i - 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i * 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i * 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i - 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i - 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i * 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i * 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] - dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] - dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] * dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] * dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][1] = (dp[i + A][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][1] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][-1] = (dp[i + A][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][-1] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][1] = (dp[i + A][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][1] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][0] - dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] - dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = dp[i + A][0] * dp[i][1] % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = dp[i + A][0] * dp[i][1] % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(l - 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l - 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(l * 1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l * 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i - 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i - 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i * 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i * 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i - 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i - 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i * 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i * 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] - dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] - dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] * dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] * dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][1] = (dp[i + A][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][1] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][-1] = (dp[i + A][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][-1] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][1] = (dp[i + A][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][1] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][0] - dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] - dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = dp[i + A][0] * dp[i][1] % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = dp[i + A][0] * dp[i][1] % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp = [[0, 0] for _ in range(N + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(N + 2)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 2)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp = [[0, 0] for _ in range(N + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(N + 0)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 0)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp = [[0, 0] for _ in range(N + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(N + 0)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 0)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp = [[0, 0] for _ in range(N + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(N + -1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + -1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, min(N + 1, i + B)):",
      "mutated_line": "for j in range(i + 1, min(N + 2, i + B)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 2, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, min(N + 1, i + B)):",
      "mutated_line": "for j in range(i + 1, min(N + 0, i + B)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 0, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, min(N + 1, i + B)):",
      "mutated_line": "for j in range(i + 1, min(N + 0, i + B)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 0, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, min(N + 1, i + B)):",
      "mutated_line": "for j in range(i + 1, min(N + -1, i + B)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + -1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(i + 1, min(N + 1, i + A)):",
      "mutated_line": "for j in range(i + 1, min(N + 2, i + A)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 2, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(i + 1, min(N + 1, i + A)):",
      "mutated_line": "for j in range(i + 1, min(N + 0, i + A)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 0, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(i + 1, min(N + 1, i + A)):",
      "mutated_line": "for j in range(i + 1, min(N + 0, i + A)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 0, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(i + 1, min(N + 1, i + A)):",
      "mutated_line": "for j in range(i + 1, min(N + -1, i + A)):",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + -1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][2] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][2] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][0] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][0] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][0] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][0] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][-1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][-1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = (dp[i + l][1] - dp[i][0] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] - dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = dp[i + l][1] * (dp[i][0] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = dp[i + l][1] * (dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = (dp[N][1] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][1] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = (dp[N][-1] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][-1] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = (dp[N][1] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][1] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(l + 2)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 2)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(l + 0)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 0)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(l + 0)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 0)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(l + -1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + -1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 2][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 2][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 0][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 0][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 0][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 0][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + -1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + -1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][1] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][1] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][-1] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][-1] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][1] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][1] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][1]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][-1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][-1]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][1]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 2][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 2][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 0][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 0][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 0][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 0][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + -1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + -1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][2]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][2]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][0]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][0]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][-1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][-1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i - A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i - A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i * A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i * A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(l + 2)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 2)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(l + 0)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 0)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(l + 0)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 0)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[0, 0] for _ in range(l + 1)]",
      "mutated_line": "dp = [[0, 0] for _ in range(l + -1)]",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + -1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 2][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 2][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 0][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 0][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 0][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 0][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + -1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + -1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][1] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][1] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][-1] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][-1] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][1] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][1] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][1]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][-1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][-1]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][1]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 2][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 2][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 0][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 0][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 0][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 0][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + -1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + -1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][2]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][2]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][0]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][0]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][-1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][-1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i - A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i - A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i * A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i * A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][1] = (dp[j][2] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][2] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][1] = (dp[j][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][0] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][1] = (dp[j][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][0] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][1] = (dp[j][-1] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][-1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][1] = (dp[j][1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][1]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][1] = (dp[j][1] + dp[i][-1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][-1]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[j][1] = (dp[j][1] + dp[i][0]) % MOD",
      "mutated_line": "dp[j][1] = (dp[j][1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][1]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[j][0] = (dp[j][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[j][0] = (dp[j][1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][1] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[j][0] = (dp[j][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[j][0] = (dp[j][-1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][-1] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[j][0] = (dp[j][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[j][0] = (dp[j][1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][1] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[j][0] = (dp[j][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[j][0] = (dp[j][0] + dp[i][2]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][2]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[j][0] = (dp[j][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[j][0] = (dp[j][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][0]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[j][0] = (dp[j][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[j][0] = (dp[j][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][0]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[j][0] = (dp[j][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[j][0] = (dp[j][0] + dp[i][-1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][-1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i - l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i - l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i * l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i * l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] / dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] / dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = (dp[i + l][1] + (dp[i][0] + dp_1s[l])) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + (dp[i][0] + dp_1s[l])) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] ** dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] ** dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = (dp[N][0] + dp[N - l][1] * dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][1] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = (dp[N][0] + dp[N - l][-1] * dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][-1] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = (dp[N][0] + dp[N - l][1] * dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][1] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i - 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i - 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i * 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i * 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][2] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][2] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][0] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][0] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][0] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][0] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][-1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][-1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][1] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][-1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][-1] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][1] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][1] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][-1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][-1] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][1] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][2]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][2]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][0]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][0]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][-1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][-1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i - 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i - 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i * 1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i * 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][2] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][2] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][0] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][0] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][0] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][0] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][-1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][-1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][1] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][-1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][-1] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][1] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][1] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][-1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][-1] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][1] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][1] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][2]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][2]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][0]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][0]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][-1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][-1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = (dp[i + l][2] + dp[i][0] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][2] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = (dp[i + l][0] + dp[i][0] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][0] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = (dp[i + l][0] + dp[i][0] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][0] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = (dp[i + l][-1] + dp[i][0] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][-1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = (dp[N][0] + dp[N + l][0] * dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N + l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD",
      "mutated_line": "dp[N][0] = (dp[N][0] + dp[N * l][0] * dp_0s_edge[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N * l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 2][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 2][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 0][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 0][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 0][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 0][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + -1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + -1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i - 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i - 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i * 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i * 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i - A][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i - A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i * A][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i * A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 2][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 2][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 0][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 0][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + 0][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 0][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD",
      "mutated_line": "dp[i + 1][0] = (dp[i + -1][0] + dp[i][0]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + -1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i - 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i - 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i * 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i * 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i - A][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i - A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + A][0] = (dp[i * A][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i * A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = (dp[i - l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i - l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = (dp[i * l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i * l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][1] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][1] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][-1] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][-1] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD",
      "mutated_line": "dp[i + l][1] = (dp[i + l][1] + dp[i][1] * dp_1s[l]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][1] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 2][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 2][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 0][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 0][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 0][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 0][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + -1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + -1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 2][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 2][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 0][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 0][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + 0][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 0][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD",
      "mutated_line": "dp[i + 1][1] = (dp[i + -1][1] + dp[i][0] + dp[i][1]) % MOD",
      "code": "def count_different_strings(N, A, B):\n    MOD = 10 ** 9 + 7\n    if A > B:\n        (A, B) = (B, A)\n    dp_1s = [0] * B\n    for l in range(A + 2, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[1][1] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + 1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_1s[l] = dp[l][1] - 1\n    dp_0s_edge = [0] * B\n    for l in range(A + 1, B):\n        dp = [[0, 0] for _ in range(l + 1)]\n        dp[A][0] = 1\n        for i in range(1, l):\n            dp[i + 1][0] = (dp[i + 1][0] + dp[i][0]) % MOD\n            dp[i + 1][1] = (dp[i + -1][1] + dp[i][0] + dp[i][1]) % MOD\n            if i + A < l:\n                dp[i + A][0] = (dp[i + A][0] + dp[i][1]) % MOD\n        dp_0s_edge[l] = dp[l][1]\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0] = [1, 1]\n    for l in range(A + 1, B):\n        dp[l][1] = dp_0s_edge[l]\n    for i in range(N):\n        for j in range(i + 1, min(N + 1, i + B)):\n            dp[j][1] = (dp[j][1] + dp[i][0]) % MOD\n        for j in range(i + 1, min(N + 1, i + A)):\n            dp[j][0] = (dp[j][0] + dp[i][1]) % MOD\n        for l in range(A + 2, B):\n            if i + l <= N:\n                dp[i + l][1] = (dp[i + l][1] + dp[i][0] * dp_1s[l]) % MOD\n    for l in range(A + 1, B):\n        dp[N][0] = (dp[N][0] + dp[N - l][0] * dp_0s_edge[l]) % MOD\n    return (pow(2, N, MOD) - sum(dp[N])) % MOD"
    }
  ]
}