{
  "task_id": "taco_13516",
  "entry_point": "calculate_snuke_win_probability",
  "mutant_count": 128,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "S = 0",
      "mutated_line": "S = 1",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 1\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "S = 0",
      "mutated_line": "S = -1",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = -1\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "S = 0",
      "mutated_line": "S = 1",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 1\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "YY = [0] * (N + 1)",
      "mutated_line": "YY = [0] / (N + 1)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] / (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "YY = [0] * (N + 1)",
      "mutated_line": "YY = [0] + (N + 1)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] + (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "YY = [0] * (N + 1)",
      "mutated_line": "YY = [0] ** (N + 1)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] ** (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if b > a:",
      "mutated_line": "if b >= a:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b >= a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if b > a:",
      "mutated_line": "if b <= a:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b <= a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if b > a:",
      "mutated_line": "if b != a:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b != a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "S += b - a",
      "mutated_line": "S -= b - a",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S -= b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "YY = [0] * (N + 1)",
      "mutated_line": "YY = [0] * (N - 1)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N - 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "YY = [0] * (N + 1)",
      "mutated_line": "YY = [0] * (N * 1)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N * 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "YY[i + 1] = YY[i] + Y[i][0]",
      "mutated_line": "YY[i + 1] = YY[i] - Y[i][0]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] - Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "YY[i + 1] = YY[i] + Y[i][0]",
      "mutated_line": "YY[i + 1] = YY[i] * Y[i][0]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] * Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] + (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] + (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return (S - Y[i][0] + Y[i][1]) * (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return (S - Y[i][0] + Y[i][1]) * (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ma1, ma2 = 0, 1",
      "mutated_line": "(ma1, ma2) = (1, 1)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (1, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ma1, ma2 = 0, 1",
      "mutated_line": "(ma1, ma2) = (-1, 1)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (-1, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ma1, ma2 = 0, 1",
      "mutated_line": "(ma1, ma2) = (1, 1)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (1, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ma1, ma2 = 0, 1",
      "mutated_line": "(ma1, ma2) = (0, 2)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 2)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ma1, ma2 = 0, 1",
      "mutated_line": "(ma1, ma2) = (0, 0)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 0)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ma1, ma2 = 0, 1",
      "mutated_line": "(ma1, ma2) = (0, 0)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 0)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ma1, ma2 = 0, 1",
      "mutated_line": "(ma1, ma2) = (0, -1)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, -1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "l = 0",
      "mutated_line": "l = 1",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 1\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "l = 0",
      "mutated_line": "l = -1",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = -1\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "l = 0",
      "mutated_line": "l = 1",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 1\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l >= 1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l >= 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l <= 1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l <= 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l != 1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l != 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "a = l * Y[i][1] + min(f(i, l), Y[i][1])",
      "mutated_line": "a = l * Y[i][1] - min(f(i, l), Y[i][1])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] - min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "a = l * Y[i][1] + min(f(i, l), Y[i][1])",
      "mutated_line": "a = l * Y[i][1] * min(f(i, l), Y[i][1])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] * min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "b = N * Y[i][1]",
      "mutated_line": "b = N / Y[i][1]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N / Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "b = N * Y[i][1]",
      "mutated_line": "b = N + Y[i][1]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N + Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "b = N * Y[i][1]",
      "mutated_line": "b = N ** Y[i][1]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N ** Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if a * ma2 > b * ma1:",
      "mutated_line": "if a * ma2 >= b * ma1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 >= b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if a * ma2 > b * ma1:",
      "mutated_line": "if a * ma2 <= b * ma1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 <= b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if a * ma2 > b * ma1:",
      "mutated_line": "if a * ma2 != b * ma1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 != b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return (ma1 // g, ma2 // g)",
      "mutated_line": "return (ma1 / g, ma2 // g)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 / g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return (ma1 // g, ma2 // g)",
      "mutated_line": "return (ma1 * g, ma2 // g)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 * g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return (ma1 // g, ma2 // g)",
      "mutated_line": "return (ma1 // g, ma2 / g)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 / g)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return (ma1 // g, ma2 // g)",
      "mutated_line": "return (ma1 // g, ma2 * g)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 * g)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "S += b - a",
      "mutated_line": "S += b + a",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b + a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "S += b - a",
      "mutated_line": "S += b * a",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b * a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "YY = [0] * (N + 1)",
      "mutated_line": "YY = [1] * (N + 1)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [1] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "YY = [0] * (N + 1)",
      "mutated_line": "YY = [-1] * (N + 1)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [-1] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "YY = [0] * (N + 1)",
      "mutated_line": "YY = [1] * (N + 1)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [1] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "YY = [0] * (N + 1)",
      "mutated_line": "YY = [0] * (N + 2)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 2)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "YY = [0] * (N + 1)",
      "mutated_line": "YY = [0] * (N + 0)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 0)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "YY = [0] * (N + 1)",
      "mutated_line": "YY = [0] * (N + 0)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 0)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "YY = [0] * (N + 1)",
      "mutated_line": "YY = [0] * (N + -1)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + -1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "YY[i + 1] = YY[i] + Y[i][0]",
      "mutated_line": "YY[i - 1] = YY[i] + Y[i][0]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i - 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "YY[i + 1] = YY[i] + Y[i][0]",
      "mutated_line": "YY[i * 1] = YY[i] + Y[i][0]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i * 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] - Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] - Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return (S - Y[i][0]) * Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return (S - Y[i][0]) * Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r + l > 1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r + l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r * l > 1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r * l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 2:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 2:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 0:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 0:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > 0:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 0:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "while r - l > 1:",
      "mutated_line": "while r - l > -1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > -1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) / 2",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) / 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) * 2",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) * 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if f(i, m) >= 0:",
      "mutated_line": "if f(i, m) > 0:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) > 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if f(i, m) >= 0:",
      "mutated_line": "if f(i, m) < 0:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) < 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if f(i, m) >= 0:",
      "mutated_line": "if f(i, m) == 0:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) == 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "a = l * Y[i][1] + min(f(i, l), Y[i][1])",
      "mutated_line": "a = l / Y[i][1] + min(f(i, l), Y[i][1])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l / Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "a = l * Y[i][1] + min(f(i, l), Y[i][1])",
      "mutated_line": "a = l + Y[i][1] + min(f(i, l), Y[i][1])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l + Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "a = l * Y[i][1] + min(f(i, l), Y[i][1])",
      "mutated_line": "a = l ** Y[i][1] + min(f(i, l), Y[i][1])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l ** Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if a * ma2 > b * ma1:",
      "mutated_line": "if a / ma2 > b * ma1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a / ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if a * ma2 > b * ma1:",
      "mutated_line": "if a + ma2 > b * ma1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a + ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if a * ma2 > b * ma1:",
      "mutated_line": "if a ** ma2 > b * ma1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a ** ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if a * ma2 > b * ma1:",
      "mutated_line": "if a * ma2 > b / ma1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b / ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if a * ma2 > b * ma1:",
      "mutated_line": "if a * ma2 > b + ma1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b + ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if a * ma2 > b * ma1:",
      "mutated_line": "if a * ma2 > b ** ma1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b ** ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "a, b = b, a % b",
      "mutated_line": "(a, b) = (b, a * b)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a * b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "a, b = b, a % b",
      "mutated_line": "(a, b) = (b, a + b)",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a + b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "YY[i + 1] = YY[i] + Y[i][0]",
      "mutated_line": "YY[i + 2] = YY[i] + Y[i][0]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 2] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "YY[i + 1] = YY[i] + Y[i][0]",
      "mutated_line": "YY[i + 0] = YY[i] + Y[i][0]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 0] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "YY[i + 1] = YY[i] + Y[i][0]",
      "mutated_line": "YY[i + 0] = YY[i] + Y[i][0]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 0] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "YY[i + 1] = YY[i] + Y[i][0]",
      "mutated_line": "YY[i + -1] = YY[i] + Y[i][0]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + -1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "YY[i + 1] = YY[i] + Y[i][0]",
      "mutated_line": "YY[i + 1] = YY[i] + Y[i][1]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][1]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "YY[i + 1] = YY[i] + Y[i][0]",
      "mutated_line": "YY[i + 1] = YY[i] + Y[i][-1]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][-1]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "YY[i + 1] = YY[i] + Y[i][0]",
      "mutated_line": "YY[i + 1] = YY[i] + Y[i][1]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][1]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S + Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S + Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S * Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S * Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n < i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n < i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n > i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n > i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n == i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n == i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] + Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] + Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] * Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] * Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l - r) // 2",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l - r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = l * r // 2",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = l * r // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 3",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 3\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 1\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 0",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 0\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 1\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // -2",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // -2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if f(i, m) >= 0:",
      "mutated_line": "if f(i, m) >= 1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 1:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if f(i, m) >= 0:",
      "mutated_line": "if f(i, m) >= -1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= -1:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if f(i, m) >= 0:",
      "mutated_line": "if f(i, m) >= 1:",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 1:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b = N * Y[i][1]",
      "mutated_line": "b = N * Y[i][2]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][2]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b = N * Y[i][1]",
      "mutated_line": "b = N * Y[i][0]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][0]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b = N * Y[i][1]",
      "mutated_line": "b = N * Y[i][0]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][0]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "b = N * Y[i][1]",
      "mutated_line": "b = N * Y[i][-1]",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][-1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][2] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][2] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][0] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][0] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][0] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][0] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][-1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][-1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "a = l * Y[i][1] + min(f(i, l), Y[i][1])",
      "mutated_line": "a = l * Y[i][2] + min(f(i, l), Y[i][1])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][2] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "a = l * Y[i][1] + min(f(i, l), Y[i][1])",
      "mutated_line": "a = l * Y[i][0] + min(f(i, l), Y[i][1])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][0] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "a = l * Y[i][1] + min(f(i, l), Y[i][1])",
      "mutated_line": "a = l * Y[i][0] + min(f(i, l), Y[i][1])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][0] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "a = l * Y[i][1] + min(f(i, l), Y[i][1])",
      "mutated_line": "a = l * Y[i][-1] + min(f(i, l), Y[i][1])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][-1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "a = l * Y[i][1] + min(f(i, l), Y[i][1])",
      "mutated_line": "a = l * Y[i][1] + min(f(i, l), Y[i][2])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][2])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "a = l * Y[i][1] + min(f(i, l), Y[i][1])",
      "mutated_line": "a = l * Y[i][1] + min(f(i, l), Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][0])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "a = l * Y[i][1] + min(f(i, l), Y[i][1])",
      "mutated_line": "a = l * Y[i][1] + min(f(i, l), Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][0])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "a = l * Y[i][1] + min(f(i, l), Y[i][1])",
      "mutated_line": "a = l * Y[i][1] + min(f(i, l), Y[i][-1])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][-1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][1] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][1] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][-1] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][-1] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][1] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][1] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n - 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n - 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n * 1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n * 1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][1])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][1])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][-1])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][-1])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][1])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][1])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 2] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 2] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 0] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 0] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 0] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 0] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + 1] - Y[i][0])",
      "mutated_line": "return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + -1] - Y[i][0])",
      "code": "def calculate_snuke_win_probability(N, A, B):\n\n    def gcd(a, b):\n        while b:\n            (a, b) = (b, a % b)\n        return a\n    S = 0\n    Y = []\n    for i in range(N):\n        (a, b) = (A[i], B[i])\n        if b > a:\n            S += b - a\n            Y.append((b, b))\n        else:\n            Y.append((a, b))\n    Y = sorted(Y)\n    YY = [0] * (N + 1)\n    for i in range(N):\n        YY[i + 1] = YY[i] + Y[i][0]\n\n    def f(i, n):\n        return S - Y[i][0] + Y[i][1] - (YY[n] if n <= i else YY[n + -1] - Y[i][0])\n    (ma1, ma2) = (0, 1)\n    for i in range(N):\n        l = 0\n        r = N\n        while r - l > 1:\n            m = (l + r) // 2\n            if f(i, m) >= 0:\n                l = m\n            else:\n                r = m\n        a = l * Y[i][1] + min(f(i, l), Y[i][1])\n        b = N * Y[i][1]\n        if a * ma2 > b * ma1:\n            (ma1, ma2) = (a, b)\n    g = gcd(ma1, ma2)\n    return (ma1 // g, ma2 // g)"
    }
  ]
}