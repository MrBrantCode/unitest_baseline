{
  "task_id": "taco_18797",
  "entry_point": "calculate_min_direction_changes",
  "mutant_count": 168,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ans = float('inf')",
      "mutated_line": "ans = float('')",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for pp in range(2):",
      "mutated_line": "for pp in range(3):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(3):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for pp in range(2):",
      "mutated_line": "for pp in range(1):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(1):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for pp in range(2):",
      "mutated_line": "for pp in range(0):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(0):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for pp in range(2):",
      "mutated_line": "for pp in range(1):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(1):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for pp in range(2):",
      "mutated_line": "for pp in range(-2):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(-2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "lpoz = -1",
      "mutated_line": "lpoz = +1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = +1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sw = 0",
      "mutated_line": "sw = 1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 1\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sw = 0",
      "mutated_line": "sw = -1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = -1\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "sw = 0",
      "mutated_line": "sw = 1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 1\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dir = True",
      "mutated_line": "dir = False",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = False\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if prev == -1:",
      "mutated_line": "if prev != -1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev != -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if ans != -1 and ans > sw:",
      "mutated_line": "if ans != -1 or ans > sw:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 or ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "return ans if ans != float('inf') else -1",
      "mutated_line": "return ans if ans == float('inf') else -1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans == float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "return ans if ans != float('inf') else -1",
      "mutated_line": "return ans if ans != float('inf') else +1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else +1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "lpoz = -1",
      "mutated_line": "lpoz = -2",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -2\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "lpoz = -1",
      "mutated_line": "lpoz = -0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -0\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "lpoz = -1",
      "mutated_line": "lpoz = -0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -0\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "lpoz = -1",
      "mutated_line": "lpoz = --1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = --1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prev = B[0]",
      "mutated_line": "prev = B[1]",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[1]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prev = B[0]",
      "mutated_line": "prev = B[-1]",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[-1]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prev = B[0]",
      "mutated_line": "prev = B[1]",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[1]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "if prev == -1:",
      "mutated_line": "if prev == +1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == +1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "prev = 1",
      "mutated_line": "prev = 2",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 2\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "prev = 1",
      "mutated_line": "prev = 0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 0\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "prev = 1",
      "mutated_line": "prev = 0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 0\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "prev = 1",
      "mutated_line": "prev = -1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = -1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "lpoz = 0",
      "mutated_line": "lpoz = 1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 1\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "lpoz = 0",
      "mutated_line": "lpoz = -1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = -1\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "lpoz = 0",
      "mutated_line": "lpoz = 1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 1\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(2, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(0, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(0, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(-1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if B[i] != -1:",
      "mutated_line": "if B[i] == -1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] == -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if dir and prev == M:",
      "mutated_line": "if dir or prev == M:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir or prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "sw += 1",
      "mutated_line": "sw -= 1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw -= 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != -1 or not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 or not (dir and prev <= B[i] or (not dir and prev >= B[i])):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "sw += 1",
      "mutated_line": "sw -= 1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw -= 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if B[i] != -1:",
      "mutated_line": "if B[i] == -1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] == -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if ans != -1 and ans > sw:",
      "mutated_line": "if ans == -1 and ans > sw:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans == -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if ans != -1 and ans > sw:",
      "mutated_line": "if ans != -1 and ans >= sw:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans >= sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if ans != -1 and ans > sw:",
      "mutated_line": "if ans != -1 and ans <= sw:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans <= sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if ans != -1 and ans > sw:",
      "mutated_line": "if ans != -1 and ans != sw:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans != sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if 1 <= B[i] <= M:",
      "mutated_line": "if 1 < B[i] <= M:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 < B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if 1 <= B[i] <= M:",
      "mutated_line": "if 1 > B[i] <= M:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 > B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if 1 <= B[i] <= M:",
      "mutated_line": "if 1 == B[i] <= M:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 == B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return ans if ans != float('inf') else -1",
      "mutated_line": "return ans if ans != float('inf') else -2",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -2"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return ans if ans != float('inf') else -1",
      "mutated_line": "return ans if ans != float('inf') else -0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return ans if ans != float('inf') else -1",
      "mutated_line": "return ans if ans != float('inf') else -0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return ans if ans != float('inf') else -1",
      "mutated_line": "return ans if ans != float('inf') else --1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else --1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if prev == -1:",
      "mutated_line": "if prev == -2:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -2:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if prev == -1:",
      "mutated_line": "if prev == -0:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -0:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if prev == -1:",
      "mutated_line": "if prev == -0:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -0:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if prev == -1:",
      "mutated_line": "if prev == --1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == --1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "if B[i] != -1:",
      "mutated_line": "if B[i] != +1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != +1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if j != -1:",
      "mutated_line": "if j == -1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j == -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if dir and prev == M:",
      "mutated_line": "if dir and prev != M:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev != M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sw += 1",
      "mutated_line": "sw += 2",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 2\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sw += 1",
      "mutated_line": "sw += 0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 0\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sw += 1",
      "mutated_line": "sw += 0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 0\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sw += 1",
      "mutated_line": "sw += -1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += -1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "elif not dir and prev == 1:",
      "mutated_line": "elif not dir or prev == 1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir or prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "sw += 1",
      "mutated_line": "sw -= 1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw -= 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "prev = prev + 1",
      "mutated_line": "prev = prev - 1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev - 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "prev = prev + 1",
      "mutated_line": "prev = prev * 1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev * 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "prev = prev - 1",
      "mutated_line": "prev = prev + 1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev + 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "prev = prev - 1",
      "mutated_line": "prev = prev * 1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev * 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] == -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] == -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sw += 1",
      "mutated_line": "sw += 2",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 2\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sw += 1",
      "mutated_line": "sw += 0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 0\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sw += 1",
      "mutated_line": "sw += 0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 0\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sw += 1",
      "mutated_line": "sw += -1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += -1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "if B[i] != -1:",
      "mutated_line": "if B[i] != +1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != +1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "if ans != -1 and ans > sw:",
      "mutated_line": "if ans != +1 and ans > sw:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != +1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if 1 <= B[i] <= M:",
      "mutated_line": "if 2 <= B[i] <= M:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 2 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if 1 <= B[i] <= M:",
      "mutated_line": "if 0 <= B[i] <= M:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 0 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if 1 <= B[i] <= M:",
      "mutated_line": "if 0 <= B[i] <= M:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 0 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if 1 <= B[i] <= M:",
      "mutated_line": "if -1 <= B[i] <= M:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if -1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "B[i] = M + 1 - B[i]",
      "mutated_line": "B[i] = M + 1 + B[i]",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 + B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "B[i] = M + 1 - B[i]",
      "mutated_line": "B[i] = (M + 1) * B[i]",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = (M + 1) * B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return ans if ans != float('inf') else -1",
      "mutated_line": "return ans if ans != float('') else -1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if B[i] != -1:",
      "mutated_line": "if B[i] != -2:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -2:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if B[i] != -1:",
      "mutated_line": "if B[i] != -0:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -0:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if B[i] != -1:",
      "mutated_line": "if B[i] != -0:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -0:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if B[i] != -1:",
      "mutated_line": "if B[i] != --1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != --1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "if j != -1:",
      "mutated_line": "if j != +1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != +1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 and abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 and abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif not dir and prev == 1:",
      "mutated_line": "elif not dir and prev != 1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev != 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sw += 1",
      "mutated_line": "sw += 2",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 2\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sw += 1",
      "mutated_line": "sw += 0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 0\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sw += 1",
      "mutated_line": "sw += 0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 0\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sw += 1",
      "mutated_line": "sw += -1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += -1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prev = prev + 1",
      "mutated_line": "prev = prev + 2",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 2\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prev = prev + 1",
      "mutated_line": "prev = prev + 0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 0\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prev = prev + 1",
      "mutated_line": "prev = prev + 0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 0\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prev = prev + 1",
      "mutated_line": "prev = prev + -1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + -1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "prev = prev - 1",
      "mutated_line": "prev = prev - 2",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 2\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "prev = prev - 1",
      "mutated_line": "prev = prev - 0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 0\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "prev = prev - 1",
      "mutated_line": "prev = prev - 0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 0\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "prev = prev - 1",
      "mutated_line": "prev = prev - -1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - -1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != +1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != +1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != -1 and (not ((dir and prev <= B[i]) and (not dir and prev >= B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not ((dir and prev <= B[i]) and (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if B[i] != -1:",
      "mutated_line": "if B[i] != -2:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -2:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if B[i] != -1:",
      "mutated_line": "if B[i] != -0:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -0:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if B[i] != -1:",
      "mutated_line": "if B[i] != -0:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -0:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if B[i] != -1:",
      "mutated_line": "if B[i] != --1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != --1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if ans != -1 and ans > sw:",
      "mutated_line": "if ans != -2 and ans > sw:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -2 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if ans != -1 and ans > sw:",
      "mutated_line": "if ans != -0 and ans > sw:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -0 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if ans != -1 and ans > sw:",
      "mutated_line": "if ans != -0 and ans > sw:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -0 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if ans != -1 and ans > sw:",
      "mutated_line": "if ans != --1 and ans > sw:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != --1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "B[i] = M + 1 - B[i]",
      "mutated_line": "B[i] = M - 1 - B[i]",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M - 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "B[i] = M + 1 - B[i]",
      "mutated_line": "B[i] = M * 1 - B[i]",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M * 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j != -1:",
      "mutated_line": "if j != -2:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -2:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j != -1:",
      "mutated_line": "if j != -0:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -0:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j != -1:",
      "mutated_line": "if j != -0:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -0:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if j != -1:",
      "mutated_line": "if j != --1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != --1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 == abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 == abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) >= abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) >= abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) <= abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) <= abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) != abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) != abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "ans = -1",
      "mutated_line": "ans = +1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = +1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif not dir and prev == 1:",
      "mutated_line": "elif not dir and prev == 2:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 2:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif not dir and prev == 1:",
      "mutated_line": "elif not dir and prev == 0:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 0:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif not dir and prev == 1:",
      "mutated_line": "elif not dir and prev == 0:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 0:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif not dir and prev == 1:",
      "mutated_line": "elif not dir and prev == -1:",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == -1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != -2 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -2 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != -0 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -0 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != -0 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -0 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != --1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != --1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != -1 and (not ((dir or prev <= B[i]) or (not dir and prev >= B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not ((dir or prev <= B[i]) or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != -1 and (not (dir and prev <= B[i] or (not dir or prev >= B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir or prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "B[i] = M + 1 - B[i]",
      "mutated_line": "B[i] = M + 2 - B[i]",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 2 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "B[i] = M + 1 - B[i]",
      "mutated_line": "B[i] = M + 0 - B[i]",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 0 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "B[i] = M + 1 - B[i]",
      "mutated_line": "B[i] = M + 0 - B[i]",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 0 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "B[i] = M + 1 - B[i]",
      "mutated_line": "B[i] = M + -1 - B[i]",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + -1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) * 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) * 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if i - j + 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if i - j + 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) * 2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) * 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) + 2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) + 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = -1",
      "mutated_line": "ans = -2",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -2\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = -1",
      "mutated_line": "ans = -0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -0\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = -1",
      "mutated_line": "ans = -0",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -0\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = -1",
      "mutated_line": "ans = --1",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = --1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != -1 and (not (dir and prev < B[i] or (not dir and prev >= B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev < B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != -1 and (not (dir and prev > B[i] or (not dir and prev >= B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev > B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != -1 and (not (dir and prev == B[i] or (not dir and prev >= B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev == B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev > B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev > B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev < B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev < B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if B[i] != -1 and not (dir and prev <= B[i] or (not dir and prev >= B[i])):",
      "mutated_line": "if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev == B[i]))):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev == B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i + j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i + j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if i * j % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if i * j % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 3 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 3 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 1 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 1 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 0 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 0 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 1 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 1 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % -2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % -2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 3 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 3 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 1 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 1 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 0 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 0 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 1 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 1 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) % -2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % -2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] + B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] + B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] * B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] * B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i + j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i + j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i * j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i * j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] + B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] + B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i - j) % 2 != abs(B[i] - B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "mutated_line": "if (i - j) % 2 != abs(B[i] * B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):",
      "code": "def calculate_min_direction_changes(N, M, B):\n    ans = float('inf')\n    for pp in range(2):\n        lpoz = -1\n        sw = 0\n        prev = B[0]\n        dir = True\n        if prev == -1:\n            prev = 1\n        else:\n            lpoz = 0\n        for i in range(1, N):\n            if B[i] != -1:\n                j = lpoz\n                if j != -1:\n                    if (i - j) % 2 != abs(B[i] * B[j]) % 2 or abs(B[i] - B[j]) > abs(i - j):\n                        ans = -1\n                        break\n                lpoz = i\n            if dir and prev == M:\n                sw += 1\n                dir = not dir\n            elif not dir and prev == 1:\n                sw += 1\n                dir = not dir\n            if dir:\n                prev = prev + 1\n            else:\n                prev = prev - 1\n            if B[i] != -1 and (not (dir and prev <= B[i] or (not dir and prev >= B[i]))):\n                sw += 1\n                dir = not dir\n            if B[i] != -1:\n                prev = B[i]\n        if ans != -1 and ans > sw:\n            ans = sw\n        for i in range(N):\n            if 1 <= B[i] <= M:\n                B[i] = M + 1 - B[i]\n    return ans if ans != float('inf') else -1"
    }
  ]
}