{
  "task_id": "taco_18218",
  "entry_point": "nsum",
  "mutant_count": 180,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 + a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 + a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 * (a * (a + 1) // 2)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 * (a * (a + 1) // 2)\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) / 2 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) / 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) * 2 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) * 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a * (a + 1) / 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) / 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a * (a + 1) * 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) * 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "broken = False",
      "mutated_line": "broken = True",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = True\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "tolook = 0",
      "mutated_line": "tolook = 1",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 1\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "tolook = 0",
      "mutated_line": "tolook = -1",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = -1\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "tolook = 0",
      "mutated_line": "tolook = 1",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 1\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if k != 0:",
      "mutated_line": "if k == 0:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k == 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if tolook % 2:",
      "mutated_line": "if tolook * 2:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook * 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if tolook % 2:",
      "mutated_line": "if tolook + 2:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook + 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b / (b - 1) // 2 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b / (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return (b + (b - 1)) // 2 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return (b + (b - 1)) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b ** (b - 1) // 2 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b ** (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 3 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 3 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 1 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 1 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 0 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 0 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 1 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 1 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // -2 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // -2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a / (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a / (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - (a + (a + 1)) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - (a + (a + 1)) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a ** (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a ** (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a * (a + 1) // 3",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 3\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a * (a + 1) // 1",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 1\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a * (a + 1) // 0",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 0\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a * (a + 1) // 1",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 1\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a * (a + 1) // -2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // -2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if k != 0:",
      "mutated_line": "if k != 1:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 1:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if k != 0:",
      "mutated_line": "if k != -1:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != -1:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if k != 0:",
      "mutated_line": "if k != 1:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 1:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if lost[0] in (1, 2):",
      "mutated_line": "if lost[0] not in (1, 2):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] not in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 - n * (n + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 - n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 * (n * (n + 1) // 2)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 * (n * (n + 1) // 2)\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if tolook % 2:",
      "mutated_line": "if tolook % 3:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 3:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if tolook % 2:",
      "mutated_line": "if tolook % 1:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 1:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if tolook % 2:",
      "mutated_line": "if tolook % 0:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 0:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if tolook % 2:",
      "mutated_line": "if tolook % 1:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 1:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if tolook % 2:",
      "mutated_line": "if tolook % -2:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % -2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b + 1) // 2 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b + 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b * 1) // 2 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b * 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a * (a - 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a - 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a * (a * 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a * 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif k == 1:",
      "mutated_line": "elif k != 1:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k != 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 2 + n * (n + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 2 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 0 + n * (n + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 0 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 0 + n * (n + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 0 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = -1 + n * (n + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = -1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n * (n + 1) / 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) / 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n * (n + 1) * 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) * 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "results.append('Chef')",
      "mutated_line": "results.append('')",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "results.append('Mom')",
      "mutated_line": "results.append('')",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 2) // 2 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 2) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 0) // 2 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 0) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 0) // 2 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 0) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - -1) // 2 - a * (a + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - -1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a * (a + 2) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 2) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a * (a + 0) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 0) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a * (a + 0) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 0) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "return b * (b - 1) // 2 - a * (a + 1) // 2",
      "mutated_line": "return b * (b - 1) // 2 - a * (a + -1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + -1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if lost[0] in (1, 2):",
      "mutated_line": "if lost[1] in (1, 2):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[1] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if lost[0] in (1, 2):",
      "mutated_line": "if lost[-1] in (1, 2):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[-1] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if lost[0] in (1, 2):",
      "mutated_line": "if lost[1] in (1, 2):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[1] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if lost[0] in (1, 2):",
      "mutated_line": "if lost[0] in (2, 2):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (2, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if lost[0] in (1, 2):",
      "mutated_line": "if lost[0] in (0, 2):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (0, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if lost[0] in (1, 2):",
      "mutated_line": "if lost[0] in (0, 2):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (0, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if lost[0] in (1, 2):",
      "mutated_line": "if lost[0] in (-1, 2):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (-1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if lost[0] in (1, 2):",
      "mutated_line": "if lost[0] in (1, 3):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 3):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if lost[0] in (1, 2):",
      "mutated_line": "if lost[0] in (1, 1):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 1):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if lost[0] in (1, 2):",
      "mutated_line": "if lost[0] in (1, 0):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 0):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if lost[0] in (1, 2):",
      "mutated_line": "if lost[0] in (1, 1):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 1):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if lost[0] in (1, 2):",
      "mutated_line": "if lost[0] in (1, -2):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, -2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "tolook = lost[0]",
      "mutated_line": "tolook = lost[1]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[1]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "tolook = lost[0]",
      "mutated_line": "tolook = lost[-1]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[-1]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "tolook = lost[0]",
      "mutated_line": "tolook = lost[1]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[1]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif k == 1:",
      "mutated_line": "elif k == 2:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 2:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif k == 1:",
      "mutated_line": "elif k == 0:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 0:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif k == 1:",
      "mutated_line": "elif k == 0:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 0:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif k == 1:",
      "mutated_line": "elif k == -1:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == -1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + 1) // 2 + lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 + lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = (1 + n * (n + 1) // 2) * lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = (1 + n * (n + 1) // 2) * lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n / (n + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n / (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + (n + (n + 1)) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + (n + (n + 1)) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n ** (n + 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n ** (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n * (n + 1) // 3",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 3\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n * (n + 1) // 1",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 1\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n * (n + 1) // 0",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 0\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n * (n + 1) // 1",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 1\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n * (n + 1) // -2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // -2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 - n * (n + 1) // 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 - n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 * (n * (n + 1) // 2) - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 * (n * (n + 1) // 2) - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tolook = nsum(0, lost[0])",
      "mutated_line": "tolook = nsum(1, lost[0])",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(1, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tolook = nsum(0, lost[0])",
      "mutated_line": "tolook = nsum(-1, lost[0])",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(-1, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tolook = nsum(0, lost[0])",
      "mutated_line": "tolook = nsum(1, lost[0])",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(1, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(k - 1):",
      "mutated_line": "for i in range(k + 1):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k + 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(k - 1):",
      "mutated_line": "for i in range(k * 1):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k * 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if lost[i] > tolook:",
      "mutated_line": "if lost[i] >= tolook:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] >= tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if lost[i] > tolook:",
      "mutated_line": "if lost[i] <= tolook:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] <= tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if lost[i] > tolook:",
      "mutated_line": "if lost[i] != tolook:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] != tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "tolook += 1",
      "mutated_line": "tolook -= 1",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook -= 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "tolook += nsum(lost[i], lost[i + 1])",
      "mutated_line": "tolook -= nsum(lost[i], lost[i + 1])",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook -= nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if lost[-1] > tolook:",
      "mutated_line": "if lost[-1] >= tolook:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] >= tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if lost[-1] > tolook:",
      "mutated_line": "if lost[-1] <= tolook:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] <= tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if lost[-1] > tolook:",
      "mutated_line": "if lost[-1] != tolook:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] != tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "tolook += 1",
      "mutated_line": "tolook -= 1",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook -= 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook -= 1 + nsum(lost[-1], n + 1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook -= 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n * (n - 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n - 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n * (n * 1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n * 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 2 + n * (n + 1) // 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 2 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 0 + n * (n + 1) // 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 0 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 0 + n * (n + 1) // 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 0 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = -1 + n * (n + 1) // 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = -1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + 1) / 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) / 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + 1) * 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) * 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + 1) // 2 - lost[1]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[1]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + 1) // 2 - lost[-1]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[-1]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + 1) // 2 - lost[1]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[1]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tolook = nsum(0, lost[0])",
      "mutated_line": "tolook = nsum(0, lost[1])",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[1])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tolook = nsum(0, lost[0])",
      "mutated_line": "tolook = nsum(0, lost[-1])",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[-1])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tolook = nsum(0, lost[0])",
      "mutated_line": "tolook = nsum(0, lost[1])",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[1])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(k - 1):",
      "mutated_line": "for i in range(k - 2):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 2):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(k - 1):",
      "mutated_line": "for i in range(k - 0):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 0):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(k - 1):",
      "mutated_line": "for i in range(k - 0):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 0):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(k - 1):",
      "mutated_line": "for i in range(k - -1):",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - -1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tolook += 1",
      "mutated_line": "tolook += 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 2\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tolook += 1",
      "mutated_line": "tolook += 0",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 0\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tolook += 1",
      "mutated_line": "tolook += 0",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 0\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tolook += 1",
      "mutated_line": "tolook += -1",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += -1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "broken = True",
      "mutated_line": "broken = False",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = False\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "tolook += 1",
      "mutated_line": "tolook += 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 2\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "tolook += 1",
      "mutated_line": "tolook += 0",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 0\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "tolook += 1",
      "mutated_line": "tolook += 0",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 0\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "tolook += 1",
      "mutated_line": "tolook += -1",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += -1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 1 - nsum(lost[-1], n + 1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 - nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 1 * nsum(lost[-1], n + 1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 * nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n * (n + 2) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 2) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n * (n + 0) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 0) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n * (n + 0) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 0) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "tolook = 1 + n * (n + 1) // 2",
      "mutated_line": "tolook = 1 + n * (n + -1) // 2",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + -1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n / (n + 1) // 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n / (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + (n + (n + 1)) // 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + (n + (n + 1)) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n ** (n + 1) // 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n ** (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + 1) // 3 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 3 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + 1) // 1 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 1 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + 1) // 0 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 0 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + 1) // 1 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 1 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + 1) // -2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // -2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "if lost[-1] > tolook:",
      "mutated_line": "if lost[+1] > tolook:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[+1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 2 + nsum(lost[-1], n + 1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 2 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 0 + nsum(lost[-1], n + 1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 0 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 0 + nsum(lost[-1], n + 1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 0 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += -1 + nsum(lost[-1], n + 1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += -1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n - 1) // 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n - 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n * 1) // 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n * 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "tolook += nsum(lost[i], lost[i + 1])",
      "mutated_line": "tolook += nsum(lost[i], lost[i - 1])",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i - 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "tolook += nsum(lost[i], lost[i + 1])",
      "mutated_line": "tolook += nsum(lost[i], lost[i * 1])",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i * 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if lost[-1] > tolook:",
      "mutated_line": "if lost[-2] > tolook:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-2] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if lost[-1] > tolook:",
      "mutated_line": "if lost[-0] > tolook:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-0] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if lost[-1] > tolook:",
      "mutated_line": "if lost[-0] > tolook:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-0] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if lost[-1] > tolook:",
      "mutated_line": "if lost[--1] > tolook:",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[--1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 1 + nsum(lost[-1], n - 1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n - 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 1 + nsum(lost[-1], n * 1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n * 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + 2) // 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 2) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + 0) // 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 0) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + 0) // 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 0) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "tolook = 1 + n * (n + 1) // 2 - lost[0]",
      "mutated_line": "tolook = 1 + n * (n + -1) // 2 - lost[0]",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + -1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "tolook += nsum(lost[i], lost[i + 1])",
      "mutated_line": "tolook += nsum(lost[i], lost[i + 2])",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 2])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "tolook += nsum(lost[i], lost[i + 1])",
      "mutated_line": "tolook += nsum(lost[i], lost[i + 0])",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 0])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "tolook += nsum(lost[i], lost[i + 1])",
      "mutated_line": "tolook += nsum(lost[i], lost[i + 0])",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 0])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "tolook += nsum(lost[i], lost[i + 1])",
      "mutated_line": "tolook += nsum(lost[i], lost[i + -1])",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + -1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 1 + nsum(lost[+1], n + 1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[+1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 1 + nsum(lost[-1], n + 2)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 2)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 1 + nsum(lost[-1], n + 0)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 0)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 1 + nsum(lost[-1], n + 0)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + 0)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 1 + nsum(lost[-1], n + -1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-1], n + -1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 1 + nsum(lost[-2], n + 1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-2], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 1 + nsum(lost[-0], n + 1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-0], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 1 + nsum(lost[-0], n + 1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[-0], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "tolook += 1 + nsum(lost[-1], n + 1)",
      "mutated_line": "tolook += 1 + nsum(lost[--1], n + 1)",
      "code": "def nsum(a, b):\n    return b * (b - 1) // 2 - a * (a + 1) // 2\n\ndef determine_first_mover(T, test_cases):\n    results = []\n    for case in test_cases:\n        (n, k, lost) = case\n        broken = False\n        brokenAt = None\n        tolook = 0\n        if k != 0:\n            lost.sort()\n            if lost[0] in (1, 2):\n                tolook = lost[0]\n            elif k == 1:\n                tolook = 1 + n * (n + 1) // 2 - lost[0]\n            else:\n                tolook = nsum(0, lost[0])\n                for i in range(k - 1):\n                    if lost[i] > tolook:\n                        tolook += 1\n                        broken = True\n                        brokenAt = i\n                        break\n                    else:\n                        tolook += nsum(lost[i], lost[i + 1])\n                if not broken:\n                    if lost[-1] > tolook:\n                        tolook += 1\n                    else:\n                        tolook += 1 + nsum(lost[--1], n + 1)\n        else:\n            tolook = 1 + n * (n + 1) // 2\n        if tolook % 2:\n            results.append('Chef')\n        else:\n            results.append('Mom')\n    return results"
    }
  ]
}