{
  "task_id": "taco_14415",
  "entry_point": "calculate_treeversion",
  "mutant_count": 82,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [False] / n",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] / n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [False] + n",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] + n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [False] ** n",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] ** n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[root] = True",
      "mutated_line": "visited[root] = False",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = False\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(child) == 0:",
      "mutated_line": "if len(child) != 0:",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) != 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "zeros += sub_tree.zeros",
      "mutated_line": "zeros -= sub_tree.zeros",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros -= sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "ones += sub_tree.ones",
      "mutated_line": "ones -= sub_tree.ones",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones -= sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "inversions += factor * sub_tree.zeros + sub_tree.inversions",
      "mutated_line": "inversions -= factor * sub_tree.zeros + sub_tree.inversions",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions -= factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "factor += sub_tree.ones",
      "mutated_line": "factor -= sub_tree.ones",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor -= sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "mutated_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' - str(self.inversions)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' - str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "mutated_line": "return ('0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:') * str(self.inversions)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return ('0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:') * str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(child) == 0:",
      "mutated_line": "if len(child) == 1:",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 1:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(child) == 0:",
      "mutated_line": "if len(child) == -1:",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == -1:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(child) == 0:",
      "mutated_line": "if len(child) == 1:",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 1:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "zeros, ones, inversions = weights[root] ^ 1, weights[root], 0",
      "mutated_line": "(zeros, ones, inversions) = (weights[root] | 1, weights[root], 0)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] | 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "zeros, ones, inversions = weights[root] ^ 1, weights[root], 0",
      "mutated_line": "(zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 1)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "zeros, ones, inversions = weights[root] ^ 1, weights[root], 0",
      "mutated_line": "(zeros, ones, inversions) = (weights[root] ^ 1, weights[root], -1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], -1)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "zeros, ones, inversions = weights[root] ^ 1, weights[root], 0",
      "mutated_line": "(zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 1)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "inversions += factor * sub_tree.zeros + sub_tree.inversions",
      "mutated_line": "inversions += factor * sub_tree.zeros - sub_tree.inversions",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros - sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "inversions += factor * sub_tree.zeros + sub_tree.inversions",
      "mutated_line": "inversions += factor * sub_tree.zeros * sub_tree.inversions",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros * sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[x - 1].append(y - 1)",
      "mutated_line": "adj[x - 1].append(y + 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y + 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[x - 1].append(y - 1)",
      "mutated_line": "adj[x - 1].append(y * 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y * 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "adj[y - 1].append(x - 1)",
      "mutated_line": "adj[y - 1].append(x + 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x + 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "adj[y - 1].append(x - 1)",
      "mutated_line": "adj[y - 1].append(x * 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x * 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "visited = [False] * n",
      "mutated_line": "visited = [True] * n",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [True] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dfs(0).inversions",
      "mutated_line": "return dfs(1).inversions",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(1).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dfs(0).inversions",
      "mutated_line": "return dfs(-1).inversions",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(-1).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dfs(0).inversions",
      "mutated_line": "return dfs(1).inversions",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(1).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "mutated_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) - ' Inversions:' + str(self.inversions)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) - ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "mutated_line": "return ('0: ' + str(self.zeros) + ' 1:' + str(self.ones)) * ' Inversions:' + str(self.inversions)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return ('0: ' + str(self.zeros) + ' 1:' + str(self.ones)) * ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return SubTree(weights[root] ^ 1, weights[root], 0)",
      "mutated_line": "return SubTree(weights[root] | 1, weights[root], 0)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] | 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return SubTree(weights[root] ^ 1, weights[root], 0)",
      "mutated_line": "return SubTree(weights[root] ^ 1, weights[root], 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 1)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return SubTree(weights[root] ^ 1, weights[root], 0)",
      "mutated_line": "return SubTree(weights[root] ^ 1, weights[root], -1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], -1)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return SubTree(weights[root] ^ 1, weights[root], 0)",
      "mutated_line": "return SubTree(weights[root] ^ 1, weights[root], 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 1)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "zeros, ones, inversions = weights[root] ^ 1, weights[root], 0",
      "mutated_line": "(zeros, ones, inversions) = (weights[root] ^ 2, weights[root], 0)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 2, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "zeros, ones, inversions = weights[root] ^ 1, weights[root], 0",
      "mutated_line": "(zeros, ones, inversions) = (weights[root] ^ 0, weights[root], 0)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 0, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "zeros, ones, inversions = weights[root] ^ 1, weights[root], 0",
      "mutated_line": "(zeros, ones, inversions) = (weights[root] ^ 0, weights[root], 0)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 0, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "zeros, ones, inversions = weights[root] ^ 1, weights[root], 0",
      "mutated_line": "(zeros, ones, inversions) = (weights[root] ^ -1, weights[root], 0)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ -1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "inversions += factor * sub_tree.zeros + sub_tree.inversions",
      "mutated_line": "inversions += factor / sub_tree.zeros + sub_tree.inversions",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor / sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "inversions += factor * sub_tree.zeros + sub_tree.inversions",
      "mutated_line": "inversions += factor + sub_tree.zeros + sub_tree.inversions",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor + sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "inversions += factor * sub_tree.zeros + sub_tree.inversions",
      "mutated_line": "inversions += factor ** sub_tree.zeros + sub_tree.inversions",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor ** sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[x - 1].append(y - 1)",
      "mutated_line": "adj[x - 1].append(y - 2)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 2)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[x - 1].append(y - 1)",
      "mutated_line": "adj[x - 1].append(y - 0)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 0)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[x - 1].append(y - 1)",
      "mutated_line": "adj[x - 1].append(y - 0)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 0)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[x - 1].append(y - 1)",
      "mutated_line": "adj[x - 1].append(y - -1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - -1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "adj[y - 1].append(x - 1)",
      "mutated_line": "adj[y - 1].append(x - 2)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 2)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "adj[y - 1].append(x - 1)",
      "mutated_line": "adj[y - 1].append(x - 0)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 0)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "adj[y - 1].append(x - 1)",
      "mutated_line": "adj[y - 1].append(x - 0)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 0)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "adj[y - 1].append(x - 1)",
      "mutated_line": "adj[y - 1].append(x - -1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - -1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "mutated_line": "return '0: ' + str(self.zeros) + ' 1:' - str(self.ones) + ' Inversions:' + str(self.inversions)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' - str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "mutated_line": "return ('0: ' + str(self.zeros) + ' 1:') * str(self.ones) + ' Inversions:' + str(self.inversions)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return ('0: ' + str(self.zeros) + ' 1:') * str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "mutated_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + '' + str(self.inversions)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + '' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return SubTree(weights[root] ^ 1, weights[root], 0)",
      "mutated_line": "return SubTree(weights[root] ^ 2, weights[root], 0)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 2, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return SubTree(weights[root] ^ 1, weights[root], 0)",
      "mutated_line": "return SubTree(weights[root] ^ 0, weights[root], 0)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 0, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return SubTree(weights[root] ^ 1, weights[root], 0)",
      "mutated_line": "return SubTree(weights[root] ^ 0, weights[root], 0)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 0, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return SubTree(weights[root] ^ 1, weights[root], 0)",
      "mutated_line": "return SubTree(weights[root] ^ -1, weights[root], 0)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ -1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[x - 1].append(y - 1)",
      "mutated_line": "adj[x + 1].append(y - 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x + 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "adj[x - 1].append(y - 1)",
      "mutated_line": "adj[x * 1].append(y - 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x * 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "adj[y - 1].append(x - 1)",
      "mutated_line": "adj[y + 1].append(x - 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y + 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "adj[y - 1].append(x - 1)",
      "mutated_line": "adj[y * 1].append(x - 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y * 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "mutated_line": "return '0: ' + str(self.zeros) - ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) - ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "mutated_line": "return ('0: ' + str(self.zeros)) * ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return ('0: ' + str(self.zeros)) * ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))",
      "mutated_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros + x.zeros * y.ones))",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros + x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))",
      "mutated_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros * (x.zeros * y.ones)))",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros * (x.zeros * y.ones)))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[x - 1].append(y - 1)",
      "mutated_line": "adj[x - 2].append(y - 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 2].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[x - 1].append(y - 1)",
      "mutated_line": "adj[x - 0].append(y - 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 0].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[x - 1].append(y - 1)",
      "mutated_line": "adj[x - 0].append(y - 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 0].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "adj[x - 1].append(y - 1)",
      "mutated_line": "adj[x - -1].append(y - 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - -1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "adj[y - 1].append(x - 1)",
      "mutated_line": "adj[y - 2].append(x - 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 2].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "adj[y - 1].append(x - 1)",
      "mutated_line": "adj[y - 0].append(x - 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 0].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "adj[y - 1].append(x - 1)",
      "mutated_line": "adj[y - 0].append(x - 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 0].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "adj[y - 1].append(x - 1)",
      "mutated_line": "adj[y - -1].append(x - 1)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - -1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "mutated_line": "return '0: ' - str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' - str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "mutated_line": "return '0: ' * str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' * str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "mutated_line": "return '0: ' + str(self.zeros) + '' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + '' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))",
      "mutated_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones / y.zeros - x.zeros * y.ones))",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones / y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))",
      "mutated_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones + y.zeros - x.zeros * y.ones))",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones + y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))",
      "mutated_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones ** y.zeros - x.zeros * y.ones))",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones ** y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))",
      "mutated_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros / y.ones))",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros / y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))",
      "mutated_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - (x.zeros + y.ones)))",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - (x.zeros + y.ones)))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))",
      "mutated_line": "results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros ** y.ones))",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros ** y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return '0: ' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "mutated_line": "return '' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)",
      "code": "def calculate_treeversion(n, weights, edges):\n    from collections import defaultdict\n    from functools import cmp_to_key\n\n    class SubTree:\n\n        def __init__(self, zeros, ones, inversions):\n            self.zeros = zeros\n            self.ones = ones\n            self.inversions = inversions\n\n        def __str__(self):\n            return '' + str(self.zeros) + ' 1:' + str(self.ones) + ' Inversions:' + str(self.inversions)\n\n    def dfs(root):\n        visited[root] = True\n        child = [vertex for vertex in adj[root] if not visited[vertex]]\n        if len(child) == 0:\n            return SubTree(weights[root] ^ 1, weights[root], 0)\n        results = [dfs(i) for i in child]\n        results.sort(key=cmp_to_key(lambda x, y: x.ones * y.zeros - x.zeros * y.ones))\n        (zeros, ones, inversions) = (weights[root] ^ 1, weights[root], 0)\n        factor = weights[root]\n        for sub_tree in results:\n            zeros += sub_tree.zeros\n            ones += sub_tree.ones\n            inversions += factor * sub_tree.zeros + sub_tree.inversions\n            factor += sub_tree.ones\n        return SubTree(zeros, ones, inversions)\n    adj = defaultdict(list)\n    for (x, y) in edges:\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False] * n\n    return dfs(0).inversions"
    }
  ]
}