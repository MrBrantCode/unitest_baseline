{
  "task_id": "taco_13366",
  "entry_point": "minimal_pieces",
  "mutant_count": 101,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if res < 0:",
      "mutated_line": "if res <= 0:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res <= 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if res < 0:",
      "mutated_line": "if res >= 0:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res >= 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if res < 0:",
      "mutated_line": "if res != 0:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res != 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = 1",
      "mutated_line": "i = 2",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 2\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = 1",
      "mutated_line": "i = 0",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 0\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = 1",
      "mutated_line": "i = 0",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 0\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "i = 1",
      "mutated_line": "i = -1",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = -1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i < n:",
      "mutated_line": "while i <= n:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i <= n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i < n:",
      "mutated_line": "while i >= n:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i >= n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i < n:",
      "mutated_line": "while i != n:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i != n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i -= 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "fail = False",
      "mutated_line": "fail = True",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = True\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if res < 0:",
      "mutated_line": "if res < 1:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 1:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if res < 0:",
      "mutated_line": "if res < -1:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < -1:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if res < 0:",
      "mutated_line": "if res < 1:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 1:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tmpmin = a[0]",
      "mutated_line": "tmpmin = a[1]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[1]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tmpmin = a[0]",
      "mutated_line": "tmpmin = a[-1]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[-1]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "tmpmin = a[0]",
      "mutated_line": "tmpmin = a[1]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[1]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tmpmax = a[0]",
      "mutated_line": "tmpmax = a[1]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[1]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tmpmax = a[0]",
      "mutated_line": "tmpmax = a[-1]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[-1]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "tmpmax = a[0]",
      "mutated_line": "tmpmax = a[1]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[1]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:",
      "mutated_line": "if abs(a[i] - tmpmin) <= s or abs(a[i] - tmpmax) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s or abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 2\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 0\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 0\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += -1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(pieces[j]) < l:",
      "mutated_line": "if len(pieces[j]) <= l:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) <= l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(pieces[j]) < l:",
      "mutated_line": "if len(pieces[j]) >= l:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) >= l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(pieces[j]) < l:",
      "mutated_line": "if len(pieces[j]) != l:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) != l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tmppc = [a[0]]",
      "mutated_line": "tmppc = [a[1]]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[1]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tmppc = [a[0]]",
      "mutated_line": "tmppc = [a[-1]]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[-1]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tmppc = [a[0]]",
      "mutated_line": "tmppc = [a[1]]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[1]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:",
      "mutated_line": "if abs(a[i] - tmpmin) < s and abs(a[i] - tmpmax) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) < s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:",
      "mutated_line": "if abs(a[i] - tmpmin) > s and abs(a[i] - tmpmax) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) > s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:",
      "mutated_line": "if abs(a[i] - tmpmin) == s and abs(a[i] - tmpmax) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) == s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:",
      "mutated_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) < s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) < s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:",
      "mutated_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) > s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) > s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:",
      "mutated_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) == s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) == s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if a[i] < tmpmin:",
      "mutated_line": "if a[i] <= tmpmin:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] <= tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if a[i] < tmpmin:",
      "mutated_line": "if a[i] >= tmpmin:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] >= tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if a[i] < tmpmin:",
      "mutated_line": "if a[i] != tmpmin:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] != tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if j > 0:",
      "mutated_line": "if j >= 0:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j >= 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if j > 0:",
      "mutated_line": "if j <= 0:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j <= 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if j > 0:",
      "mutated_line": "if j != 0:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j != 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif a[i] > tmpmax:",
      "mutated_line": "elif a[i] >= tmpmax:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] >= tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif a[i] > tmpmax:",
      "mutated_line": "elif a[i] <= tmpmax:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] <= tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "elif a[i] > tmpmax:",
      "mutated_line": "elif a[i] != tmpmax:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] != tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if j > 0:",
      "mutated_line": "if j > 1:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 1:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if j > 0:",
      "mutated_line": "if j > -1:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > -1:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if j > 0:",
      "mutated_line": "if j > 1:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 1:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while len(pieces[j]) < l:",
      "mutated_line": "while len(pieces[j]) <= l:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) <= l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while len(pieces[j]) < l:",
      "mutated_line": "while len(pieces[j]) >= l:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) >= l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while len(pieces[j]) < l:",
      "mutated_line": "while len(pieces[j]) != l:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) != l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return +1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:",
      "mutated_line": "if abs(a[i] + tmpmin) <= s and abs(a[i] - tmpmax) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] + tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:",
      "mutated_line": "if abs(a[i] * tmpmin) <= s and abs(a[i] - tmpmax) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] * tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:",
      "mutated_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] + tmpmax) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] + tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:",
      "mutated_line": "if abs(a[i] - tmpmin) <= s and abs(a[i] * tmpmax) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] * tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "prevpc = pieces[j - 1]",
      "mutated_line": "prevpc = pieces[j + 1]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j + 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "prevpc = pieces[j - 1]",
      "mutated_line": "prevpc = pieces[j * 1]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j * 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:",
      "mutated_line": "if abs(tmp - minj) <= s or abs(tmp - maxj) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s or abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if len(prevpc) < l:",
      "mutated_line": "if len(prevpc) <= l:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) <= l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if len(prevpc) < l:",
      "mutated_line": "if len(prevpc) >= l:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) >= l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if len(prevpc) < l:",
      "mutated_line": "if len(prevpc) != l:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) != l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -2\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -0\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -0\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return --1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "prevpc = pieces[j - 1]",
      "mutated_line": "prevpc = pieces[j - 2]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 2]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "prevpc = pieces[j - 1]",
      "mutated_line": "prevpc = pieces[j - 0]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 0]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "prevpc = pieces[j - 1]",
      "mutated_line": "prevpc = pieces[j - 0]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 0]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "prevpc = pieces[j - 1]",
      "mutated_line": "prevpc = pieces[j - -1]",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - -1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:",
      "mutated_line": "if abs(tmp - minj) < s and abs(tmp - maxj) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) < s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:",
      "mutated_line": "if abs(tmp - minj) > s and abs(tmp - maxj) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) > s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:",
      "mutated_line": "if abs(tmp - minj) == s and abs(tmp - maxj) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) == s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:",
      "mutated_line": "if abs(tmp - minj) <= s and abs(tmp - maxj) < s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) < s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:",
      "mutated_line": "if abs(tmp - minj) <= s and abs(tmp - maxj) > s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) > s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:",
      "mutated_line": "if abs(tmp - minj) <= s and abs(tmp - maxj) == s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) == s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if tmp < minj:",
      "mutated_line": "if tmp <= minj:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp <= minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if tmp < minj:",
      "mutated_line": "if tmp >= minj:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp >= minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if tmp < minj:",
      "mutated_line": "if tmp != minj:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp != minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return +1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return +1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pieces[j].insert(0, tmp)",
      "mutated_line": "pieces[j].insert(1, tmp)",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(1, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pieces[j].insert(0, tmp)",
      "mutated_line": "pieces[j].insert(-1, tmp)",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(-1, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pieces[j].insert(0, tmp)",
      "mutated_line": "pieces[j].insert(1, tmp)",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(1, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif tmp > maxj:",
      "mutated_line": "elif tmp >= maxj:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp >= maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif tmp > maxj:",
      "mutated_line": "elif tmp <= maxj:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp <= maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif tmp > maxj:",
      "mutated_line": "elif tmp != maxj:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp != maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -2\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -0\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -0\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return --1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -2\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -0\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -0\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return --1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:",
      "mutated_line": "if abs(tmp + minj) <= s and abs(tmp - maxj) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp + minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:",
      "mutated_line": "if abs(tmp * minj) <= s and abs(tmp - maxj) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp * minj) <= s and abs(tmp - maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:",
      "mutated_line": "if abs(tmp - minj) <= s and abs(tmp + maxj) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp + maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if abs(tmp - minj) <= s and abs(tmp - maxj) <= s:",
      "mutated_line": "if abs(tmp - minj) <= s and abs(tmp * maxj) <= s:",
      "code": "def minimal_pieces(n, s, l, a):\n\n    def split(a, n, s, l):\n        pieces = []\n        i = 1\n        tmpmin = a[0]\n        tmpmax = a[0]\n        tmppc = [a[0]]\n        while i < n:\n            if abs(a[i] - tmpmin) <= s and abs(a[i] - tmpmax) <= s:\n                tmppc.append(a[i])\n                if a[i] < tmpmin:\n                    tmpmin = a[i]\n                elif a[i] > tmpmax:\n                    tmpmax = a[i]\n            else:\n                pieces.append(tmppc)\n                tmppc = [a[i]]\n                tmpmin = a[i]\n                tmpmax = a[i]\n            i += 1\n        pieces.append(tmppc)\n        fail = False\n        for j in range(len(pieces)):\n            if len(pieces[j]) < l:\n                if j > 0:\n                    prevpc = pieces[j - 1]\n                    minj = min(pieces[j])\n                    maxj = max(pieces[j])\n                    while len(pieces[j]) < l:\n                        tmp = prevpc.pop()\n                        if abs(tmp - minj) <= s and abs(tmp * maxj) <= s:\n                            pieces[j].insert(0, tmp)\n                            if tmp < minj:\n                                minj = tmp\n                            elif tmp > maxj:\n                                maxj = tmp\n                        else:\n                            return -1\n                        if len(prevpc) < l:\n                            return -1\n                else:\n                    return -1\n        return len(pieces)\n    res = split(a, n, s, l)\n    if res < 0:\n        a.reverse()\n        res = split(a, n, s, l)\n    return res"
    }
  ]
}