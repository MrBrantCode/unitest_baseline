{
  "task_id": "taco_3173",
  "entry_point": "max_cake_volume",
  "mutant_count": 50,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "d = [0] * (len(k) + 1)",
      "mutated_line": "d = [0] / (len(k) + 1)",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] / (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "d = [0] * (len(k) + 1)",
      "mutated_line": "d = [0] + (len(k) + 1)",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] + (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "d = [0] * (len(k) + 1)",
      "mutated_line": "d = [0] ** (len(k) + 1)",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] ** (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "q += v",
      "mutated_line": "q -= v",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q -= v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return max(d) * math.pi",
      "mutated_line": "return max(d) / math.pi",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) / math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return max(d) * math.pi",
      "mutated_line": "return max(d) + math.pi",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) + math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return max(d) * math.pi",
      "mutated_line": "return max(d) ** math.pi",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) ** math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "p = [r ** 2 * h for r, h in cakes]",
      "mutated_line": "p = [r ** 2 / h for (r, h) in cakes]",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 / h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "p = [r ** 2 * h for r, h in cakes]",
      "mutated_line": "p = [r ** 2 + h for (r, h) in cakes]",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 + h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "p = [r ** 2 * h for r, h in cakes]",
      "mutated_line": "p = [(r ** 2) ** h for (r, h) in cakes]",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [(r ** 2) ** h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "d = [0] * (len(k) + 1)",
      "mutated_line": "d = [0] * (len(k) - 1)",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) - 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "d = [0] * (len(k) + 1)",
      "mutated_line": "d = [0] * (len(k) * 1)",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) * 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "i = j + 1",
      "mutated_line": "i = j - 1",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j - 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "i = j + 1",
      "mutated_line": "i = j * 1",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j * 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "q = 0",
      "mutated_line": "q = 1",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 1\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "q = 0",
      "mutated_line": "q = -1",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = -1\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "q = 0",
      "mutated_line": "q = 1",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 1\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while j > 0:",
      "mutated_line": "while j >= 0:",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j >= 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while j > 0:",
      "mutated_line": "while j <= 0:",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j <= 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while j > 0:",
      "mutated_line": "while j != 0:",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j != 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "j -= j & -j",
      "mutated_line": "j += j & -j",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j += j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i < len(d):",
      "mutated_line": "while i <= len(d):",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i <= len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i < len(d):",
      "mutated_line": "while i >= len(d):",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i >= len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i < len(d):",
      "mutated_line": "while i != len(d):",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i != len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "i += i & -i",
      "mutated_line": "i -= i & -i",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i -= i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "p = [r ** 2 * h for r, h in cakes]",
      "mutated_line": "p = [r * 2 * h for (r, h) in cakes]",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r * 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "p = [r ** 2 * h for r, h in cakes]",
      "mutated_line": "p = [(r + 2) * h for (r, h) in cakes]",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [(r + 2) * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = [0] * (len(k) + 1)",
      "mutated_line": "d = [1] * (len(k) + 1)",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [1] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = [0] * (len(k) + 1)",
      "mutated_line": "d = [-1] * (len(k) + 1)",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [-1] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = [0] * (len(k) + 1)",
      "mutated_line": "d = [1] * (len(k) + 1)",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [1] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = [0] * (len(k) + 1)",
      "mutated_line": "d = [0] * (len(k) + 2)",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 2)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = [0] * (len(k) + 1)",
      "mutated_line": "d = [0] * (len(k) + 0)",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 0)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = [0] * (len(k) + 1)",
      "mutated_line": "d = [0] * (len(k) + 0)",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 0)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d = [0] * (len(k) + 1)",
      "mutated_line": "d = [0] * (len(k) + -1)",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + -1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i = j + 1",
      "mutated_line": "i = j + 2",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 2\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i = j + 1",
      "mutated_line": "i = j + 0",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 0\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i = j + 1",
      "mutated_line": "i = j + 0",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 0\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i = j + 1",
      "mutated_line": "i = j + -1",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + -1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while j > 0:",
      "mutated_line": "while j > 1:",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 1:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while j > 0:",
      "mutated_line": "while j > -1:",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > -1:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while j > 0:",
      "mutated_line": "while j > 1:",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 1:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "j -= j & -j",
      "mutated_line": "j -= j | -j",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j | -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "i += i & -i",
      "mutated_line": "i += i | -i",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i | -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [r ** 2 * h for r, h in cakes]",
      "mutated_line": "p = [r ** 3 * h for (r, h) in cakes]",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 3 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [r ** 2 * h for r, h in cakes]",
      "mutated_line": "p = [r ** 1 * h for (r, h) in cakes]",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 1 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [r ** 2 * h for r, h in cakes]",
      "mutated_line": "p = [r ** 0 * h for (r, h) in cakes]",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 0 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [r ** 2 * h for r, h in cakes]",
      "mutated_line": "p = [r ** 1 * h for (r, h) in cakes]",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 1 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "p = [r ** 2 * h for r, h in cakes]",
      "mutated_line": "p = [r ** -2 * h for (r, h) in cakes]",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** -2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "j -= j & -j",
      "mutated_line": "j -= j & +j",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & +j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & -i\n    return max(d) * math.pi"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "i += i & -i",
      "mutated_line": "i += i & +i",
      "code": "import math\n\ndef max_cake_volume(n, cakes):\n    p = [r ** 2 * h for (r, h) in cakes]\n    k = {v: j for (j, v) in enumerate(sorted(set(p)))}\n    d = [0] * (len(k) + 1)\n    for v in p:\n        j = k[v]\n        i = j + 1\n        q = 0\n        while j > 0:\n            q = max(d[j], q)\n            j -= j & -j\n        q += v\n        while i < len(d):\n            d[i] = max(d[i], q)\n            i += i & +i\n    return max(d) * math.pi"
    }
  ]
}