{
  "task_id": "taco_1347",
  "entry_point": "minimum_moves_to_reach_last_block",
  "mutant_count": 43,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if heights[0] < max(heights):",
      "mutated_line": "if heights[0] <= max(heights):",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] <= max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if heights[0] < max(heights):",
      "mutated_line": "if heights[0] >= max(heights):",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] >= max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if heights[0] < max(heights):",
      "mutated_line": "if heights[0] != max(heights):",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] != max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return +1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(2, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(0, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(0, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(-1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if len(stack) == 0 or heights[i] < stack[-1]:",
      "mutated_line": "if len(stack) == 0 and heights[i] < stack[-1]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 and heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if heights[0] < max(heights):",
      "mutated_line": "if heights[1] < max(heights):",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[1] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if heights[0] < max(heights):",
      "mutated_line": "if heights[-1] < max(heights):",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[-1] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if heights[0] < max(heights):",
      "mutated_line": "if heights[1] < max(heights):",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[1] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -2\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -0\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -0\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return --1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if len(stack) == 0 or heights[i] < stack[-1]:",
      "mutated_line": "if len(stack) != 0 or heights[i] < stack[-1]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) != 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if len(stack) == 0 or heights[i] < stack[-1]:",
      "mutated_line": "if len(stack) == 0 or heights[i] <= stack[-1]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] <= stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if len(stack) == 0 or heights[i] < stack[-1]:",
      "mutated_line": "if len(stack) == 0 or heights[i] >= stack[-1]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] >= stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if len(stack) == 0 or heights[i] < stack[-1]:",
      "mutated_line": "if len(stack) == 0 or heights[i] != stack[-1]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] != stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) > 0 or stack[-1] <= heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 or stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(stack) == 0 or heights[i] < stack[-1]:",
      "mutated_line": "if len(stack) == 1 or heights[i] < stack[-1]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 1 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(stack) == 0 or heights[i] < stack[-1]:",
      "mutated_line": "if len(stack) == -1 or heights[i] < stack[-1]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == -1 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(stack) == 0 or heights[i] < stack[-1]:",
      "mutated_line": "if len(stack) == 1 or heights[i] < stack[-1]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 1 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) >= 0 and stack[-1] <= heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) >= 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) <= 0 and stack[-1] <= heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) <= 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) != 0 and stack[-1] <= heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) != 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) > 0 and stack[-1] < heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] < heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) > 0 and stack[-1] > heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] > heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) > 0 and stack[-1] == heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] == heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "if len(stack) == 0 or heights[i] < stack[-1]:",
      "mutated_line": "if len(stack) == 0 or heights[i] < stack[+1]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[+1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) > 1 and stack[-1] <= heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 1 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) > -1 and stack[-1] <= heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > -1 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) > 1 and stack[-1] <= heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 1 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(stack) == 0 or heights[i] < stack[-1]:",
      "mutated_line": "if len(stack) == 0 or heights[i] < stack[-2]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-2]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(stack) == 0 or heights[i] < stack[-1]:",
      "mutated_line": "if len(stack) == 0 or heights[i] < stack[-0]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-0]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(stack) == 0 or heights[i] < stack[-1]:",
      "mutated_line": "if len(stack) == 0 or heights[i] < stack[-0]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-0]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if len(stack) == 0 or heights[i] < stack[-1]:",
      "mutated_line": "if len(stack) == 0 or heights[i] < stack[--1]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[--1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) > 0 and stack[+1] <= heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[+1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) > 0 and stack[-2] <= heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-2] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) > 0 and stack[-0] <= heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-0] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) > 0 and stack[-0] <= heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[-0] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while len(stack) > 0 and stack[-1] <= heights[i]:",
      "mutated_line": "while len(stack) > 0 and stack[--1] <= heights[i]:",
      "code": "def minimum_moves_to_reach_last_block(N, heights):\n    if heights[0] < max(heights):\n        return -1\n    stack = []\n    for i in range(1, N):\n        if len(stack) == 0 or heights[i] < stack[-1]:\n            stack.append(heights[i])\n        else:\n            while len(stack) > 0 and stack[--1] <= heights[i]:\n                stack.pop()\n            stack.append(heights[i])\n    return len(stack)"
    }
  ]
}