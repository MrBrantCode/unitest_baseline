{
  "task_id": "taco_2222",
  "entry_point": "calculate_best_place",
  "mutant_count": 62,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "op -= 1",
      "mutated_line": "op += 1",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op += 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pos = 1",
      "mutated_line": "pos = 2",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 2\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pos = 1",
      "mutated_line": "pos = 0",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 0\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pos = 1",
      "mutated_line": "pos = 0",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 0\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pos = 1",
      "mutated_line": "pos = -1",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = -1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "op -= 1",
      "mutated_line": "op -= 2",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 2\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "op -= 1",
      "mutated_line": "op -= 0",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 0\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "op -= 1",
      "mutated_line": "op -= 0",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 0\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "op -= 1",
      "mutated_line": "op -= -1",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= -1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "bal -= head",
      "mutated_line": "bal += head",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal += head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "pos -= 1",
      "mutated_line": "pos += 1",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos += 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if ti > bal:",
      "mutated_line": "if ti >= bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti >= bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if ti > bal:",
      "mutated_line": "if ti <= bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti <= bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if ti > bal:",
      "mutated_line": "if ti != bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti != bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "pos += 1",
      "mutated_line": "pos -= 1",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos -= 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if bal < head:",
      "mutated_line": "if bal <= head:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal <= head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if bal < head:",
      "mutated_line": "if bal >= head:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal >= head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if bal < head:",
      "mutated_line": "if bal != head:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal != head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pos -= 1",
      "mutated_line": "pos -= 2",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 2\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pos -= 1",
      "mutated_line": "pos -= 0",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 0\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pos -= 1",
      "mutated_line": "pos -= 0",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 0\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pos -= 1",
      "mutated_line": "pos -= -1",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= -1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "while op >= 0 and l[op][0] > bal:",
      "mutated_line": "while op >= 0 or l[op][0] > bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 or l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "op -= 1",
      "mutated_line": "op += 1",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op += 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "pos += 1",
      "mutated_line": "pos -= 1",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos -= 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pos += 1",
      "mutated_line": "pos += 2",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 2\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pos += 1",
      "mutated_line": "pos += 0",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 0\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pos += 1",
      "mutated_line": "pos += 0",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 0\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "pos += 1",
      "mutated_line": "pos += -1",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += -1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while op >= 0 and l[op][0] > bal:",
      "mutated_line": "while op > 0 and l[op][0] > bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op > 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while op >= 0 and l[op][0] > bal:",
      "mutated_line": "while op < 0 and l[op][0] > bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op < 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while op >= 0 and l[op][0] > bal:",
      "mutated_line": "while op == 0 and l[op][0] > bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op == 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while op >= 0 and l[op][0] > bal:",
      "mutated_line": "while op >= 0 and l[op][0] >= bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] >= bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while op >= 0 and l[op][0] > bal:",
      "mutated_line": "while op >= 0 and l[op][0] <= bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] <= bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while op >= 0 and l[op][0] > bal:",
      "mutated_line": "while op >= 0 and l[op][0] != bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] != bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "op -= 1",
      "mutated_line": "op -= 2",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 2\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "op -= 1",
      "mutated_line": "op -= 0",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 0\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "op -= 1",
      "mutated_line": "op -= 0",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 0\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "op -= 1",
      "mutated_line": "op -= -1",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= -1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pos += 1",
      "mutated_line": "pos += 2",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 2\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pos += 1",
      "mutated_line": "pos += 0",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 0\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pos += 1",
      "mutated_line": "pos += 0",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 0\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "pos += 1",
      "mutated_line": "pos += -1",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += -1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "l.append((ti, wi - ti + 1))",
      "mutated_line": "l.append((ti, wi - ti - 1))",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti - 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "l.append((ti, wi - ti + 1))",
      "mutated_line": "l.append((ti, (wi - ti) * 1))",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, (wi - ti) * 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "op = bisect_right(l, (bal, float('inf')))",
      "mutated_line": "op = bisect_right(l, (bal, float('')))",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while op >= 0 and l[op][0] > bal:",
      "mutated_line": "while op >= 1 and l[op][0] > bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 1 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while op >= 0 and l[op][0] > bal:",
      "mutated_line": "while op >= -1 and l[op][0] > bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= -1 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while op >= 0 and l[op][0] > bal:",
      "mutated_line": "while op >= 1 and l[op][0] > bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 1 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "l.append((ti, wi - ti + 1))",
      "mutated_line": "l.append((ti, wi + ti + 1))",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi + ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "l.append((ti, wi - ti + 1))",
      "mutated_line": "l.append((ti, wi * ti + 1))",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi * ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l.append((ti, wi - ti + 1))",
      "mutated_line": "l.append((ti, wi - ti + 2))",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 2))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l.append((ti, wi - ti + 1))",
      "mutated_line": "l.append((ti, wi - ti + 0))",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 0))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l.append((ti, wi - ti + 1))",
      "mutated_line": "l.append((ti, wi - ti + 0))",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 0))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l.append((ti, wi - ti + 1))",
      "mutated_line": "l.append((ti, wi - ti + -1))",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + -1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while op >= 0 and l[op][0] > bal:",
      "mutated_line": "while op >= 0 and l[op][1] > bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][1] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while op >= 0 and l[op][0] > bal:",
      "mutated_line": "while op >= 0 and l[op][-1] > bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][-1] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "while op >= 0 and l[op][0] > bal:",
      "mutated_line": "while op >= 0 and l[op][1] > bal:",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][1] > bal:\n            heapq.heappush(w, l[op][1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "heapq.heappush(w, l[op][1])",
      "mutated_line": "heapq.heappush(w, l[op][2])",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][2])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "heapq.heappush(w, l[op][1])",
      "mutated_line": "heapq.heappush(w, l[op][0])",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][0])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "heapq.heappush(w, l[op][1])",
      "mutated_line": "heapq.heappush(w, l[op][0])",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][0])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "heapq.heappush(w, l[op][1])",
      "mutated_line": "heapq.heappush(w, l[op][-1])",
      "code": "from bisect import bisect_right\nimport heapq\n\ndef calculate_best_place(n, limak_team, other_teams):\n    (t_limak, w_limak) = limak_team\n    bal = t_limak\n    pos = 1\n    l = []\n    for (ti, wi) in other_teams:\n        if ti > bal:\n            pos += 1\n        l.append((ti, wi - ti + 1))\n    l.sort()\n    best_pos = pos\n    op = bisect_right(l, (bal, float('inf')))\n    w = []\n    for (i, v) in l[op:]:\n        heapq.heappush(w, v)\n    op -= 1\n    while w:\n        head = heapq.heappop(w)\n        if bal < head:\n            break\n        bal -= head\n        pos -= 1\n        while op >= 0 and l[op][0] > bal:\n            heapq.heappush(w, l[op][-1])\n            op -= 1\n            pos += 1\n        best_pos = min(best_pos, pos)\n    return best_pos"
    }
  ]
}