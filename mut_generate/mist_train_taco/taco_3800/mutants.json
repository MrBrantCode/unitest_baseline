{
  "task_id": "taco_3800",
  "entry_point": "min_squares_to_disconnect",
  "mutant_count": 85,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 1\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "x = 0",
      "mutated_line": "x = -1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = -1\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 1\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k < 3:",
      "mutated_line": "if k <= 3:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k <= 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k < 3:",
      "mutated_line": "if k >= 3:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k >= 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k < 3:",
      "mutated_line": "if k != 3:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k != 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return 2",
      "mutated_line": "return 3",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 3"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return 2",
      "mutated_line": "return 0",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 1"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return 2",
      "mutated_line": "return -2",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return -2"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "x += 1",
      "mutated_line": "x -= 1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x -= 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k < 3:",
      "mutated_line": "if k < 4:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 4:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k < 3:",
      "mutated_line": "if k < 2:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 2:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k < 3:",
      "mutated_line": "if k < 0:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 0:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k < 3:",
      "mutated_line": "if k < 1:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 1:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k < 3:",
      "mutated_line": "if k < -3:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < -3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return +1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d = [1] * k",
      "mutated_line": "d = [1] / k",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] / k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d = [1] * k",
      "mutated_line": "d = [1] + k",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] + k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d = [1] * k",
      "mutated_line": "d = [1] ** k",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] ** k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[j] = 0",
      "mutated_line": "d[j] = 1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 1\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[j] = 0",
      "mutated_line": "d[j] = -1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = -1\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[j] = 0",
      "mutated_line": "d[j] = 1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 1\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if 1 in d:",
      "mutated_line": "if 1 not in d:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 not in d:\n            return 1\n    return 2"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if paper[i][j] != '#':",
      "mutated_line": "if paper[i][j] == '#':",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] == '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if (i, j - 1) in s:",
      "mutated_line": "if (i, j - 1) not in s:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) not in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (i - 1, j) in s:",
      "mutated_line": "if (i - 1, j) not in s:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) not in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x += 1",
      "mutated_line": "x += 2",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 2\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x += 1",
      "mutated_line": "x += 0",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 0\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x += 1",
      "mutated_line": "x += 0",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 0\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "x += 1",
      "mutated_line": "x += -1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += -1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -2\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -0\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -0\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return --1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[node] = 0",
      "mutated_line": "d[node] = 1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 1\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[node] = 0",
      "mutated_line": "d[node] = -1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = -1\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[node] = 0",
      "mutated_line": "d[node] = 1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 1\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 1 in d:",
      "mutated_line": "if 2 in d:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 2 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 1 in d:",
      "mutated_line": "if 0 in d:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 0 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 1 in d:",
      "mutated_line": "if 0 in d:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 0 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if 1 in d:",
      "mutated_line": "if -1 in d:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if -1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 2\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 0\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 0\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return -1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if paper[i][j] != '#':",
      "mutated_line": "if paper[i][j] != '':",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d = [1] * k",
      "mutated_line": "d = [2] * k",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [2] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d = [1] * k",
      "mutated_line": "d = [0] * k",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [0] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d = [1] * k",
      "mutated_line": "d = [0] * k",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [0] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d = [1] * k",
      "mutated_line": "d = [-1] * k",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [-1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "stack = [p[j][0]]",
      "mutated_line": "stack = [p[j][1]]",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][1]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "stack = [p[j][0]]",
      "mutated_line": "stack = [p[j][-1]]",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][-1]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "stack = [p[j][0]]",
      "mutated_line": "stack = [p[j][1]]",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][1]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if (i, j - 1) in s:",
      "mutated_line": "if (i, j + 1) in s:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j + 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if (i, j - 1) in s:",
      "mutated_line": "if (i, j * 1) in s:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j * 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "p[x].append(x - 1)",
      "mutated_line": "p[x].append(x + 1)",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x + 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "p[x].append(x - 1)",
      "mutated_line": "p[x].append(x * 1)",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x * 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i - 1, j) in s:",
      "mutated_line": "if (i + 1, j) in s:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i + 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (i - 1, j) in s:",
      "mutated_line": "if (i * 1, j) in s:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i * 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (i, j - 1) in s:",
      "mutated_line": "if (i, j - 2) in s:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 2) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (i, j - 1) in s:",
      "mutated_line": "if (i, j - 0) in s:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 0) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (i, j - 1) in s:",
      "mutated_line": "if (i, j - 0) in s:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 0) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if (i, j - 1) in s:",
      "mutated_line": "if (i, j - -1) in s:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - -1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p[x].append(x - 1)",
      "mutated_line": "p[x].append(x - 2)",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 2)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p[x].append(x - 1)",
      "mutated_line": "p[x].append(x - 0)",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 0)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p[x].append(x - 1)",
      "mutated_line": "p[x].append(x - 0)",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 0)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p[x].append(x - 1)",
      "mutated_line": "p[x].append(x - -1)",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - -1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i - 1, j) in s:",
      "mutated_line": "if (i - 2, j) in s:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 2, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i - 1, j) in s:",
      "mutated_line": "if (i - 0, j) in s:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 0, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i - 1, j) in s:",
      "mutated_line": "if (i - 0, j) in s:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 0, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (i - 1, j) in s:",
      "mutated_line": "if (i - -1, j) in s:",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - -1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "y = s[(i - 1, j)]",
      "mutated_line": "y = s[i + 1, j]",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i + 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "y = s[(i - 1, j)]",
      "mutated_line": "y = s[i * 1, j]",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i * 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "p[x - 1].append(x)",
      "mutated_line": "p[x + 1].append(x)",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x + 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "p[x - 1].append(x)",
      "mutated_line": "p[x * 1].append(x)",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x * 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y = s[(i - 1, j)]",
      "mutated_line": "y = s[i - 2, j]",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 2, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y = s[(i - 1, j)]",
      "mutated_line": "y = s[i - 0, j]",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 0, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y = s[(i - 1, j)]",
      "mutated_line": "y = s[i - 0, j]",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 0, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "y = s[(i - 1, j)]",
      "mutated_line": "y = s[i - -1, j]",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - -1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p[x - 1].append(x)",
      "mutated_line": "p[x - 2].append(x)",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 2].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p[x - 1].append(x)",
      "mutated_line": "p[x - 0].append(x)",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 0].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p[x - 1].append(x)",
      "mutated_line": "p[x - 0].append(x)",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - 0].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p[x - 1].append(x)",
      "mutated_line": "p[x - -1].append(x)",
      "code": "def min_squares_to_disconnect(n, m, paper):\n    p = []\n    s = {}\n    x = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] != '#':\n                continue\n            s[i, j] = x\n            p.append([])\n            if (i, j - 1) in s:\n                p[x].append(x - 1)\n                p[x - -1].append(x)\n            if (i - 1, j) in s:\n                y = s[i - 1, j]\n                p[x].append(y)\n                p[y].append(x)\n            x += 1\n    k = len(p)\n    if k < 3:\n        return -1\n    for j in range(k):\n        d = [1] * k\n        d[j] = 0\n        stack = [p[j][0]]\n        while stack:\n            node = stack.pop()\n            if not d[node]:\n                continue\n            d[node] = 0\n            for neighbor in p[node]:\n                if d[neighbor]:\n                    stack.append(neighbor)\n        if 1 in d:\n            return 1\n    return 2"
    }
  ]
}