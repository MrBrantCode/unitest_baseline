{
  "task_id": "taco_12668",
  "entry_point": "least_interval",
  "mutant_count": 40,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "time = 0",
      "mutated_line": "time = 1",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 1\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "time = 0",
      "mutated_line": "time = -1",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = -1\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "time = 0",
      "mutated_line": "time = 1",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 1\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if task in dic:",
      "mutated_line": "if task not in dic:",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task not in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "dic[task] += 1",
      "mutated_line": "dic[task] -= 1",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] -= 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "time += 1",
      "mutated_line": "time -= 1",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time -= 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dic[task] += 1",
      "mutated_line": "dic[task] += 2",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 2\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dic[task] += 1",
      "mutated_line": "dic[task] += 0",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 0\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dic[task] += 1",
      "mutated_line": "dic[task] += 0",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 0\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dic[task] += 1",
      "mutated_line": "dic[task] += -1",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += -1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dic[task] = 1",
      "mutated_line": "dic[task] = 2",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 2\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dic[task] = 1",
      "mutated_line": "dic[task] = 0",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 0\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dic[task] = 1",
      "mutated_line": "dic[task] = 0",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 0\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dic[task] = 1",
      "mutated_line": "dic[task] = -1",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = -1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for _ in range(K + 1):",
      "mutated_line": "for _ in range(K - 1):",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K - 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for _ in range(K + 1):",
      "mutated_line": "for _ in range(K * 1):",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K * 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "time += 1",
      "mutated_line": "time += 2",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 2\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "time += 1",
      "mutated_line": "time += 0",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 0\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "time += 1",
      "mutated_line": "time += 0",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 0\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "time += 1",
      "mutated_line": "time += -1",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += -1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if not heap and not temp:",
      "mutated_line": "if not heap or not temp:",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap or not temp:\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "heapq.heappush(heap, [-count, task])",
      "mutated_line": "heapq.heappush(heap, [+count, task])",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [+count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for _ in range(K + 1):",
      "mutated_line": "for _ in range(K + 2):",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 2):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for _ in range(K + 1):",
      "mutated_line": "for _ in range(K + 0):",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 0):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for _ in range(K + 1):",
      "mutated_line": "for _ in range(K + 0):",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 0):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for _ in range(K + 1):",
      "mutated_line": "for _ in range(K + -1):",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + -1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if count < -1:",
      "mutated_line": "if count <= -1:",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count <= -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if count < -1:",
      "mutated_line": "if count >= -1:",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count >= -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if count < -1:",
      "mutated_line": "if count != -1:",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count != -1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "if count < -1:",
      "mutated_line": "if count < +1:",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < +1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if count < -1:",
      "mutated_line": "if count < -2:",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -2:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if count < -1:",
      "mutated_line": "if count < -0:",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -0:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if count < -1:",
      "mutated_line": "if count < -0:",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -0:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if count < -1:",
      "mutated_line": "if count < --1:",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < --1:\n                    temp.append([count + 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "temp.append([count + 1, task])",
      "mutated_line": "temp.append([count - 1, task])",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count - 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "temp.append([count + 1, task])",
      "mutated_line": "temp.append([count * 1, task])",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count * 1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "temp.append([count + 1, task])",
      "mutated_line": "temp.append([count + 2, task])",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 2, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "temp.append([count + 1, task])",
      "mutated_line": "temp.append([count + 0, task])",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 0, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "temp.append([count + 1, task])",
      "mutated_line": "temp.append([count + 0, task])",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + 0, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "temp.append([count + 1, task])",
      "mutated_line": "temp.append([count + -1, task])",
      "code": "import heapq\n\ndef least_interval(N, K, tasks):\n    dic = {}\n    for task in tasks:\n        if task in dic:\n            dic[task] += 1\n        else:\n            dic[task] = 1\n    heap = []\n    for (task, count) in dic.items():\n        heapq.heappush(heap, [-count, task])\n    time = 0\n    while heap:\n        temp = []\n        for _ in range(K + 1):\n            if heap:\n                (count, task) = heapq.heappop(heap)\n                if count < -1:\n                    temp.append([count + -1, task])\n            time += 1\n            if not heap and (not temp):\n                break\n        for item in temp:\n            heapq.heappush(heap, item)\n    return time"
    }
  ]
}