{
  "task_id": "taco_8686",
  "entry_point": "calculate_probability",
  "mutant_count": 164,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "p /= 100",
      "mutated_line": "p *= 100",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p *= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "d = 0",
      "mutated_line": "for (k_val, p) in enumerate(r):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 1\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "d = 0",
      "mutated_line": "for (k_val, p) in enumerate(r):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = -1\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "d = 0",
      "mutated_line": "for (k_val, p) in enumerate(r):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 1\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "m = ai.count(-1)",
      "mutated_line": "m = ai.count(+1)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(+1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = {(0, min(k, m)): 1}",
      "mutated_line": "x = {(0, min(k, m)): 2}",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 2}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = {(0, min(k, m)): 1}",
      "mutated_line": "x = {(0, min(k, m)): 0}",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 0}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = {(0, min(k, m)): 1}",
      "mutated_line": "x = {(0, min(k, m)): 0}",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 0}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = {(0, min(k, m)): 1}",
      "mutated_line": "x = {(0, min(k, m)): -1}",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): -1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "r = [1]",
      "mutated_line": "r = [2]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [2]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "r = [1]",
      "mutated_line": "r = [0]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [0]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "r = [1]",
      "mutated_line": "r = [0]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [0]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "r = [1]",
      "mutated_line": "r = [-1]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [-1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "p /= 100",
      "mutated_line": "p /= 101",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 101\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "p /= 100",
      "mutated_line": "p /= 99",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 99\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "p /= 100",
      "mutated_line": "p /= 0",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 0\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "p /= 100",
      "mutated_line": "p /= 1",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 1\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "p /= 100",
      "mutated_line": "p /= -100",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= -100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if s > 0:",
      "mutated_line": "if s >= 0:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s >= 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if s > 0:",
      "mutated_line": "if s <= 0:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s <= 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if s > 0:",
      "mutated_line": "if s != 0:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s != 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] / (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] + (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] ** (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k_val + a >= l:",
      "mutated_line": "if k_val + a > l:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a > l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k_val + a >= l:",
      "mutated_line": "if k_val + a < l:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a < l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k_val + a >= l:",
      "mutated_line": "if k_val + a == l:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a == l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for k_val in range(n - m, -1, -1):",
      "mutated_line": "for k_val in range(n + m, -1, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n + m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for k_val in range(n - m, -1, -1):",
      "mutated_line": "for k_val in range(n * m, -1, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n * m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "for k_val in range(n - m, -1, -1):",
      "mutated_line": "for k_val in range(n - m, +1, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, +1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "for k_val in range(n - m, -1, -1):",
      "mutated_line": "for k_val in range(n - m, -1, +1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, +1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "y[k_val][a - 1] += y[k_val][a]",
      "mutated_line": "y[k_val][a - 1] -= y[k_val][a]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] -= y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for k_val in range(n - m, 0, -1):",
      "mutated_line": "for k_val in range(n + m, 0, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n + m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for k_val in range(n - m, 0, -1):",
      "mutated_line": "for k_val in range(n * m, 0, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n * m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k_val in range(n - m, 0, -1):",
      "mutated_line": "for k_val in range(n - m, 1, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 1, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k_val in range(n - m, 0, -1):",
      "mutated_line": "for k_val in range(n - m, -1, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k_val in range(n - m, 0, -1):",
      "mutated_line": "for k_val in range(n - m, 1, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 1, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "for k_val in range(n - m, 0, -1):",
      "mutated_line": "for k_val in range(n - m, 0, +1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, +1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "y[k_val - 1][a] += y[k_val][a]",
      "mutated_line": "y[k_val - 1][a] -= y[k_val][a]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] -= y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if l - k_val <= n - m:",
      "mutated_line": "if l - k_val < n - m:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val < n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if l - k_val <= n - m:",
      "mutated_line": "if l - k_val > n - m:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val > n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if l - k_val <= n - m:",
      "mutated_line": "if l - k_val == n - m:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val == n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "d += y[max(0, l - k_val)][k_val] * p",
      "mutated_line": "d -= y[max(0, l - k_val)][k_val] * p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d -= y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m = ai.count(-1)",
      "mutated_line": "m = ai.count(-2)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-2)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m = ai.count(-1)",
      "mutated_line": "m = ai.count(-0)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-0)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m = ai.count(-1)",
      "mutated_line": "m = ai.count(-0)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-0)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m = ai.count(-1)",
      "mutated_line": "m = ai.count(--1)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(--1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = {(0, min(k, m)): 1}",
      "mutated_line": "x = {(1, min(k, m)): 1}",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(1, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = {(0, min(k, m)): 1}",
      "mutated_line": "x = {(-1, min(k, m)): 1}",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(-1, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = {(0, min(k, m)): 1}",
      "mutated_line": "x = {(1, min(k, m)): 1}",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(1, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if s > 0:",
      "mutated_line": "if s > 1:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 1:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if s > 0:",
      "mutated_line": "if s > -1:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > -1:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if s > 0:",
      "mutated_line": "if s > 1:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 1:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "y[k_val, a] += q - q * p",
      "mutated_line": "y[k_val, a] -= q - q * p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] -= q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "y[k_val, a] += q * p",
      "mutated_line": "y[k_val, a] -= q * p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] -= q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "i = [0] + [q * p for q in r]",
      "mutated_line": "i = [0] - [q * p for q in r]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] - [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "i = [0] + [q * p for q in r]",
      "mutated_line": "i = [0] * [q * p for q in r]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] * [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "j = [q - q * p for q in r] + [0]",
      "mutated_line": "j = [q - q * p for q in r] - [0]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] - [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "j = [q - q * p for q in r] + [0]",
      "mutated_line": "j = [q - q * p for q in r] * [0]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] * [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m - 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m * 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if k_val + a >= l:",
      "mutated_line": "if k_val - a >= l:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val - a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if k_val + a >= l:",
      "mutated_line": "if k_val * a >= l:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val * a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for k_val in range(n - m, -1, -1):",
      "mutated_line": "for k_val in range(n - m, -2, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -2, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for k_val in range(n - m, -1, -1):",
      "mutated_line": "for k_val in range(n - m, -0, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -0, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for k_val in range(n - m, -1, -1):",
      "mutated_line": "for k_val in range(n - m, -0, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -0, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for k_val in range(n - m, -1, -1):",
      "mutated_line": "for k_val in range(n - m, --1, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, --1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for k_val in range(n - m, -1, -1):",
      "mutated_line": "for k_val in range(n - m, -1, -2):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -2):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for k_val in range(n - m, -1, -1):",
      "mutated_line": "for k_val in range(n - m, -1, -0):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -0):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for k_val in range(n - m, -1, -1):",
      "mutated_line": "for k_val in range(n - m, -1, -0):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -0):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for k_val in range(n - m, -1, -1):",
      "mutated_line": "for k_val in range(n - m, -1, --1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, --1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for a in range(m, 0, -1):",
      "mutated_line": "for a in range(m, 1, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 1, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for a in range(m, 0, -1):",
      "mutated_line": "for a in range(m, -1, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, -1, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for a in range(m, 0, -1):",
      "mutated_line": "for a in range(m, 1, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 1, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "for a in range(m, 0, -1):",
      "mutated_line": "for a in range(m, 0, +1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, +1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k_val in range(n - m, 0, -1):",
      "mutated_line": "for k_val in range(n - m, 0, -2):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -2):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k_val in range(n - m, 0, -1):",
      "mutated_line": "for k_val in range(n - m, 0, -0):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -0):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k_val in range(n - m, 0, -1):",
      "mutated_line": "for k_val in range(n - m, 0, -0):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -0):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for k_val in range(n - m, 0, -1):",
      "mutated_line": "for k_val in range(n - m, 0, --1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, --1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "for a in range(m, -1, -1):",
      "mutated_line": "for a in range(m, +1, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, +1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "for a in range(m, -1, -1):",
      "mutated_line": "for a in range(m, -1, +1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, +1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if l - k_val <= n - m:",
      "mutated_line": "if l + k_val <= n - m:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l + k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if l - k_val <= n - m:",
      "mutated_line": "if l * k_val <= n - m:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l * k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if l - k_val <= n - m:",
      "mutated_line": "if l - k_val <= n + m:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n + m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if l - k_val <= n - m:",
      "mutated_line": "if l - k_val <= n * m:",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n * m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "d += y[max(0, l - k_val)][k_val] * p",
      "mutated_line": "d += y[max(0, l - k_val)][k_val] / p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] / p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "d += y[max(0, l - k_val)][k_val] * p",
      "mutated_line": "d += y[max(0, l - k_val)][k_val] + p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] + p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "d += y[max(0, l - k_val)][k_val] * p",
      "mutated_line": "d += y[max(0, l - k_val)][k_val] ** p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] ** p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y[k_val, a] += q - q * p",
      "mutated_line": "y[k_val, a] += q + q * p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q + q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y[k_val, a] += q - q * p",
      "mutated_line": "y[k_val, a] += q * (q * p)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q * (q * p)\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "y[k_val, a] += q * p",
      "mutated_line": "y[k_val, a] += q / p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q / p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "y[k_val, a] += q * p",
      "mutated_line": "y[k_val, a] += q + p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q + p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "y[k_val, a] += q * p",
      "mutated_line": "y[k_val, a] += q ** p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q ** p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = [a + b for a, b in zip(i, j)]",
      "mutated_line": "r = [a - b for (a, b) in zip(i, j)]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a - b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = [a + b for a, b in zip(i, j)]",
      "mutated_line": "r = [a * b for (a, b) in zip(i, j)]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a * b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[1] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[-1] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[1] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 2) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 0) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 0) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + -1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m - 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range((n - m) * 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for a in range(m, 0, -1):",
      "mutated_line": "for a in range(m, 0, -2):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -2):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for a in range(m, 0, -1):",
      "mutated_line": "for a in range(m, 0, -0):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -0):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for a in range(m, 0, -1):",
      "mutated_line": "for a in range(m, 0, -0):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -0):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for a in range(m, 0, -1):",
      "mutated_line": "for a in range(m, 0, --1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, --1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y[k_val][a - 1] += y[k_val][a]",
      "mutated_line": "y[k_val][a + 1] += y[k_val][a]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a + 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "y[k_val][a - 1] += y[k_val][a]",
      "mutated_line": "y[k_val][a * 1] += y[k_val][a]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a * 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a in range(m, -1, -1):",
      "mutated_line": "for a in range(m, -2, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -2, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a in range(m, -1, -1):",
      "mutated_line": "for a in range(m, -0, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -0, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a in range(m, -1, -1):",
      "mutated_line": "for a in range(m, -0, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -0, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a in range(m, -1, -1):",
      "mutated_line": "for a in range(m, --1, -1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, --1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a in range(m, -1, -1):",
      "mutated_line": "for a in range(m, -1, -2):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -2):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a in range(m, -1, -1):",
      "mutated_line": "for a in range(m, -1, -0):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -0):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a in range(m, -1, -1):",
      "mutated_line": "for a in range(m, -1, -0):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -0):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for a in range(m, -1, -1):",
      "mutated_line": "for a in range(m, -1, --1):",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, --1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y[k_val, a] += q - q * p",
      "mutated_line": "y[k_val, a] += q - q / p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q / p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y[k_val, a] += q - q * p",
      "mutated_line": "y[k_val, a] += q - (q + p)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - (q + p)\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "y[k_val, a] += q - q * p",
      "mutated_line": "y[k_val, a] += q - q ** p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q ** p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "a = min(m, a + s)",
      "mutated_line": "a = min(m, a - s)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a - s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "a = min(m, a + s)",
      "mutated_line": "a = min(m, a * s)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a * s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "k_val = min(l, k_val + 1)",
      "mutated_line": "k_val = min(l, k_val - 1)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val - 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "k_val = min(l, k_val + 1)",
      "mutated_line": "k_val = min(l, k_val * 1)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val * 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = [0] + [q * p for q in r]",
      "mutated_line": "i = [1] + [q * p for q in r]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [1] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = [0] + [q * p for q in r]",
      "mutated_line": "i = [-1] + [q * p for q in r]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [-1] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = [0] + [q * p for q in r]",
      "mutated_line": "i = [1] + [q * p for q in r]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [1] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "i = [0] + [q * p for q in r]",
      "mutated_line": "i = [0] + [q / p for q in r]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q / p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "i = [0] + [q * p for q in r]",
      "mutated_line": "i = [0] + [q + p for q in r]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q + p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "i = [0] + [q * p for q in r]",
      "mutated_line": "i = [0] + [q ** p for q in r]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q ** p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "j = [q - q * p for q in r] + [0]",
      "mutated_line": "j = [q + q * p for q in r] + [0]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q + q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "j = [q - q * p for q in r] + [0]",
      "mutated_line": "j = [q * (q * p) for q in r] + [0]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q * (q * p) for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "j = [q - q * p for q in r] + [0]",
      "mutated_line": "j = [q - q * p for q in r] + [1]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [1]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "j = [q - q * p for q in r] + [0]",
      "mutated_line": "j = [q - q * p for q in r] + [-1]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [-1]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "j = [q - q * p for q in r] + [0]",
      "mutated_line": "j = [q - q * p for q in r] + [1]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [1]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n + m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n * m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 2)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 0)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 0)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "y = [[0] * (m + 1) for _ in range(n - m + 1)]",
      "mutated_line": "for ((k_val, a), q) in x.items():",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + -1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "y[k_val][a - 1] += y[k_val][a]",
      "mutated_line": "y[k_val][a - 2] += y[k_val][a]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 2] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "y[k_val][a - 1] += y[k_val][a]",
      "mutated_line": "y[k_val][a - 0] += y[k_val][a]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 0] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "y[k_val][a - 1] += y[k_val][a]",
      "mutated_line": "y[k_val][a - 0] += y[k_val][a]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 0] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "y[k_val][a - 1] += y[k_val][a]",
      "mutated_line": "y[k_val][a - -1] += y[k_val][a]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - -1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "y[k_val - 1][a] += y[k_val][a]",
      "mutated_line": "y[k_val + 1][a] += y[k_val][a]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val + 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "y[k_val - 1][a] += y[k_val][a]",
      "mutated_line": "y[k_val * 1][a] += y[k_val][a]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val * 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k_val = min(l, k_val + 1)",
      "mutated_line": "k_val = min(l, k_val + 2)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 2)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k_val = min(l, k_val + 1)",
      "mutated_line": "k_val = min(l, k_val + 0)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 0)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k_val = min(l, k_val + 1)",
      "mutated_line": "k_val = min(l, k_val + 0)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 0)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k_val = min(l, k_val + 1)",
      "mutated_line": "k_val = min(l, k_val + -1)",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + -1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "j = [q - q * p for q in r] + [0]",
      "mutated_line": "j = [q - q / p for q in r] + [0]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q / p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "j = [q - q * p for q in r] + [0]",
      "mutated_line": "j = [q - (q + p) for q in r] + [0]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - (q + p) for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "j = [q - q * p for q in r] + [0]",
      "mutated_line": "j = [q - q ** p for q in r] + [0]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q ** p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "y[k_val - 1][a] += y[k_val][a]",
      "mutated_line": "y[k_val - 2][a] += y[k_val][a]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 2][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "y[k_val - 1][a] += y[k_val][a]",
      "mutated_line": "y[k_val - 0][a] += y[k_val][a]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 0][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "y[k_val - 1][a] += y[k_val][a]",
      "mutated_line": "y[k_val - 0][a] += y[k_val][a]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 0][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "y[k_val - 1][a] += y[k_val][a]",
      "mutated_line": "y[k_val - -1][a] += y[k_val][a]",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - -1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d += y[max(0, l - k_val)][k_val] * p",
      "mutated_line": "d += y[max(1, l - k_val)][k_val] * p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(1, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d += y[max(0, l - k_val)][k_val] * p",
      "mutated_line": "d += y[max(-1, l - k_val)][k_val] * p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(-1, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d += y[max(0, l - k_val)][k_val] * p",
      "mutated_line": "d += y[max(1, l - k_val)][k_val] * p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(1, l - k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "d += y[max(0, l - k_val)][k_val] * p",
      "mutated_line": "d += y[max(0, l + k_val)][k_val] * p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l + k_val)][k_val] * p\n    return d"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "d += y[max(0, l - k_val)][k_val] * p",
      "mutated_line": "d += y[max(0, l * k_val)][k_val] * p",
      "code": "from collections import defaultdict\n\ndef calculate_probability(n, l, k, pi, ai):\n    m = ai.count(-1)\n    x = {(0, min(k, m)): 1}\n    r = [1]\n    for (p, s) in zip(pi, ai):\n        p /= 100\n        if s > 0:\n            y = defaultdict(int)\n            for ((k_val, a), q) in x.items():\n                y[k_val, a] += q - q * p\n                a = min(m, a + s)\n                k_val = min(l, k_val + 1)\n                y[k_val, a] += q * p\n            x = y\n        else:\n            i = [0] + [q * p for q in r]\n            j = [q - q * p for q in r] + [0]\n            r = [a + b for (a, b) in zip(i, j)]\n    y = [[0] * (m + 1) for _ in range(n - m + 1)]\n    for ((k_val, a), q) in x.items():\n        if k_val + a >= l:\n            y[k_val][a] = q\n    for k_val in range(n - m, -1, -1):\n        for a in range(m, 0, -1):\n            y[k_val][a - 1] += y[k_val][a]\n    for k_val in range(n - m, 0, -1):\n        for a in range(m, -1, -1):\n            y[k_val - 1][a] += y[k_val][a]\n    d = 0\n    for (k_val, p) in enumerate(r):\n        if l - k_val <= n - m:\n            d += y[max(0, l * k_val)][k_val] * p\n    return d"
    }
  ]
}