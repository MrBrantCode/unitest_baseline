{
  "task_id": "taco_13563",
  "entry_point": "can_reach_target",
  "mutant_count": 44,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] / (n + 1)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] / (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] + (n + 1)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] + (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] ** (n + 1)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] ** (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "used[b] = True",
      "mutated_line": "used[b] = False",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = False\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] / (n + 1)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] / (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] + (n + 1)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] + (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] ** (n + 1)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] ** (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "found = False",
      "mutated_line": "found = True",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = True\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n - 1)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n - 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n * 1)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n * 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "used[v] = True",
      "mutated_line": "used[v] = False",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = False\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n - 1)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n - 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n * 1)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n * 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "used[v] = True",
      "mutated_line": "used[v] = False",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = False\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if v != b and wei in startset:",
      "mutated_line": "if v != b or wei in startset:",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b or wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return 'YES' if found else 'NO'",
      "mutated_line": "return '' if found else 'NO'",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return '' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return 'YES' if found else 'NO'",
      "mutated_line": "return 'YES' if found else ''",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else ''"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [True] * (n + 1)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [True] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + 2)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 2)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + 0)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 0)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + 0)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 0)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + -1)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + -1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [True] * (n + 1)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [True] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + 2)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 2)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + 0)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 0)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + 0)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 0)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "used = [False] * (n + 1)",
      "mutated_line": "used = [False] * (n + -1)",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + -1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if v != b and wei in startset:",
      "mutated_line": "if v == b and wei in startset:",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v == b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if v != b and wei in startset:",
      "mutated_line": "if v != b and wei not in startset:",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei not in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "found = True",
      "mutated_line": "found = False",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = False\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n - 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n * 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "stack = deque([(a, 0)])",
      "mutated_line": "stack = deque([(a, 1)])",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 1)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "stack = deque([(a, 0)])",
      "mutated_line": "stack = deque([(a, -1)])",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, -1)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "stack = deque([(a, 0)])",
      "mutated_line": "stack = deque([(a, 1)])",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 1)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "stack = deque([(b, 0)])",
      "mutated_line": "stack = deque([(b, 1)])",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 1)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "stack = deque([(b, 0)])",
      "mutated_line": "stack = deque([(b, -1)])",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, -1)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "stack = deque([(b, 0)])",
      "mutated_line": "stack = deque([(b, 1)])",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 1)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 2)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 0)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 0)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v, w) in edges:",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + -1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stack.append((n_node, wei ^ w))",
      "mutated_line": "stack.append((n_node, wei | w))",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei | w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    return 'YES' if found else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "stack.append((n_node, wei ^ w))",
      "mutated_line": "stack.append((n_node, wei | w))",
      "code": "def can_reach_target(n, a, b, edges):\n    from collections import deque\n    g = [[] for _ in range(n + 1)]\n    for (u, v, w) in edges:\n        g[u].append((v, w))\n        g[v].append((u, w))\n    startset = set()\n    used = [False] * (n + 1)\n    used[b] = True\n    stack = deque([(a, 0)])\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        startset.add(wei)\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei ^ w))\n    used = [False] * (n + 1)\n    stack = deque([(b, 0)])\n    found = False\n    while stack:\n        (v, wei) = stack.pop()\n        used[v] = True\n        if v != b and wei in startset:\n            found = True\n            break\n        for (n_node, w) in g[v]:\n            if not used[n_node]:\n                stack.append((n_node, wei | w))\n    return 'YES' if found else 'NO'"
    }
  ]
}