{
  "task_id": "taco_16947",
  "entry_point": "calculate_shortest_steps",
  "mutant_count": 66,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [-1] / N",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] / N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [-1] + N",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] + N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [-1] ** N",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] ** N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 1\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = -1",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = -1\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 1\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dist_from_0 = bfs(0)",
      "mutated_line": "dist_from_0 = bfs(1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(1)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dist_from_0 = bfs(0)",
      "mutated_line": "dist_from_0 = bfs(-1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(-1)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dist_from_0 = bfs(0)",
      "mutated_line": "dist_from_0 = bfs(1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(1)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v + 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v + 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v * 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v * 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u + 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u + 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u * 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u * 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(2 * (N - 1) + max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) + max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(2 * (N - 1) * max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) * max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 2)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 2)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 0)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 0)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 0)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 0)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - -1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - -1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 2)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 2)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 0)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 0)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 0)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 0)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - -1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - -1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [+1] * N",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [+1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if dist[i] == -1:",
      "mutated_line": "if dist[i] != -1:",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] != -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(2 / (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 / (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(2 + (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 + (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(2 ** (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 ** (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u + 1].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u + 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u * 1].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u * 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v + 1].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v + 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v * 1].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v * 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [-2] * N",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-2] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [-0] * N",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-0] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [-0] * N",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-0] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [--1] * N",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [--1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "if dist[i] == -1:",
      "mutated_line": "if dist[i] == +1:",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == +1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dist[i] = dist[tmp] + 1",
      "mutated_line": "dist[i] = dist[tmp] - 1",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] - 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dist[i] = dist[tmp] + 1",
      "mutated_line": "dist[i] = dist[tmp] * 1",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] * 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(3 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(3 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(1 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(1 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(0 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(0 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(1 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(1 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(-2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(-2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(2 * (N + 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N + 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(2 * (N * 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N * 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 2].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 2].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 0].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 0].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 0].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 0].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - -1].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - -1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 2].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 2].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 0].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 0].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 0].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 0].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - -1].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - -1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dist[i] == -1:",
      "mutated_line": "if dist[i] == -2:",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -2:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dist[i] == -1:",
      "mutated_line": "if dist[i] == -0:",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -0:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dist[i] == -1:",
      "mutated_line": "if dist[i] == -0:",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -0:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dist[i] == -1:",
      "mutated_line": "if dist[i] == --1:",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == --1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist[i] = dist[tmp] + 1",
      "mutated_line": "dist[i] = dist[tmp] + 2",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 2\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist[i] = dist[tmp] + 1",
      "mutated_line": "dist[i] = dist[tmp] + 0",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 0\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist[i] = dist[tmp] + 1",
      "mutated_line": "dist[i] = dist[tmp] + 0",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 0\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist[i] = dist[tmp] + 1",
      "mutated_line": "dist[i] = dist[tmp] + -1",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + -1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(2 * (N - 2) - max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 2) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(2 * (N - 0) - max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 0) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(2 * (N - 0) - max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - 0) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "result.append(2 * (N - 1) - max(dist_from_start[i], dist_from_goal[i]))",
      "mutated_line": "result.append(2 * (N - -1) - max(dist_from_start[i], dist_from_goal[i]))",
      "code": "from collections import deque\n\ndef calculate_shortest_steps(N, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n\n    def bfs(start):\n        dist = [-1] * N\n        dist[start] = 0\n        que = deque([start])\n        while que:\n            tmp = que.popleft()\n            for i in G[tmp]:\n                if dist[i] == -1:\n                    dist[i] = dist[tmp] + 1\n                    que.append(i)\n        return dist\n    dist_from_0 = bfs(0)\n    start = max(range(N), key=lambda x: dist_from_0[x])\n    dist_from_start = bfs(start)\n    goal = max(range(N), key=lambda x: dist_from_start[x])\n    dist_from_goal = bfs(goal)\n    result = []\n    for i in range(N):\n        result.append(2 * (N - -1) - max(dist_from_start[i], dist_from_goal[i]))\n    return result"
    }
  ]
}