{
  "task_id": "taco_4257",
  "entry_point": "count_distinct_binary_strings",
  "mutant_count": 151,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000008\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000006\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 0\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = -1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if first is None:",
      "mutated_line": "if first is not None:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is not None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dp = [0] * n",
      "mutated_line": "dp = [0] / n",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] / n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dp = [0] * n",
      "mutated_line": "dp = [0] + n",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] + n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dp = [0] * n",
      "mutated_line": "dp = [0] ** n",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] ** n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[first] = 1",
      "mutated_line": "dp[first] = 2",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 2\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[first] = 1",
      "mutated_line": "dp[first] = 0",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 0\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[first] = 1",
      "mutated_line": "dp[first] = 0",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 0\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[first] = 1",
      "mutated_line": "dp[first] = -1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = -1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 1\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = 0",
      "mutated_line": "r = -1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = -1\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 1\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while i < n:",
      "mutated_line": "while i <= n:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i <= n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while i < n:",
      "mutated_line": "while i >= n:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i >= n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while i < n:",
      "mutated_line": "while i != n:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i != n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return r * (first + 1) * (n - last) * MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return r * (first + 1) * (n - last) + MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) + MOD"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if s[i] == 1:",
      "mutated_line": "if s[i] != 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] != 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "j = i + 1",
      "mutated_line": "j = i - 1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i - 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "j = i + 1",
      "mutated_line": "j = i * 1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i * 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "while j < n and s[j] == 0:",
      "mutated_line": "while j < n or s[j] == 0:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n or s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j -= 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "r = (r + dp[i]) % MOD",
      "mutated_line": "r = (r + dp[i]) * MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) * MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "r = (r + dp[i]) % MOD",
      "mutated_line": "r = r + dp[i] + MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = r + dp[i] + MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if j == n:",
      "mutated_line": "if j != n:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j != n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "c = j - i - 1",
      "mutated_line": "c = j - i + 1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i + 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "c = j - i - 1",
      "mutated_line": "c = (j - i) * 1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = (j - i) * 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "add = 0",
      "mutated_line": "add = 1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 1\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "add = 0",
      "mutated_line": "add = -1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = -1\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "add = 0",
      "mutated_line": "add = 1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 1\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) > 0 or st[-1] <= c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 or st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "add += d",
      "mutated_line": "add -= d",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add -= d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 0 or st[-1] == c + 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 or st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return r * (first + 1) / (n - last) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) / (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return (r * (first + 1) + (n - last)) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return (r * (first + 1) + (n - last)) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return (r * (first + 1)) ** (n - last) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return (r * (first + 1)) ** (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if s[i] == 1:",
      "mutated_line": "if s[i] == 2:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 2:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if s[i] == 1:",
      "mutated_line": "if s[i] == 0:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 0:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if s[i] == 1:",
      "mutated_line": "if s[i] == 0:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 0:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if s[i] == 1:",
      "mutated_line": "if s[i] == -1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == -1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp = [0] * n",
      "mutated_line": "dp = [1] * n",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [1] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp = [0] * n",
      "mutated_line": "dp = [-1] * n",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [-1] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp = [0] * n",
      "mutated_line": "dp = [1] * n",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [1] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "j = i + 1",
      "mutated_line": "j = i + 2",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 2\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "j = i + 1",
      "mutated_line": "j = i + 0",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 0\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "j = i + 1",
      "mutated_line": "j = i + 0",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 0\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "j = i + 1",
      "mutated_line": "j = i + -1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + -1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while j < n and s[j] == 0:",
      "mutated_line": "while j <= n and s[j] == 0:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j <= n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while j < n and s[j] == 0:",
      "mutated_line": "while j >= n and s[j] == 0:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j >= n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while j < n and s[j] == 0:",
      "mutated_line": "while j != n and s[j] == 0:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j != n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while j < n and s[j] == 0:",
      "mutated_line": "while j < n and s[j] != 0:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] != 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 2\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 0\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 0\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += -1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "r = (r + dp[i]) % MOD",
      "mutated_line": "r = (r - dp[i]) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r - dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "r = (r + dp[i]) % MOD",
      "mutated_line": "r = r * dp[i] % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = r * dp[i] % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "c = j - i - 1",
      "mutated_line": "c = j + i - 1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j + i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "c = j - i - 1",
      "mutated_line": "c = j * i - 1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j * i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "c = j - i - 1",
      "mutated_line": "c = j - i - 2",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 2\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "c = j - i - 1",
      "mutated_line": "c = j - i - 0",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 0\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "c = j - i - 1",
      "mutated_line": "c = j - i - 0",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 0\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "c = j - i - 1",
      "mutated_line": "c = j - i - -1",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - -1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "st.append(0)",
      "mutated_line": "st.append(1)",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(1)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "st.append(0)",
      "mutated_line": "st.append(-1)",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(-1)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "st.append(0)",
      "mutated_line": "st.append(1)",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(1)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) >= 0 and st[-1] <= c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) >= 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) <= 0 and st[-1] <= c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) <= 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) != 0 and st[-1] <= c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) != 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) > 0 and st[-1] < c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] < c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) > 0 and st[-1] > c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] > c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) > 0 and st[-1] == c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] == c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = (dp[j] + d * (c - v + 1)) * MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) * MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = dp[j] + d * (c - v + 1) + MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = dp[j] + d * (c - v + 1) + MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) >= 0 and st[-1] == c + 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) >= 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) <= 0 and st[-1] == c + 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) <= 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) != 0 and st[-1] == c + 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) != 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 0 and st[-1] != c + 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] != c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stv[-1] = (stv[-1] + add) % MOD",
      "mutated_line": "stv[-1] = (stv[-1] + add) * MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) * MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stv[-1] = (stv[-1] + add) % MOD",
      "mutated_line": "stv[-1] = stv[-1] + add + MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = stv[-1] + add + MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return r / (first + 1) * (n - last) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r / (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return (r + (first + 1)) * (n - last) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return (r + (first + 1)) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return r ** (first + 1) * (n - last) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r ** (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return r * (first + 1) * (n + last) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n + last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return r * (first + 1) * (n * last) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n * last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while j < n and s[j] == 0:",
      "mutated_line": "while j < n and s[j] == 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 1:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while j < n and s[j] == 0:",
      "mutated_line": "while j < n and s[j] == -1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == -1:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while j < n and s[j] == 0:",
      "mutated_line": "while j < n and s[j] == 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 1:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) > 1 and st[-1] <= c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 1 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) > -1 and st[-1] <= c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > -1 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) > 1 and st[-1] <= c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 1 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = (dp[j] - d * (c - v + 1)) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] - d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = dp[j] * (d * (c - v + 1)) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = dp[j] * (d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 1 and st[-1] == c + 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 1 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > -1 and st[-1] == c + 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > -1 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 1 and st[-1] == c + 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 1 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 0 and st[-1] == c - 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c - 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 0 and st[-1] == c * 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c * 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "stv[-1] = (stv[-1] + add) % MOD",
      "mutated_line": "stv[+1] = (stv[-1] + add) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[+1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stv[-1] = (stv[-1] + add) % MOD",
      "mutated_line": "stv[-1] = (stv[-1] - add) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] - add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stv[-1] = (stv[-1] + add) % MOD",
      "mutated_line": "stv[-1] = stv[-1] * add % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = stv[-1] * add % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "st.append(c + 1)",
      "mutated_line": "st.append(c - 1)",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c - 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "st.append(c + 1)",
      "mutated_line": "st.append(c * 1)",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c * 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return r * (first - 1) * (n - last) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first - 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return r * (first * 1) * (n - last) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first * 1) * (n - last) % MOD"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) > 0 and st[+1] <= c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[+1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = (dp[j] + d / (c - v + 1)) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d / (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = (dp[j] + (d + (c - v + 1))) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + (d + (c - v + 1))) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = (dp[j] + d ** (c - v + 1)) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d ** (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 0 and st[+1] == c + 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[+1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 0 and st[-1] == c + 2:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 2:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 0 and st[-1] == c + 0:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 0:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 0 and st[-1] == c + 0:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 0:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 0 and st[-1] == c + -1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + -1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stv[-1] = (stv[-1] + add) % MOD",
      "mutated_line": "stv[-2] = (stv[-1] + add) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-2] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stv[-1] = (stv[-1] + add) % MOD",
      "mutated_line": "stv[-0] = (stv[-1] + add) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-0] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stv[-1] = (stv[-1] + add) % MOD",
      "mutated_line": "stv[-0] = (stv[-1] + add) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-0] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stv[-1] = (stv[-1] + add) % MOD",
      "mutated_line": "stv[--1] = (stv[-1] + add) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[--1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "st.append(c + 1)",
      "mutated_line": "st.append(c + 2)",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 2)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "st.append(c + 1)",
      "mutated_line": "st.append(c + 0)",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 0)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "st.append(c + 1)",
      "mutated_line": "st.append(c + 0)",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 0)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "st.append(c + 1)",
      "mutated_line": "st.append(c + -1)",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + -1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return r * (first + 2) * (n - last) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 2) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return r * (first + 0) * (n - last) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 0) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return r * (first + 0) * (n - last) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 0) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return r * (first + 1) * (n - last) % MOD",
      "mutated_line": "return r * (first + -1) * (n - last) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + -1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) > 0 and st[-2] <= c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-2] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) > 0 and st[-0] <= c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-0] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) > 0 and st[-0] <= c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-0] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while len(st) > 0 and st[-1] <= c:",
      "mutated_line": "while len(st) > 0 and st[--1] <= c:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[--1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = (dp[j] + d * (c - v - 1)) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v - 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = (dp[j] + d * ((c - v) * 1)) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * ((c - v) * 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 0 and st[-2] == c + 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-2] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 0 and st[-0] == c + 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-0] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 0 and st[-0] == c + 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-0] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if len(st) > 0 and st[-1] == c + 1:",
      "mutated_line": "if len(st) > 0 and st[--1] == c + 1:",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[--1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "stv[-1] = (stv[-1] + add) % MOD",
      "mutated_line": "stv[-1] = (stv[+1] + add) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[+1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = (dp[j] + d * (c + v + 1)) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c + v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = (dp[j] + d * (c * v + 1)) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c * v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = (dp[j] + d * (c - v + 2)) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 2)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = (dp[j] + d * (c - v + 0)) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 0)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = (dp[j] + d * (c - v + 0)) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 0)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[j] = (dp[j] + d * (c - v + 1)) % MOD",
      "mutated_line": "dp[j] = (dp[j] + d * (c - v + -1)) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + -1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stv[-1] = (stv[-1] + add) % MOD",
      "mutated_line": "stv[-1] = (stv[-2] + add) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-2] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stv[-1] = (stv[-1] + add) % MOD",
      "mutated_line": "stv[-1] = (stv[-0] + add) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-0] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stv[-1] = (stv[-1] + add) % MOD",
      "mutated_line": "stv[-1] = (stv[-0] + add) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[-0] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stv[-1] = (stv[-1] + add) % MOD",
      "mutated_line": "stv[-1] = (stv[--1] + add) % MOD",
      "code": "def count_distinct_binary_strings(s: str) -> int:\n    MOD = 1000000007\n    s = list(map(int, s))\n    n = len(s)\n    first = None\n    for i in range(n):\n        if s[i] == 1:\n            first = i\n            break\n    if first is None:\n        return n\n    dp = [0] * n\n    dp[first] = 1\n    st = []\n    stv = []\n    r = 0\n    i = first\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == 0:\n            j += 1\n        r = (r + dp[i]) % MOD\n        if j == n:\n            last = i\n            break\n        c = j - i - 1\n        add = 0\n        st.append(0)\n        stv.append(dp[i])\n        while len(st) > 0 and st[-1] <= c:\n            v = st.pop()\n            d = stv.pop()\n            dp[j] = (dp[j] + d * (c - v + 1)) % MOD\n            add += d\n        if len(st) > 0 and st[-1] == c + 1:\n            stv[-1] = (stv[--1] + add) % MOD\n        else:\n            st.append(c + 1)\n            stv.append(add)\n        i = j\n    return r * (first + 1) * (n - last) % MOD"
    }
  ]
}