{
  "task_id": "taco_14299",
  "entry_point": "process_queries",
  "mutant_count": 27,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "results = [-1] * n",
      "mutated_line": "results = [-1] / n",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] / n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "results = [-1] * n",
      "mutated_line": "results = [-1] + n",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] + n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "results = [-1] * n",
      "mutated_line": "results = [-1] ** n",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] ** n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "next_server_free_time = 0",
      "mutated_line": "next_server_free_time = 1",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 1\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "next_server_free_time = 0",
      "mutated_line": "next_server_free_time = -1",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = -1\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "next_server_free_time = 0",
      "mutated_line": "next_server_free_time = 1",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 1\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "next_server_free_time += d",
      "mutated_line": "next_server_free_time -= d",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time -= d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "while queue and next_server_free_time <= t:",
      "mutated_line": "(idx1, d1) = queue.popleft()",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue or next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "next_server_free_time += d1",
      "mutated_line": "next_server_free_time -= d1",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time -= d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if next_server_free_time <= t:",
      "mutated_line": "if next_server_free_time < t:",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time < t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if next_server_free_time <= t:",
      "mutated_line": "if next_server_free_time > t:",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time > t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if next_server_free_time <= t:",
      "mutated_line": "if next_server_free_time == t:",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time == t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "results = [-1] * n",
      "mutated_line": "results = [+1] * n",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [+1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while queue and next_server_free_time <= t:",
      "mutated_line": "(idx1, d1) = queue.popleft()",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time < t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while queue and next_server_free_time <= t:",
      "mutated_line": "(idx1, d1) = queue.popleft()",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time > t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while queue and next_server_free_time <= t:",
      "mutated_line": "(idx1, d1) = queue.popleft()",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time == t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "results[idx] = t + d",
      "mutated_line": "results[idx] = t - d",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t - d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "results[idx] = t + d",
      "mutated_line": "results[idx] = t * d",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t * d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "next_server_free_time = t + d",
      "mutated_line": "next_server_free_time = t - d",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t - d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "next_server_free_time = t + d",
      "mutated_line": "next_server_free_time = t * d",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t * d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif len(queue) < b:",
      "mutated_line": "elif len(queue) <= b:",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) <= b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif len(queue) < b:",
      "mutated_line": "elif len(queue) >= b:",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) >= b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif len(queue) < b:",
      "mutated_line": "elif len(queue) != b:",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) != b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "results = [-1] * n",
      "mutated_line": "results = [-2] * n",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-2] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "results = [-1] * n",
      "mutated_line": "results = [-0] * n",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-0] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "results = [-1] * n",
      "mutated_line": "results = [-0] * n",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [-0] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "results = [-1] * n",
      "mutated_line": "results = [--1] * n",
      "code": "from collections import deque\n\ndef process_queries(n, b, queries):\n    results = [--1] * n\n    next_server_free_time = 0\n    queue = deque()\n    for (idx, (t, d)) in enumerate(queries):\n        while queue and next_server_free_time <= t:\n            (idx1, d1) = queue.popleft()\n            next_server_free_time += d1\n            results[idx1] = next_server_free_time\n        if next_server_free_time <= t:\n            results[idx] = t + d\n            next_server_free_time = t + d\n        elif len(queue) < b:\n            queue.append((idx, d))\n    while queue:\n        (idx, d) = queue.popleft()\n        next_server_free_time += d\n        results[idx] = next_server_free_time\n    return results"
    }
  ]
}