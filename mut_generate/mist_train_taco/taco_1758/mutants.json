{
  "task_id": "taco_1758",
  "entry_point": "calculate_minimum_unfairness",
  "mutant_count": 81,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - 2 * k) / 2",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) / 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - 2 * k) * 2",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) * 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] - a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] - a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = (a[:index] + a[index + 1:index + 2 * k + 1:2]) * a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = (a[:index] + a[index + 1:index + 2 * k + 1:2]) * a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sm = 0",
      "mutated_line": "sm = 1",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 1\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sm = 0",
      "mutated_line": "sm = -1",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = -1\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sm = 0",
      "mutated_line": "sm = 1",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 1\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "k = min(k, n - k)",
      "mutated_line": "k = min(k, n + k)",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n + k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "k = min(k, n - k)",
      "mutated_line": "k = min(k, n * k)",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n * k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n + 2 * k) // 2",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n + 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = n * (2 * k) // 2",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = n * (2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - 2 * k) // 3",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 3\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - 2 * k) // 1",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 1\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - 2 * k) // 0",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 0\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - 2 * k) // 1",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 1\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - 2 * k) // -2",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // -2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] - a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] - a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] * a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] * a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "sm += abs(u - v)",
      "mutated_line": "sm -= abs(u - v)",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm -= abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - 2 / k) // 2",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 / k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - (2 + k)) // 2",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - (2 + k)) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - 2 ** k) // 2",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 ** k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index - 2 * k:2]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index - 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index * (2 * k):2]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index * (2 * k):2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index + 2 * k:3]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:3]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index + 2 * k:1]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:1]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index + 2 * k:0]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:0]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index + 2 * k:1]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:1]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index + 2 * k:-2]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:-2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - 3 * k) // 2",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 3 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - 1 * k) // 2",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 1 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - 0 * k) // 2",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 0 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - 1 * k) // 2",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 1 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "index = (n - 2 * k) // 2",
      "mutated_line": "index = (n - -2 * k) // 2",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - -2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index + 2 / k:2]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 / k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index + (2 + k):2]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + (2 + k):2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index + 2 ** k:2]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 ** k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index - 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index - 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index * (2 * k):]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index * (2 * k):]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sm += abs(u - v)",
      "mutated_line": "sm += abs(u + v)",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u + v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sm += abs(u - v)",
      "mutated_line": "sm += abs(u * v)",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u * v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index + 3 * k:2]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 3 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index + 1 * k:2]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 1 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index + 0 * k:2]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 0 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index + 1 * k:2]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 1 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "I = a[index:index + 2 * k:2]",
      "mutated_line": "I = a[index:index + -2 * k:2]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + -2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index - 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index - 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index * 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index * 1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k - 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k - 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:(index + 2 * k) * 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:(index + 2 * k) * 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:3] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:3] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:1] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:1] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:0] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:0] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:1] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:1] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:-2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:-2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 / k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 / k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + (2 + k):]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + (2 + k):]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 ** k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 ** k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 2:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 2:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 0:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 0:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 0:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 0:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + -1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + -1:index + 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index - 2 * k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index - 2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index * (2 * k) + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index * (2 * k) + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 2:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 2:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 0:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 0:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 0:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 0:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + -1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + -1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 3 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 3 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 1 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 1 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 0 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 0 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 1 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 1 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + -2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + -2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 / k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 / k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + (2 + k) + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + (2 + k) + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 2 ** k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 2 ** k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 3 * k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 3 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 1 * k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 1 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 0 * k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 0 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + 1 * k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + 1 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "J = a[:index] + a[index + 1:index + 2 * k + 1:2] + a[index + 2 * k:]",
      "mutated_line": "J = a[:index] + a[index + 1:index + -2 * k + 1:2] + a[index + 2 * k:]",
      "code": "def calculate_minimum_unfairness(n, k, a):\n\n    def sumup(I, J):\n        sm = 0\n        for u in I:\n            for v in J:\n                sm += abs(u - v)\n        return sm\n    k = min(k, n - k)\n    a.sort()\n    index = (n - 2 * k) // 2\n    I = a[index:index + 2 * k:2]\n    J = a[:index] + a[index + 1:index + -2 * k + 1:2] + a[index + 2 * k:]\n    return sumup(I, J)"
    }
  ]
}