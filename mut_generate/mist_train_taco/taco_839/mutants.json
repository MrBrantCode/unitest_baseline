{
  "task_id": "taco_839",
  "entry_point": "find_shortest_safe_path",
  "mutant_count": 144,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 0 and i >= n and (j < 0) and (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 and i >= n and (j < 0) and (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if out_of_bounds(i, j) or matrix[i][j] == 0:",
      "mutated_line": "if out_of_bounds(i, j) and matrix[i][j] == 0:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) and matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return False\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if memo[i][j] != -1 and memo[i][j] != float('inf'):",
      "mutated_line": "if memo[i][j] != -1 or memo[i][j] != float('inf'):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 or memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if j == m - 1:",
      "mutated_line": "if j != m - 1:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j != m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "min_ = float('inf')",
      "mutated_line": "min_ = float('')",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "return -1 if min_ == float('inf') else min_",
      "mutated_line": "return -1 if min_ != float('inf') else min_",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ != float('inf') else min_"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "return -1 if min_ == float('inf') else min_",
      "mutated_line": "return +1 if min_ == float('inf') else min_",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return +1 if min_ == float('inf') else min_"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(+1, 0), (0, 1), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(+1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 1), (0, 1), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 1), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, -1), (0, 1), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, -1), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 1), (0, 1), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 1), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (1, 1), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (1, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (-1, 1), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (-1, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (1, 1), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (1, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 2), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 2), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 0), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 0), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 0), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 0), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, -1), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, -1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (2, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (2, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (0, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (0, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (0, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (0, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (-1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (1, 1), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 1), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (1, -1), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, -1), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (1, 1), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 1), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (1, 0), (1, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (1, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (1, 0), (-1, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (-1, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (1, 0), (1, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (1, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, +1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, +1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i <= 0 or i >= n or j < 0 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i <= 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i >= 0 or i >= n or j < 0 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i >= 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i != 0 or i >= n or j < 0 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i != 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 0 or i > n or j < 0 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i > n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 0 or i < n or j < 0 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i < n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 0 or i == n or j < 0 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i == n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 0 or i >= n or j <= 0 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j <= 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 0 or i >= n or j >= 0 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j >= 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 0 or i >= n or j != 0 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j != 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 0 or i >= n or j < 0 or (j > m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j > m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 0 or i >= n or j < 0 or (j < m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j < m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 0 or i >= n or j < 0 or (j == m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j == m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if out_of_bounds(i, j) or matrix[i][j] == 0:",
      "mutated_line": "if out_of_bounds(i, j) or matrix[i][j] != 0:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] != 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return True\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if not out_of_bounds(x, y) and matrix[x][y] == 0:",
      "mutated_line": "if not out_of_bounds(x, y) or matrix[x][y] == 0:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) or matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if memo[i][j] != -1 and memo[i][j] != float('inf'):",
      "mutated_line": "if memo[i][j] == -1 and memo[i][j] != float('inf'):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] == -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if memo[i][j] != -1 and memo[i][j] != float('inf'):",
      "mutated_line": "if memo[i][j] != -1 and memo[i][j] == float('inf'):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] == float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if j == m - 1:",
      "mutated_line": "if j == m + 1:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m + 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if j == m - 1:",
      "mutated_line": "if j == m * 1:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m * 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 2\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 0\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 0\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return -1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_ = float('inf')",
      "mutated_line": "min_ = float('')",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if d == (0, -1):",
      "mutated_line": "if d != (0, -1):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d != (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if (x, y) not in visited and is_safe(x, y):",
      "mutated_line": "if (x, y) not in visited or is_safe(x, y):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited or is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "memo = [[-1 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "memo = [[+1 for _ in range(m)] for _ in range(n)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[+1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if is_safe(i, 0):",
      "mutated_line": "if is_safe(i, 1):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 1):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if is_safe(i, 0):",
      "mutated_line": "if is_safe(i, -1):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, -1):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if is_safe(i, 0):",
      "mutated_line": "if is_safe(i, 1):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 1):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1 if min_ == float('inf') else min_",
      "mutated_line": "return -2 if min_ == float('inf') else min_",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -2 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1 if min_ == float('inf') else min_",
      "mutated_line": "return -0 if min_ == float('inf') else min_",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -0 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1 if min_ == float('inf') else min_",
      "mutated_line": "return -0 if min_ == float('inf') else min_",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -0 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1 if min_ == float('inf') else min_",
      "mutated_line": "return --1 if min_ == float('inf') else min_",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return --1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(n, m) = (len(matrix), len(matrix[0]))",
      "mutated_line": "(n, m) = (len(matrix), len(matrix[1]))",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[1]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(n, m) = (len(matrix), len(matrix[0]))",
      "mutated_line": "(n, m) = (len(matrix), len(matrix[-1]))",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[-1]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "(n, m) = (len(matrix), len(matrix[0]))",
      "mutated_line": "(n, m) = (len(matrix), len(matrix[1]))",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[1]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-2, 0), (0, 1), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-2, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-0, 0), (0, 1), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-0, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-0, 0), (0, 1), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-0, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(--1, 0), (0, 1), (1, 0), (0, -1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(--1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -2)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -2)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -0)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -0)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -0)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -0)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "dr = [(-1, 0), (0, 1), (1, 0), (0, --1)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, --1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 1 or i >= n or j < 0 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 1 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < -1 or i >= n or j < 0 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < -1 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 1 or i >= n or j < 0 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 1 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 0 or i >= n or j < 1 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 1 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 0 or i >= n or j < -1 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < -1 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return i < 0 or i >= n or j < 0 or j >= m",
      "mutated_line": "return i < 0 or i >= n or j < 1 or (j >= m)",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 1 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if out_of_bounds(i, j) or matrix[i][j] == 0:",
      "mutated_line": "if out_of_bounds(i, j) or matrix[i][j] == 1:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 1:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if out_of_bounds(i, j) or matrix[i][j] == 0:",
      "mutated_line": "if out_of_bounds(i, j) or matrix[i][j] == -1:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == -1:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if out_of_bounds(i, j) or matrix[i][j] == 0:",
      "mutated_line": "if out_of_bounds(i, j) or matrix[i][j] == 1:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 1:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i - d[0], j + d[1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i - d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i * d[0], j + d[1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i * d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[0], j - d[1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j - d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[0], j * d[1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j * d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if not out_of_bounds(x, y) and matrix[x][y] == 0:",
      "mutated_line": "if not out_of_bounds(x, y) and matrix[x][y] != 0:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] != 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return True\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "if memo[i][j] != -1 and memo[i][j] != float('inf'):",
      "mutated_line": "if memo[i][j] != +1 and memo[i][j] != float('inf'):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != +1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if j == m - 1:",
      "mutated_line": "if j == m - 2:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 2:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if j == m - 1:",
      "mutated_line": "if j == m - 0:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 0:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if j == m - 1:",
      "mutated_line": "if j == m - 0:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 0:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if j == m - 1:",
      "mutated_line": "if j == m - -1:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - -1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i - d[0], j + d[1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i - d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i * d[0], j + d[1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i * d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[0], j - d[1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j - d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[0], j * d[1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j * d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if (x, y) not in visited and is_safe(x, y):",
      "mutated_line": "if (x, y) in visited and is_safe(x, y):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "memo = [[-1 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "memo = [[-2 for _ in range(m)] for _ in range(n)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-2 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "memo = [[-1 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "memo = [[-0 for _ in range(m)] for _ in range(n)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-0 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "memo = [[-1 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "memo = [[-0 for _ in range(m)] for _ in range(n)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-0 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "memo = [[-1 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "memo = [[--1 for _ in range(m)] for _ in range(n)]",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[--1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1 if min_ == float('inf') else min_",
      "mutated_line": "return -1 if min_ == float('') else min_",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not out_of_bounds(x, y) and matrix[x][y] == 0:",
      "mutated_line": "if not out_of_bounds(x, y) and matrix[x][y] == 1:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 1:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not out_of_bounds(x, y) and matrix[x][y] == 0:",
      "mutated_line": "if not out_of_bounds(x, y) and matrix[x][y] == -1:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == -1:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not out_of_bounds(x, y) and matrix[x][y] == 0:",
      "mutated_line": "if not out_of_bounds(x, y) and matrix[x][y] == 1:",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 1:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if memo[i][j] != -1 and memo[i][j] != float('inf'):",
      "mutated_line": "if memo[i][j] != -2 and memo[i][j] != float('inf'):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -2 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if memo[i][j] != -1 and memo[i][j] != float('inf'):",
      "mutated_line": "if memo[i][j] != -0 and memo[i][j] != float('inf'):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -0 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if memo[i][j] != -1 and memo[i][j] != float('inf'):",
      "mutated_line": "if memo[i][j] != -0 and memo[i][j] != float('inf'):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -0 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if memo[i][j] != -1 and memo[i][j] != float('inf'):",
      "mutated_line": "if memo[i][j] != --1 and memo[i][j] != float('inf'):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != --1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if memo[i][j] != -1 and memo[i][j] != float('inf'):",
      "mutated_line": "if memo[i][j] != -1 and memo[i][j] != float(''):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float(''):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if d == (0, -1):",
      "mutated_line": "if d == (1, -1):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (1, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if d == (0, -1):",
      "mutated_line": "if d == (-1, -1):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (-1, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if d == (0, -1):",
      "mutated_line": "if d == (1, -1):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (1, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "if d == (0, -1):",
      "mutated_line": "if d == (0, +1):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, +1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "min_ = min(min_, 1 + rec(x, y))",
      "mutated_line": "min_ = min(min_, 1 - rec(x, y))",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 - rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "min_ = min(min_, 1 + rec(x, y))",
      "mutated_line": "min_ = min(min_, 1 * rec(x, y))",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 * rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "min_ = min(min_, rec(i, 0))",
      "mutated_line": "min_ = min(min_, rec(i, 1))",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 1))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "min_ = min(min_, rec(i, 0))",
      "mutated_line": "min_ = min(min_, rec(i, -1))",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, -1))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "min_ = min(min_, rec(i, 0))",
      "mutated_line": "min_ = min(min_, rec(i, 1))",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 1))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[1], j + d[1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[1], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[-1], j + d[1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[-1], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[1], j + d[1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[1], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[0], j + d[2])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[2])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[0], j + d[0])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[0])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[0], j + d[0])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[0])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[0], j + d[-1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[-1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if d == (0, -1):",
      "mutated_line": "if d == (0, -2):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -2):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if d == (0, -1):",
      "mutated_line": "if d == (0, -0):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -0):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if d == (0, -1):",
      "mutated_line": "if d == (0, -0):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -0):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if d == (0, -1):",
      "mutated_line": "if d == (0, --1):",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, --1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[1], j + d[1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[1], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[-1], j + d[1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[-1], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[1], j + d[1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[1], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[0], j + d[2])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[2])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[0], j + d[0])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[0])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[0], j + d[0])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[0])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "(x, y) = (i + d[0], j + d[1])",
      "mutated_line": "(x, y) = (i + d[0], j + d[-1])",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[-1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_ = min(min_, 1 + rec(x, y))",
      "mutated_line": "min_ = min(min_, 2 + rec(x, y))",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 2 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_ = min(min_, 1 + rec(x, y))",
      "mutated_line": "min_ = min(min_, 0 + rec(x, y))",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 0 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_ = min(min_, 1 + rec(x, y))",
      "mutated_line": "min_ = min(min_, 0 + rec(x, y))",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, 0 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "min_ = min(min_, 1 + rec(x, y))",
      "mutated_line": "min_ = min(min_, -1 + rec(x, y))",
      "code": "from typing import List\n\ndef find_shortest_safe_path(matrix: List[List[int]]) -> int:\n    (n, m) = (len(matrix), len(matrix[0]))\n    dr = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\n    def out_of_bounds(i, j):\n        return i < 0 or i >= n or j < 0 or (j >= m)\n\n    def is_safe(i, j):\n        if out_of_bounds(i, j) or matrix[i][j] == 0:\n            return False\n        for d in dr:\n            (x, y) = (i + d[0], j + d[1])\n            if not out_of_bounds(x, y) and matrix[x][y] == 0:\n                return False\n        return True\n\n    def rec(i, j):\n        if memo[i][j] != -1 and memo[i][j] != float('inf'):\n            return memo[i][j]\n        if j == m - 1:\n            return 1\n        visited.add((i, j))\n        min_ = float('inf')\n        for d in dr:\n            if d == (0, -1):\n                continue\n            (x, y) = (i + d[0], j + d[1])\n            if (x, y) not in visited and is_safe(x, y):\n                min_ = min(min_, -1 + rec(x, y))\n        memo[i][j] = min_\n        visited.remove((i, j))\n        return memo[i][j]\n    visited = set()\n    memo = [[-1 for _ in range(m)] for _ in range(n)]\n    min_ = float('inf')\n    for i in range(n):\n        if is_safe(i, 0):\n            min_ = min(min_, rec(i, 0))\n    return -1 if min_ == float('inf') else min_"
    }
  ]
}