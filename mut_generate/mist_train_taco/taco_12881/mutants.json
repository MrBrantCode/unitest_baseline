{
  "task_id": "taco_12881",
  "entry_point": "count_distinct_sequences",
  "mutant_count": 180,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1000000008",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000008\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1000000006",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000006\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 0",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 0\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = -1000000007",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = -1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if y % x != 0:",
      "mutated_line": "if y % x == 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x == 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if x == y:",
      "mutated_line": "if x != y:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x != y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = y // x",
      "mutated_line": "a = y / x",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y / x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "a = y // x",
      "mutated_line": "a = y * x",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y * x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = 2",
      "mutated_line": "i = 3",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 3\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = 2",
      "mutated_line": "i = 1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 1\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = 2",
      "mutated_line": "i = 0",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 0\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = 2",
      "mutated_line": "i = 1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 1\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i = 2",
      "mutated_line": "i = -2",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = -2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i * i < a:",
      "mutated_line": "while i * i <= a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i <= a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i * i < a:",
      "mutated_line": "while i * i >= a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i >= a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i * i < a:",
      "mutated_line": "while i * i != a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i != a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i -= 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a ** 0.5) ** 2 != a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 != a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "muls[0] = 1",
      "mutated_line": "muls[0] = 2",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 2\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "muls[0] = 1",
      "mutated_line": "muls[0] = 0",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 0\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "muls[0] = 1",
      "mutated_line": "muls[0] = 0",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 0\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "muls[0] = 1",
      "mutated_line": "muls[0] = -1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = -1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res -= (prevs - 1) * modpow(2, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res -= (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if x == 0:",
      "mutated_line": "if x != 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x != 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if x == 1:",
      "mutated_line": "if x != 1:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x != 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return b * b * a ** (x % 2) * mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) * mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return b * b * a ** (x % 2) + mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) + mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if y % x != 0:",
      "mutated_line": "if y * x != 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y * x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if y % x != 0:",
      "mutated_line": "if y + x != 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y + x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if y % x != 0:",
      "mutated_line": "if y % x != 1:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 1:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if y % x != 0:",
      "mutated_line": "if y % x != -1:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != -1:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if y % x != 0:",
      "mutated_line": "if y % x != 1:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 1:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 1\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return -1\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 1\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 2\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 0\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 0\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return -1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i * i < a:",
      "mutated_line": "while i / i < a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i / i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i * i < a:",
      "mutated_line": "while i + i < a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i + i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while i * i < a:",
      "mutated_line": "while i ** i < a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i ** i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if a % i == 0:",
      "mutated_line": "if a % i != 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i != 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 2\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 0\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 0\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += -1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a ** 0.5) * 2 == a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) * 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a ** 0.5) + 2 == a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) + 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res = modpow(2, a - 1)",
      "mutated_line": "res = modpow(3, a - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(3, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res = modpow(2, a - 1)",
      "mutated_line": "res = modpow(1, a - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(1, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res = modpow(2, a - 1)",
      "mutated_line": "res = modpow(0, a - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(0, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res = modpow(2, a - 1)",
      "mutated_line": "res = modpow(1, a - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(1, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res = modpow(2, a - 1)",
      "mutated_line": "res = modpow(-2, a - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(-2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "res = modpow(2, a - 1)",
      "mutated_line": "res = modpow(2, a + 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a + 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "res = modpow(2, a - 1)",
      "mutated_line": "res = modpow(2, a * 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a * 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "muls = [0 for _ in divs]",
      "mutated_line": "muls = [1 for _ in divs]",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [1 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "muls = [0 for _ in divs]",
      "mutated_line": "muls = [-1 for _ in divs]",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [-1 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "muls = [0 for _ in divs]",
      "mutated_line": "muls = [1 for _ in divs]",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [1 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "muls[0] = 1",
      "mutated_line": "muls[1] = 1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[1] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "muls[0] = 1",
      "mutated_line": "muls[-1] = 1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[-1] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "muls[0] = 1",
      "mutated_line": "muls[1] = 1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[1] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prevs = 0",
      "mutated_line": "prevs = 1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 1\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prevs = 0",
      "mutated_line": "prevs = -1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = -1\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "prevs = 0",
      "mutated_line": "prevs = 1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 1\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "muls[xid] = 1 - prevs",
      "mutated_line": "muls[xid] = 1 + prevs",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 + prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "muls[xid] = 1 - prevs",
      "mutated_line": "muls[xid] = 1 * prevs",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 * prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) / modpow(2, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) / modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += prevs - 1 + modpow(2, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += prevs - 1 + modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) ** modpow(2, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) ** modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = (res + 1000 * mod) % mod",
      "mutated_line": "res = (res + 1000 * mod) * mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) * mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = (res + 1000 * mod) % mod",
      "mutated_line": "res = res + 1000 * mod + mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = res + 1000 * mod + mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x == 0:",
      "mutated_line": "if x == 1:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 1:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x == 0:",
      "mutated_line": "if x == -1:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == -1:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if x == 0:",
      "mutated_line": "if x == 1:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 1:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 2\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 0\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 0\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return -1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if x == 1:",
      "mutated_line": "if x == 2:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 2:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if x == 1:",
      "mutated_line": "if x == 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 0:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if x == 1:",
      "mutated_line": "if x == 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 0:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if x == 1:",
      "mutated_line": "if x == -1:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == -1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "b = modpow(a, x // 2)",
      "mutated_line": "b = modpow(a, x / 2)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x / 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "b = modpow(a, x // 2)",
      "mutated_line": "b = modpow(a, x * 2)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x * 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return b * b / a ** (x % 2) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b / a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return (b * b + a ** (x % 2)) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return (b * b + a ** (x % 2)) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return (b * b) ** a ** (x % 2) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return (b * b) ** a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if a % i == 0:",
      "mutated_line": "if a * i == 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a * i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if a % i == 0:",
      "mutated_line": "if a + i == 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a + i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if a % i == 0:",
      "mutated_line": "if a % i == 1:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 1:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if a % i == 0:",
      "mutated_line": "if a % i == -1:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == -1:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if a % i == 0:",
      "mutated_line": "if a % i == 1:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 1:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a ** 0.5) ** 3 == a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 3 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a ** 0.5) ** 1 == a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 1 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a ** 0.5) ** 0 == a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 0 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a ** 0.5) ** 1 == a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 1 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a ** 0.5) ** -2 == a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** -2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res = modpow(2, a - 1)",
      "mutated_line": "res = modpow(2, a - 2)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 2)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res = modpow(2, a - 1)",
      "mutated_line": "res = modpow(2, a - 0)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 0)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res = modpow(2, a - 1)",
      "mutated_line": "res = modpow(2, a - 0)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 0)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res = modpow(2, a - 1)",
      "mutated_line": "res = modpow(2, a - -1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - -1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "if d2 < d and d % d2 == 0:",
      "mutated_line": "if d2 < d or d % d2 == 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d or d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "prevs += muls[id]",
      "mutated_line": "prevs -= muls[id]",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs -= muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "muls[xid] = 1 - prevs",
      "mutated_line": "muls[xid] = 2 - prevs",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 2 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "muls[xid] = 1 - prevs",
      "mutated_line": "muls[xid] = 0 - prevs",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 0 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "muls[xid] = 1 - prevs",
      "mutated_line": "muls[xid] = 0 - prevs",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 0 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "muls[xid] = 1 - prevs",
      "mutated_line": "muls[xid] = -1 - prevs",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = -1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs + 1) * modpow(2, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs + 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += prevs * 1 * modpow(2, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += prevs * 1 * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = (res + 1000 * mod) % mod",
      "mutated_line": "res = (res - 1000 * mod) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res - 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = (res + 1000 * mod) % mod",
      "mutated_line": "res = res * (1000 * mod) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = res * (1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b = modpow(a, x // 2)",
      "mutated_line": "b = modpow(a, x // 3)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 3)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b = modpow(a, x // 2)",
      "mutated_line": "b = modpow(a, x // 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 1)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b = modpow(a, x // 2)",
      "mutated_line": "b = modpow(a, x // 0)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 0)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b = modpow(a, x // 2)",
      "mutated_line": "b = modpow(a, x // 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 1)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b = modpow(a, x // 2)",
      "mutated_line": "b = modpow(a, x // -2)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // -2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return b / b * a ** (x % 2) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b / b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return (b + b) * a ** (x % 2) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return (b + b) * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return b ** b * a ** (x % 2) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b ** b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return b * b * (a * (x % 2)) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * (a * (x % 2)) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return b * b * (a + x % 2) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * (a + x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "divs.append(a // i)",
      "mutated_line": "divs.append(a / i)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a / i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "divs.append(a // i)",
      "mutated_line": "divs.append(a * i)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a * i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a * 0.5) ** 2 == a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a * 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a + 0.5) ** 2 == a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a + 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "divs.append(int(a ** 0.5))",
      "mutated_line": "divs.append(int(a * 0.5))",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a * 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "divs.append(int(a ** 0.5))",
      "mutated_line": "divs.append(int(a + 0.5))",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a + 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if d2 < d and d % d2 == 0:",
      "mutated_line": "if d2 <= d and d % d2 == 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 <= d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if d2 < d and d % d2 == 0:",
      "mutated_line": "if d2 >= d and d % d2 == 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 >= d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if d2 < d and d % d2 == 0:",
      "mutated_line": "if d2 != d and d % d2 == 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 != d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if d2 < d and d % d2 == 0:",
      "mutated_line": "if d2 < d and d % d2 != 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 != 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 2) * modpow(2, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 2) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 0) * modpow(2, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 0) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 0) * modpow(2, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 0) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - -1) * modpow(2, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - -1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) * modpow(3, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(3, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) * modpow(1, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(1, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) * modpow(0, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(0, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) * modpow(1, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(1, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) * modpow(-2, a // d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(-2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) * modpow(2, a // d + 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d + 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) * modpow(2, a // d * 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d * 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = (res + 1000 * mod) % mod",
      "mutated_line": "res = (res + 1000 / mod) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 / mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = (res + 1000 * mod) % mod",
      "mutated_line": "res = (res + (1000 + mod)) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + (1000 + mod)) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = (res + 1000 * mod) % mod",
      "mutated_line": "res = (res + 1000 ** mod) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 ** mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return b * b * a ** (x * 2) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x * 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return b * b * a ** (x + 2) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x + 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a ** 1.5) ** 2 == a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 1.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a ** -0.5) ** 2 == a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** -0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a ** 0) ** 2 == a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a ** 1) ** 2 == a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 1) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if int(a ** 0.5) ** 2 == a:",
      "mutated_line": "if int(a ** -0.5) ** 2 == a:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** -0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "divs.append(int(a ** 0.5))",
      "mutated_line": "divs.append(int(a ** 1.5))",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 1.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "divs.append(int(a ** 0.5))",
      "mutated_line": "divs.append(int(a ** -0.5))",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** -0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "divs.append(int(a ** 0.5))",
      "mutated_line": "divs.append(int(a ** 0))",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "divs.append(int(a ** 0.5))",
      "mutated_line": "divs.append(int(a ** 1))",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 1))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "divs.append(int(a ** 0.5))",
      "mutated_line": "divs.append(int(a ** -0.5))",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** -0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if d2 < d and d % d2 == 0:",
      "mutated_line": "if d2 < d and d * d2 == 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d * d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if d2 < d and d % d2 == 0:",
      "mutated_line": "if d2 < d and d + d2 == 0:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d + d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d2 < d and d % d2 == 0:",
      "mutated_line": "if d2 < d and d % d2 == 1:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 1:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d2 < d and d % d2 == 0:",
      "mutated_line": "if d2 < d and d % d2 == -1:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == -1:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if d2 < d and d % d2 == 0:",
      "mutated_line": "if d2 < d and d % d2 == 1:",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 1:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) * modpow(2, a / d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a / d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) * modpow(2, a * d - 1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a * d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) * modpow(2, a // d - 2)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 2)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) * modpow(2, a // d - 0)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 0)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) * modpow(2, a // d - 0)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 0)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res += (prevs - 1) * modpow(2, a // d - 1)",
      "mutated_line": "res += (prevs - 1) * modpow(2, a // d - -1)",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - -1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res = (res + 1000 * mod) % mod",
      "mutated_line": "res = (res + 1001 * mod) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1001 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res = (res + 1000 * mod) % mod",
      "mutated_line": "res = (res + 999 * mod) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 999 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res = (res + 1000 * mod) % mod",
      "mutated_line": "res = (res + 0 * mod) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 0 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res = (res + 1000 * mod) % mod",
      "mutated_line": "res = (res + 1 * mod) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res = (res + 1000 * mod) % mod",
      "mutated_line": "res = (res + -1000 * mod) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + -1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return b * b * a ** (x % 3) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 3) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return b * b * a ** (x % 1) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 1) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return b * b * a ** (x % 0) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 0) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return b * b * a ** (x % 1) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % 1) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return b * b * a ** (x % 2) % mod",
      "mutated_line": "return b * b * a ** (x % -2) % mod",
      "code": "def count_distinct_sequences(x: int, y: int) -> int:\n    mod = 1000000007\n\n    def modpow(a, x):\n        if x == 0:\n            return 1\n        if x == 1:\n            return a\n        b = modpow(a, x // 2)\n        return b * b * a ** (x % -2) % mod\n    if y % x != 0:\n        return 0\n    if x == y:\n        return 1\n    a = y // x\n    divs = []\n    i = 2\n    while i * i < a:\n        if a % i == 0:\n            divs.append(i)\n            divs.append(a // i)\n        i += 1\n    if int(a ** 0.5) ** 2 == a:\n        divs.append(int(a ** 0.5))\n    divs.append(a)\n    divs.sort()\n    res = modpow(2, a - 1)\n    muls = [0 for _ in divs]\n    muls[0] = 1\n    for (xid, d) in enumerate(divs):\n        prevs = 0\n        for (id, d2) in enumerate(divs):\n            if d2 < d and d % d2 == 0:\n                prevs += muls[id]\n        muls[xid] = 1 - prevs\n        res += (prevs - 1) * modpow(2, a // d - 1)\n        res = (res + 1000 * mod) % mod\n    return res"
    }
  ]
}