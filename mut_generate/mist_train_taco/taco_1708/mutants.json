{
  "task_id": "taco_1708",
  "entry_point": "expected_inversions",
  "mutant_count": 177,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "a = [[0] * n for i in r(n)]",
      "mutated_line": "a = [[0] / n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] / n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "a = [[0] * n for i in r(n)]",
      "mutated_line": "a = [[0] + n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] + n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "a = [[0] * n for i in r(n)]",
      "mutated_line": "a = [[0] ** n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] ** n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "b = [[0] * n for i in r(n)]",
      "mutated_line": "b = [[0] / n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] / n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "b = [[0] * n for i in r(n)]",
      "mutated_line": "b = [[0] + n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] + n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "b = [[0] * n for i in r(n)]",
      "mutated_line": "b = [[0] ** n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] ** n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "c = [[0] * n for i in r(n)]",
      "mutated_line": "c = [[0] / n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] / n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "c = [[0] * n for i in r(n)]",
      "mutated_line": "c = [[0] + n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] + n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "c = [[0] * n for i in r(n)]",
      "mutated_line": "c = [[0] ** n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] ** n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "s += x[j] - x[i] - x[d - 1]",
      "mutated_line": "s -= x[j] - x[i] - x[d - 1]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s -= x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "s += y[i] - y[j] - y[n - d]",
      "mutated_line": "s -= y[i] - y[j] - y[n - d]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s -= y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s -= (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s -= (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l * l - l >> 1 for l in r(n + 1)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l - l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l * l * l >> 1 for l in r(n + 1)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l * l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l * l + l >> 2 for l in r(n + 1)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 2 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l * l + l >> 0 for l in r(n + 1)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 0 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l * l + l >> 0 for l in r(n + 1)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 0 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l * l + l >> -1 for l in r(n + 1)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> -1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "t = [[p[i] > p[j] for j in r(n)] for i in r(n)]",
      "mutated_line": "t = [[p[i] >= p[j] for j in r(n)] for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] >= p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "t = [[p[i] > p[j] for j in r(n)] for i in r(n)]",
      "mutated_line": "t = [[p[i] <= p[j] for j in r(n)] for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] <= p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "t = [[p[i] > p[j] for j in r(n)] for i in r(n)]",
      "mutated_line": "t = [[p[i] != p[j] for j in r(n)] for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] != p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for l in r(min(k, 1000)):",
      "mutated_line": "for l in r(min(k, 1001)):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1001)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for l in r(min(k, 1000)):",
      "mutated_line": "for l in r(min(k, 999)):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 999)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for l in r(min(k, 1000)):",
      "mutated_line": "for l in r(min(k, 0)):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 0)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for l in r(min(k, 1000)):",
      "mutated_line": "for l in r(min(k, 1)):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for l in r(min(k, 1000)):",
      "mutated_line": "for l in r(min(k, -1000)):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, -1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in r(1, n):",
      "mutated_line": "for j in r(2, n):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(2, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in r(1, n):",
      "mutated_line": "for j in r(0, n):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(0, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in r(1, n):",
      "mutated_line": "for j in r(0, n):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(0, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in r(1, n):",
      "mutated_line": "for j in r(-1, n):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(-1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "s += t[i][j]",
      "mutated_line": "s -= t[i][j]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s -= t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "s += t[i][j]",
      "mutated_line": "s -= t[i][j]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s -= t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for d in r(1, n):",
      "mutated_line": "for d in r(2, n):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(2, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for d in r(1, n):",
      "mutated_line": "for d in r(0, n):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(0, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for d in r(1, n):",
      "mutated_line": "for d in r(0, n):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(0, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for d in r(1, n):",
      "mutated_line": "for d in r(-1, n):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(-1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "s += t[i][i + d]",
      "mutated_line": "s -= t[i][i + d]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s -= t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "d = j - i",
      "mutated_line": "d = j + i",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j + i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "d = j - i",
      "mutated_line": "d = j * i",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j * i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] / (u[i] + u[d - 1] + u[n - j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] / (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] + (u[i] + u[d - 1] + u[n - j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] + (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] ** (u[i] + u[d - 1] + u[n - j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] ** (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "s += x[j] - x[i] - x[d - 1]",
      "mutated_line": "s += x[j] - x[i] + x[d - 1]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] + x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "s += x[j] - x[i] - x[d - 1]",
      "mutated_line": "s += (x[j] - x[i]) * x[d - 1]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += (x[j] - x[i]) * x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "s += y[i] - y[j] - y[n - d]",
      "mutated_line": "s += y[i] - y[j] + y[n - d]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] + y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "s += y[i] - y[j] - y[n - d]",
      "mutated_line": "s += (y[i] - y[j]) * y[n - d]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += (y[i] - y[j]) * y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] - z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] - z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += ((i + 1) * (n - j) - z[n - d] + z[n - j - 1]) * z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += ((i + 1) * (n - j) - z[n - d] + z[n - j - 1]) * z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "t[i][j] = s / u[n]",
      "mutated_line": "t[i][j] = s * u[n]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s * u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "t[i][j] = s / u[n]",
      "mutated_line": "t[i][j] = s // u[n]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s // u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l / l + l >> 1 for l in r(n + 1)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l / l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l + l + l >> 1 for l in r(n + 1)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l + l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l ** l + l >> 1 for l in r(n + 1)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l ** l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l * l + l >> 1 for l in r(n - 1)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n - 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l * l + l >> 1 for l in r(n * 1)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n * 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "v = [(i, j) for i in r(n) for j in r(i + 1, n)]",
      "mutated_line": "v = [(i, j) for i in r(n) for j in r(i - 1, n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i - 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "v = [(i, j) for i in r(n) for j in r(i + 1, n)]",
      "mutated_line": "v = [(i, j) for i in r(n) for j in r(i * 1, n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i * 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a = [[0] * n for i in r(n)]",
      "mutated_line": "a = [[1] * n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[1] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a = [[0] * n for i in r(n)]",
      "mutated_line": "a = [[-1] * n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[-1] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "a = [[0] * n for i in r(n)]",
      "mutated_line": "a = [[1] * n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[1] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "b = [[0] * n for i in r(n)]",
      "mutated_line": "b = [[1] * n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[1] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "b = [[0] * n for i in r(n)]",
      "mutated_line": "b = [[-1] * n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[-1] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "b = [[0] * n for i in r(n)]",
      "mutated_line": "b = [[1] * n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[1] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * n for i in r(n)]",
      "mutated_line": "c = [[1] * n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[1] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * n for i in r(n)]",
      "mutated_line": "c = [[-1] * n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[-1] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "c = [[0] * n for i in r(n)]",
      "mutated_line": "c = [[1] * n for i in r(n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[1] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(s, x) = (0, a[j])",
      "mutated_line": "(s, x) = (1, a[j])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (1, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(s, x) = (0, a[j])",
      "mutated_line": "(s, x) = (-1, a[j])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (-1, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(s, x) = (0, a[j])",
      "mutated_line": "(s, x) = (1, a[j])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (1, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x[i + 1] = x[i] + s",
      "mutated_line": "x[i + 1] = x[i] - s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] - s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x[i + 1] = x[i] + s",
      "mutated_line": "x[i + 1] = x[i] * s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] * s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "(s, y) = (0, b[i])",
      "mutated_line": "(s, y) = (1, b[i])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (1, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "(s, y) = (0, b[i])",
      "mutated_line": "(s, y) = (-1, b[i])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (-1, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "(s, y) = (0, b[i])",
      "mutated_line": "(s, y) = (1, b[i])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (1, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for j in r(n - 1, i, -1):",
      "mutated_line": "for j in r(n + 1, i, -1):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n + 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for j in r(n - 1, i, -1):",
      "mutated_line": "for j in r(n * 1, i, -1):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n * 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "for j in r(n - 1, i, -1):",
      "mutated_line": "for j in r(n - 1, i, +1):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, +1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "y[j - 1] = y[j] + s",
      "mutated_line": "y[j - 1] = y[j] - s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] - s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "y[j - 1] = y[j] + s",
      "mutated_line": "y[j - 1] = y[j] * s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] * s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "(s, z) = (0, c[d])",
      "mutated_line": "(s, z) = (1, c[d])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (1, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "(s, z) = (0, c[d])",
      "mutated_line": "(s, z) = (-1, c[d])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (-1, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "(s, z) = (0, c[d])",
      "mutated_line": "(s, z) = (1, c[d])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (1, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in r(n - d):",
      "mutated_line": "for i in r(n + d):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n + d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in r(n - d):",
      "mutated_line": "for i in r(n * d):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n * d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "z[i + 1] = z[i] + s",
      "mutated_line": "z[i + 1] = z[i] - s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] - s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "z[i + 1] = z[i] + s",
      "mutated_line": "z[i + 1] = z[i] * s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] * s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d - 1] - u[n - j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] - u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * ((u[i] + u[d - 1]) * u[n - j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * ((u[i] + u[d - 1]) * u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "s += x[j] - x[i] - x[d - 1]",
      "mutated_line": "s += x[j] + x[i] - x[d - 1]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] + x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "s += x[j] - x[i] - x[d - 1]",
      "mutated_line": "s += x[j] * x[i] - x[d - 1]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] * x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "s += y[i] - y[j] - y[n - d]",
      "mutated_line": "s += y[i] + y[j] - y[n - d]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] + y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "s += y[i] - y[j] - y[n - d]",
      "mutated_line": "s += y[i] * y[j] - y[n - d]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] * y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n - j) - z[n - d] - z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] - z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += ((i + 1) * (n - j) - z[n - d]) * z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += ((i + 1) * (n - j) - z[n - d]) * z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l * l + l >> 1 for l in r(n + 2)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 2)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l * l + l >> 1 for l in r(n + 0)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 0)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l * l + l >> 1 for l in r(n + 0)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 0)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "u = [l * l + l >> 1 for l in r(n + 1)]",
      "mutated_line": "u = [l * l + l >> 1 for l in r(n + -1)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + -1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "v = [(i, j) for i in r(n) for j in r(i + 1, n)]",
      "mutated_line": "v = [(i, j) for i in r(n) for j in r(i + 2, n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 2, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "v = [(i, j) for i in r(n) for j in r(i + 1, n)]",
      "mutated_line": "v = [(i, j) for i in r(n) for j in r(i + 0, n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 0, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "v = [(i, j) for i in r(n) for j in r(i + 1, n)]",
      "mutated_line": "v = [(i, j) for i in r(n) for j in r(i + 0, n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 0, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "v = [(i, j) for i in r(n) for j in r(i + 1, n)]",
      "mutated_line": "v = [(i, j) for i in r(n) for j in r(i + -1, n)]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + -1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x[i + 1] = x[i] + s",
      "mutated_line": "x[i - 1] = x[i] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i - 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "x[i + 1] = x[i] + s",
      "mutated_line": "x[i * 1] = x[i] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i * 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in r(n - 1, i, -1):",
      "mutated_line": "for j in r(n - 2, i, -1):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 2, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in r(n - 1, i, -1):",
      "mutated_line": "for j in r(n - 0, i, -1):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 0, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in r(n - 1, i, -1):",
      "mutated_line": "for j in r(n - 0, i, -1):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 0, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in r(n - 1, i, -1):",
      "mutated_line": "for j in r(n - -1, i, -1):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - -1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in r(n - 1, i, -1):",
      "mutated_line": "for j in r(n - 1, i, -2):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -2):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in r(n - 1, i, -1):",
      "mutated_line": "for j in r(n - 1, i, -0):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -0):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in r(n - 1, i, -1):",
      "mutated_line": "for j in r(n - 1, i, -0):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -0):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in r(n - 1, i, -1):",
      "mutated_line": "for j in r(n - 1, i, --1):",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, --1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "y[j - 1] = y[j] + s",
      "mutated_line": "y[j + 1] = y[j] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j + 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "y[j - 1] = y[j] + s",
      "mutated_line": "y[j * 1] = y[j] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j * 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "s += t[i][i + d]",
      "mutated_line": "s += t[i][i - d]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i - d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "s += t[i][i + d]",
      "mutated_line": "s += t[i][i * d]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i * d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "z[i + 1] = z[i] + s",
      "mutated_line": "z[i - 1] = z[i] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i - 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "z[i + 1] = z[i] + s",
      "mutated_line": "z[i * 1] = z[i] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i * 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] - u[d - 1] + u[n - j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] - u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] * u[d - 1] + u[n - j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] * u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "s += x[j] - x[i] - x[d - 1]",
      "mutated_line": "s += x[j] - x[i] - x[d + 1]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d + 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "s += x[j] - x[i] - x[d - 1]",
      "mutated_line": "s += x[j] - x[i] - x[d * 1]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d * 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "s += y[i] - y[j] - y[n - d]",
      "mutated_line": "s += y[i] - y[j] - y[n + d]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n + d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "s += y[i] - y[j] - y[n - d]",
      "mutated_line": "s += y[i] - y[j] - y[n * d]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n * d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n - j) + z[n - d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) + z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n - j) * z[n - d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) * z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[i + 1] = x[i] + s",
      "mutated_line": "x[i + 2] = x[i] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 2] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[i + 1] = x[i] + s",
      "mutated_line": "x[i + 0] = x[i] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 0] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[i + 1] = x[i] + s",
      "mutated_line": "x[i + 0] = x[i] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 0] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x[i + 1] = x[i] + s",
      "mutated_line": "x[i + -1] = x[i] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + -1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y[j - 1] = y[j] + s",
      "mutated_line": "y[j - 2] = y[j] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 2] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y[j - 1] = y[j] + s",
      "mutated_line": "y[j - 0] = y[j] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 0] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y[j - 1] = y[j] + s",
      "mutated_line": "y[j - 0] = y[j] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 0] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y[j - 1] = y[j] + s",
      "mutated_line": "y[j - -1] = y[j] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - -1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "z[i + 1] = z[i] + s",
      "mutated_line": "z[i + 2] = z[i] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 2] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "z[i + 1] = z[i] + s",
      "mutated_line": "z[i + 0] = z[i] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 0] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "z[i + 1] = z[i] + s",
      "mutated_line": "z[i + 0] = z[i] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 0] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "z[i + 1] = z[i] + s",
      "mutated_line": "z[i + -1] = z[i] + s",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + -1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j + 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j + 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d - 1] + u[(n - j) * 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[(n - j) * 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "s += x[j] - x[i] - x[d - 1]",
      "mutated_line": "s += x[j] - x[i] - x[d - 2]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 2]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "s += x[j] - x[i] - x[d - 1]",
      "mutated_line": "s += x[j] - x[i] - x[d - 0]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 0]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "s += x[j] - x[i] - x[d - 1]",
      "mutated_line": "s += x[j] - x[i] - x[d - 0]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 0]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "s += x[j] - x[i] - x[d - 1]",
      "mutated_line": "s += x[j] - x[i] - x[d - -1]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - -1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) / (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) / (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += i + 1 + (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += i + 1 + (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) ** (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) ** (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j + 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j + 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n - j) - z[n - d] + z[(n - j) * 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[(n - j) * 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d + 1] + u[n - j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d + 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d * 1] + u[n - j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d * 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n + j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n + j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n * j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n * j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 2])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 2])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 0])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 0])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 0])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 0])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - -1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - -1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i - 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i - 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += i * 1 * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += i * 1 * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n + j) - z[n - d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n + j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n * j) - z[n - d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n * j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n - j) - z[n + d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n + d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n - j) - z[n * d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n * d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n - j) - z[n - d] + z[n + j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n + j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n - j) - z[n - d] + z[n * j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n * j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 2] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 2] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 0] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 0] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 0] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 0] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - -1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - -1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d - 2] + u[n - j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 2] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d - 0] + u[n - j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 0] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d - 0] + u[n - j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 0] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])",
      "mutated_line": "s = t[i][j] * (u[i] + u[d - -1] + u[n - j - 1])",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - -1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 2) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 2) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 0) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 0) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + 0) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + 0) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "s += (i + 1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "mutated_line": "s += (i + -1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]",
      "code": "def expected_inversions(n, k, p):\n    r = range\n    u = [l * l + l >> 1 for l in r(n + 1)]\n    v = [(i, j) for i in r(n) for j in r(i + 1, n)]\n    t = [[p[i] > p[j] for j in r(n)] for i in r(n)]\n    a = [[0] * n for i in r(n)]\n    b = [[0] * n for i in r(n)]\n    c = [[0] * n for i in r(n)]\n    for l in r(min(k, 1000)):\n        for j in r(1, n):\n            (s, x) = (0, a[j])\n            for i in r(j):\n                s += t[i][j]\n                x[i + 1] = x[i] + s\n        for i in r(n):\n            (s, y) = (0, b[i])\n            for j in r(n - 1, i, -1):\n                s += t[i][j]\n                y[j - 1] = y[j] + s\n        for d in r(1, n):\n            (s, z) = (0, c[d])\n            for i in r(n - d):\n                s += t[i][i + d]\n                z[i + 1] = z[i] + s\n        for (i, j) in v:\n            d = j - i\n            (x, y, z) = (a[j], b[i], c[d])\n            s = t[i][j] * (u[i] + u[d - 1] + u[n - j - 1])\n            s += x[j] - x[i] - x[d - 1]\n            s += y[i] - y[j] - y[n - d]\n            s += (i + -1) * (n - j) - z[n - d] + z[n - j - 1] + z[i]\n            t[i][j] = s / u[n]\n    return sum((t[i][j] for (i, j) in v))"
    }
  ]
}