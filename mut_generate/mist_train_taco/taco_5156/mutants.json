{
  "task_id": "taco_5156",
  "entry_point": "shortest_village_distances",
  "mutant_count": 50,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "res = [None] * (n + 1)",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] / (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "res = [None] * (n + 1)",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] + (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "res = [None] * (n + 1)",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] ** (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "res = [None] * (n + 1)",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n - 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "res = [None] * (n + 1)",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n * 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "level = 0",
      "mutated_line": "level = 1",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 1\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "level = 0",
      "mutated_line": "level = -1",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = -1\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "level = 0",
      "mutated_line": "level = 1",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 1\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "while q and notdiscovered:",
      "mutated_line": "while q or notdiscovered:",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q or notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res = [None] * (n + 1)",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 2)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res = [None] * (n + 1)",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 0)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res = [None] * (n + 1)",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 0)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res = [None] * (n + 1)",
      "mutated_line": "",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + -1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "level = v[1] + 1",
      "mutated_line": "level = v[1] - 1",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] - 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "level = v[1] + 1",
      "mutated_line": "level = v[1] * 1",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] * 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "return [dist for dist in res if dist is not None and dist != 0]",
      "mutated_line": "return [dist for dist in res if dist is not None or dist != 0]",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None or dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "notdiscovered = set(range(1, n + 1))",
      "mutated_line": "notdiscovered = set(range(2, n + 1))",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(2, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "notdiscovered = set(range(1, n + 1))",
      "mutated_line": "notdiscovered = set(range(0, n + 1))",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(0, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "notdiscovered = set(range(1, n + 1))",
      "mutated_line": "notdiscovered = set(range(0, n + 1))",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(0, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "notdiscovered = set(range(1, n + 1))",
      "mutated_line": "notdiscovered = set(range(-1, n + 1))",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(-1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "notdiscovered = set(range(1, n + 1))",
      "mutated_line": "notdiscovered = set(range(1, n - 1))",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n - 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "notdiscovered = set(range(1, n + 1))",
      "mutated_line": "notdiscovered = set(range(1, n * 1))",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n * 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i = v[0]",
      "mutated_line": "i = v[1]",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[1]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i = v[0]",
      "mutated_line": "i = v[-1]",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[-1]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i = v[0]",
      "mutated_line": "i = v[1]",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[1]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "level = v[1] + 1",
      "mutated_line": "level = v[1] + 2",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 2\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "level = v[1] + 1",
      "mutated_line": "level = v[1] + 0",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 0\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "level = v[1] + 1",
      "mutated_line": "level = v[1] + 0",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 0\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "level = v[1] + 1",
      "mutated_line": "level = v[1] + -1",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + -1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if j == i:",
      "mutated_line": "if j != i:",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j != i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):",
      "mutated_line": "if (i not in pe1 and j not in pe1) and ((i, j) not in pe and (j, i) not in pe):",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if (i not in pe1 and j not in pe1) and ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "return [dist for dist in res if dist is not None and dist != 0]",
      "mutated_line": "return [dist for dist in res if dist is None and dist != 0]",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is None and dist != 0]"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "return [dist for dist in res if dist is not None and dist != 0]",
      "mutated_line": "return [dist for dist in res if dist is not None and dist == 0]",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist == 0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "notdiscovered = set(range(1, n + 1))",
      "mutated_line": "notdiscovered = set(range(1, n + 2))",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 2))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "notdiscovered = set(range(1, n + 1))",
      "mutated_line": "notdiscovered = set(range(1, n + 0))",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 0))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "notdiscovered = set(range(1, n + 1))",
      "mutated_line": "notdiscovered = set(range(1, n + 0))",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 0))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "notdiscovered = set(range(1, n + 1))",
      "mutated_line": "notdiscovered = set(range(1, n + -1))",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + -1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "level = v[1] + 1",
      "mutated_line": "level = v[2] + 1",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[2] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "level = v[1] + 1",
      "mutated_line": "level = v[0] + 1",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[0] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "level = v[1] + 1",
      "mutated_line": "level = v[0] + 1",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[0] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "level = v[1] + 1",
      "mutated_line": "level = v[-1] + 1",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[-1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):",
      "mutated_line": "if (i not in pe1 or j not in pe1) or ((i, j) not in pe and (j, i) not in pe):",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if (i not in pe1 or j not in pe1) or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):",
      "mutated_line": "if i not in pe1 and j not in pe1 or ((i, j) not in pe or (j, i) not in pe):",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe or (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return [dist for dist in res if dist is not None and dist != 0]",
      "mutated_line": "return [dist for dist in res if dist is not None and dist != 1]",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return [dist for dist in res if dist is not None and dist != 0]",
      "mutated_line": "return [dist for dist in res if dist is not None and dist != -1]",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != -1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return [dist for dist in res if dist is not None and dist != 0]",
      "mutated_line": "return [dist for dist in res if dist is not None and dist != 1]",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 1]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):",
      "mutated_line": "if i in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):",
      "mutated_line": "if i not in pe1 and j in pe1 or ((i, j) not in pe and (j, i) not in pe):",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j in pe1 or ((i, j) not in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):",
      "mutated_line": "if i not in pe1 and j not in pe1 or ((i, j) in pe and (j, i) not in pe):",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) in pe and (j, i) not in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) not in pe):",
      "mutated_line": "if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) in pe):",
      "code": "from collections import deque\n\ndef shortest_village_distances(n, m, main_roads, start_node):\n    pe = set(main_roads)\n    pe1 = set((node for road in main_roads for node in road))\n    res = [None] * (n + 1)\n\n    def bfs(s, pe, res, n, pe1):\n        notdiscovered = set(range(1, n + 1))\n        q = deque()\n        level = 0\n        q.append((s, level))\n        notdiscovered.discard(s)\n        while q and notdiscovered:\n            v = q.popleft()\n            i = v[0]\n            level = v[1] + 1\n            nd = []\n            for j in notdiscovered:\n                if j == i:\n                    continue\n                if i not in pe1 and j not in pe1 or ((i, j) not in pe and (j, i) in pe):\n                    q.append((j, level))\n                    nd.append(j)\n                    res[j] = level\n            for j in nd:\n                notdiscovered.discard(j)\n        return res\n    res = bfs(start_node, pe, res, n, pe1)\n    return [dist for dist in res if dist is not None and dist != 0]"
    }
  ]
}