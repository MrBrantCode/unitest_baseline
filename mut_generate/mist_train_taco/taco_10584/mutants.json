{
  "task_id": "taco_10584",
  "entry_point": "min_cost_to_valid_path",
  "mutant_count": 123,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "curr_cost = 0",
      "mutated_line": "curr_cost = 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 1\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "curr_cost = 0",
      "mutated_line": "curr_cost = -1",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = -1\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "curr_cost = 0",
      "mutated_line": "curr_cost = 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 1\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "curr_cost += 1",
      "mutated_line": "curr_cost -= 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost -= 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {2: right, 2: left, 3: down, 4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {2: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {0: right, 2: left, 3: down, 4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {0: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {0: right, 2: left, 3: down, 4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {0: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {-1: right, 2: left, 3: down, 4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {-1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, 3: left, 3: down, 4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 3: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, 1: left, 3: down, 4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 1: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, 0: left, 3: down, 4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 0: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, 1: left, 3: down, 4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 1: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, -2: left, 3: down, 4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, -2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, 2: left, 4: down, 4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 4: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, 2: left, 2: down, 4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 2: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, 2: left, 0: down, 4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 0: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, 2: left, 1: down, 4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 1: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, 2: left, -3: down, 4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, -3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, 2: left, 3: down, 5: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 5: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, 2: left, 3: down, 3: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 3: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, 2: left, 3: down, 0: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 0: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, 2: left, 3: down, 1: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 1: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "direction_map = {1: right, 2: left, 3: down, 4: up}",
      "mutated_line": "direction_map = {1: right, 2: left, 3: down, -4: up}",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, -4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[i])",
      "mutated_line": "return 0 <= i < len(grid) or 0 <= j < len(grid[i])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) or 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if not in_bounds(i, j) or (i, j) in visited:",
      "mutated_line": "if not in_bounds(i, j) and (i, j) in visited:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) and (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return [(i, j)] + dfs(next_i, next_j)",
      "mutated_line": "return [(i, j)] - dfs(next_i, next_j)",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] - dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return [(i, j)] + dfs(next_i, next_j)",
      "mutated_line": "return [(i, j)] * dfs(next_i, next_j)",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] * dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "reachable = dfs(0, 0)",
      "mutated_line": "reachable = dfs(1, 0)",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(1, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "reachable = dfs(0, 0)",
      "mutated_line": "reachable = dfs(-1, 0)",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(-1, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "reachable = dfs(0, 0)",
      "mutated_line": "reachable = dfs(1, 0)",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(1, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "reachable = dfs(0, 0)",
      "mutated_line": "reachable = dfs(0, 1)",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 1)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "reachable = dfs(0, 0)",
      "mutated_line": "reachable = dfs(0, -1)",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, -1)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "reachable = dfs(0, 0)",
      "mutated_line": "reachable = dfs(0, 1)",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 1)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "curr_cost += 1",
      "mutated_line": "curr_cost += 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "curr_cost += 1",
      "mutated_line": "curr_cost += 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "curr_cost += 1",
      "mutated_line": "curr_cost += 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "curr_cost += 1",
      "mutated_line": "curr_cost += -1",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += -1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((1, 1), (0, -1), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((1, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((-1, 1), (0, -1), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((-1, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((1, 1), (0, -1), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((1, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 2), (0, -1), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 2), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 0), (0, -1), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 0), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 0), (0, -1), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 0), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, -1), (0, -1), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, -1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (1, -1), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (1, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (-1, -1), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (-1, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (1, -1), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (1, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, +1), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, +1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (2, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (2, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (0, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (0, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (0, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (0, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (-1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (-1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 1), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 1), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, -1), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, -1), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 1), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 1), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (+1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (+1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 1))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 1))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, -1))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, -1))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 1))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 1))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[i])",
      "mutated_line": "return 0 < i < len(grid) and 0 <= j < len(grid[i])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 < i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[i])",
      "mutated_line": "return 0 > i < len(grid) and 0 <= j < len(grid[i])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 > i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[i])",
      "mutated_line": "return 0 == i < len(grid) and 0 <= j < len(grid[i])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 == i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[i])",
      "mutated_line": "return 0 <= i < len(grid) and 0 < j < len(grid[i])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 < j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[i])",
      "mutated_line": "return 0 <= i < len(grid) and 0 > j < len(grid[i])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 > j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[i])",
      "mutated_line": "return 0 <= i < len(grid) and 0 == j < len(grid[i])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 == j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if not in_bounds(i, j) or (i, j) in visited:",
      "mutated_line": "if not in_bounds(i, j) or (i, j) not in visited:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) not in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "(next_i, next_j) = (i + direction[0], j + direction[1])",
      "mutated_line": "(next_i, next_j) = (i - direction[0], j + direction[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i - direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "(next_i, next_j) = (i + direction[0], j + direction[1])",
      "mutated_line": "(next_i, next_j) = (i * direction[0], j + direction[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i * direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "(next_i, next_j) = (i + direction[0], j + direction[1])",
      "mutated_line": "(next_i, next_j) = (i + direction[0], j - direction[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j - direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "(next_i, next_j) = (i + direction[0], j + direction[1])",
      "mutated_line": "(next_i, next_j) = (i + direction[0], j * direction[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j * direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i == len(grid) - 1 or j == len(grid[i]) - 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 or j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "next_reachable += dfs(i + d[0], j + d[1])",
      "mutated_line": "next_reachable -= dfs(i + d[0], j + d[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable -= dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -2), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -2), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -0), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -0), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -0), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -0), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, --1), (1, 0), (-1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, --1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-2, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-2, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-0, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-0, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-0, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-0, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))",
      "mutated_line": "(right, left, down, up) = ((0, 1), (0, -1), (1, 0), (--1, 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (--1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[i])",
      "mutated_line": "return 1 <= i < len(grid) and 0 <= j < len(grid[i])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 1 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[i])",
      "mutated_line": "return -1 <= i < len(grid) and 0 <= j < len(grid[i])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return -1 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[i])",
      "mutated_line": "return 1 <= i < len(grid) and 0 <= j < len(grid[i])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 1 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[i])",
      "mutated_line": "return 0 <= i < len(grid) and 1 <= j < len(grid[i])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 1 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[i])",
      "mutated_line": "return 0 <= i < len(grid) and -1 <= j < len(grid[i])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and -1 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0 <= i < len(grid) and 0 <= j < len(grid[i])",
      "mutated_line": "return 0 <= i < len(grid) and 1 <= j < len(grid[i])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 1 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i != len(grid) - 1 and j == len(grid[i]) - 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i != len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i == len(grid) - 1 and j != len(grid[i]) - 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j != len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(next_i, next_j) = (i + direction[0], j + direction[1])",
      "mutated_line": "(next_i, next_j) = (i + direction[1], j + direction[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[1], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(next_i, next_j) = (i + direction[0], j + direction[1])",
      "mutated_line": "(next_i, next_j) = (i + direction[-1], j + direction[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[-1], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(next_i, next_j) = (i + direction[0], j + direction[1])",
      "mutated_line": "(next_i, next_j) = (i + direction[1], j + direction[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[1], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(next_i, next_j) = (i + direction[0], j + direction[1])",
      "mutated_line": "(next_i, next_j) = (i + direction[0], j + direction[2])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[2])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(next_i, next_j) = (i + direction[0], j + direction[1])",
      "mutated_line": "(next_i, next_j) = (i + direction[0], j + direction[0])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[0])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(next_i, next_j) = (i + direction[0], j + direction[1])",
      "mutated_line": "(next_i, next_j) = (i + direction[0], j + direction[0])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[0])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(next_i, next_j) = (i + direction[0], j + direction[1])",
      "mutated_line": "(next_i, next_j) = (i + direction[0], j + direction[-1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[-1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i == len(grid) + 1 and j == len(grid[i]) - 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) + 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i == len(grid) * 1 and j == len(grid[i]) - 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) * 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i == len(grid) - 1 and j == len(grid[i]) + 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) + 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i == len(grid) - 1 and j == len(grid[i]) * 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) * 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "next_reachable += dfs(i + d[0], j + d[1])",
      "mutated_line": "next_reachable += dfs(i - d[0], j + d[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i - d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "next_reachable += dfs(i + d[0], j + d[1])",
      "mutated_line": "next_reachable += dfs(i * d[0], j + d[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i * d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "next_reachable += dfs(i + d[0], j + d[1])",
      "mutated_line": "next_reachable += dfs(i + d[0], j - d[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j - d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "next_reachable += dfs(i + d[0], j + d[1])",
      "mutated_line": "next_reachable += dfs(i + d[0], j * d[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j * d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i == len(grid) - 2 and j == len(grid[i]) - 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 2 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i == len(grid) - 0 and j == len(grid[i]) - 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 0 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i == len(grid) - 0 and j == len(grid[i]) - 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 0 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i == len(grid) - -1 and j == len(grid[i]) - 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - -1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i == len(grid) - 1 and j == len(grid[i]) - 2:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 2:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i == len(grid) - 1 and j == len(grid[i]) - 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 0:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i == len(grid) - 1 and j == len(grid[i]) - 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 0:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i == len(grid) - 1 and j == len(grid[i]) - 1:",
      "mutated_line": "if i == len(grid) - 1 and j == len(grid[i]) - -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - -1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "next_reachable += dfs(i + d[0], j + d[1])",
      "mutated_line": "next_reachable += dfs(i + d[1], j + d[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[1], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "next_reachable += dfs(i + d[0], j + d[1])",
      "mutated_line": "next_reachable += dfs(i + d[-1], j + d[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[-1], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "next_reachable += dfs(i + d[0], j + d[1])",
      "mutated_line": "next_reachable += dfs(i + d[1], j + d[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[1], j + d[1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "next_reachable += dfs(i + d[0], j + d[1])",
      "mutated_line": "next_reachable += dfs(i + d[0], j + d[2])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[2])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "next_reachable += dfs(i + d[0], j + d[1])",
      "mutated_line": "next_reachable += dfs(i + d[0], j + d[0])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[0])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "next_reachable += dfs(i + d[0], j + d[1])",
      "mutated_line": "next_reachable += dfs(i + d[0], j + d[0])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[0])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "next_reachable += dfs(i + d[0], j + d[1])",
      "mutated_line": "next_reachable += dfs(i + d[0], j + d[-1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_cost_to_valid_path(grid: List[List[int]]) -> int:\n    (right, left, down, up) = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    direction_map = {1: right, 2: left, 3: down, 4: up}\n    directions = [right, left, down, up]\n    visited = set()\n\n    def in_bounds(i, j):\n        return 0 <= i < len(grid) and 0 <= j < len(grid[i])\n\n    def dfs(i, j):\n        if not in_bounds(i, j) or (i, j) in visited:\n            return []\n        visited.add((i, j))\n        sign = grid[i][j]\n        direction = direction_map[sign]\n        (next_i, next_j) = (i + direction[0], j + direction[1])\n        return [(i, j)] + dfs(next_i, next_j)\n    reachable = dfs(0, 0)\n    curr_cost = 0\n    while reachable:\n        next_reachable = []\n        for (i, j) in reachable:\n            if i == len(grid) - 1 and j == len(grid[i]) - 1:\n                return curr_cost\n            for d in directions:\n                next_reachable += dfs(i + d[0], j + d[-1])\n        reachable = next_reachable\n        curr_cost += 1\n    return -1"
    }
  ]
}