{
  "task_id": "taco_10020",
  "entry_point": "max_possible_score",
  "mutant_count": 15,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][n - i - 1])\n    return total_sum - min(diagonal_elements)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "total_sum = 0",
      "mutated_line": "total_sum = 1",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\n    Calculate the maximum possible score for moving a chip from the top-left to the bottom-right cell\n    in a square grid with teleportation rules.\n\n    Parameters:\n    n (int): The number of rows and columns in the grid.\n    grid (list of list of int): The square grid containing non-negative integers.\n\n    Returns:\n    int: The maximum possible score achievable.\n    \"\"\"\n    total_sum = 1\n    for row in grid:\n        total_sum += sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][n - i - 1])\n    return total_sum - min(diagonal_elements)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "total_sum = 0",
      "mutated_line": "total_sum = -1",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\n    Calculate the maximum possible score for moving a chip from the top-left to the bottom-right cell\n    in a square grid with teleportation rules.\n\n    Parameters:\n    n (int): The number of rows and columns in the grid.\n    grid (list of list of int): The square grid containing non-negative integers.\n\n    Returns:\n    int: The maximum possible score achievable.\n    \"\"\"\n    total_sum = -1\n    for row in grid:\n        total_sum += sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][n - i - 1])\n    return total_sum - min(diagonal_elements)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "total_sum = 0",
      "mutated_line": "total_sum = 1",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\n    Calculate the maximum possible score for moving a chip from the top-left to the bottom-right cell\n    in a square grid with teleportation rules.\n\n    Parameters:\n    n (int): The number of rows and columns in the grid.\n    grid (list of list of int): The square grid containing non-negative integers.\n\n    Returns:\n    int: The maximum possible score achievable.\n    \"\"\"\n    total_sum = 1\n    for row in grid:\n        total_sum += sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][n - i - 1])\n    return total_sum - min(diagonal_elements)"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "total_sum += sum(row)",
      "mutated_line": "total_sum -= sum(row)",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\n    Calculate the maximum possible score for moving a chip from the top-left to the bottom-right cell\n    in a square grid with teleportation rules.\n\n    Parameters:\n    n (int): The number of rows and columns in the grid.\n    grid (list of list of int): The square grid containing non-negative integers.\n\n    Returns:\n    int: The maximum possible score achievable.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum -= sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][n - i - 1])\n    return total_sum - min(diagonal_elements)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return total_sum - min(diagonal_elements)",
      "mutated_line": "return total_sum + min(diagonal_elements)",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\n    Calculate the maximum possible score for moving a chip from the top-left to the bottom-right cell\n    in a square grid with teleportation rules.\n\n    Parameters:\n    n (int): The number of rows and columns in the grid.\n    grid (list of list of int): The square grid containing non-negative integers.\n\n    Returns:\n    int: The maximum possible score achievable.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][n - i - 1])\n    return total_sum + min(diagonal_elements)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return total_sum - min(diagonal_elements)",
      "mutated_line": "return total_sum * min(diagonal_elements)",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\n    Calculate the maximum possible score for moving a chip from the top-left to the bottom-right cell\n    in a square grid with teleportation rules.\n\n    Parameters:\n    n (int): The number of rows and columns in the grid.\n    grid (list of list of int): The square grid containing non-negative integers.\n\n    Returns:\n    int: The maximum possible score achievable.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][n - i - 1])\n    return total_sum * min(diagonal_elements)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "diagonal_elements.append(grid[i][n - i - 1])",
      "mutated_line": "diagonal_elements.append(grid[i][n - i + 1])",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\n    Calculate the maximum possible score for moving a chip from the top-left to the bottom-right cell\n    in a square grid with teleportation rules.\n\n    Parameters:\n    n (int): The number of rows and columns in the grid.\n    grid (list of list of int): The square grid containing non-negative integers.\n\n    Returns:\n    int: The maximum possible score achievable.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][n - i + 1])\n    return total_sum - min(diagonal_elements)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "diagonal_elements.append(grid[i][n - i - 1])",
      "mutated_line": "diagonal_elements.append(grid[i][(n - i) * 1])",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\n    Calculate the maximum possible score for moving a chip from the top-left to the bottom-right cell\n    in a square grid with teleportation rules.\n\n    Parameters:\n    n (int): The number of rows and columns in the grid.\n    grid (list of list of int): The square grid containing non-negative integers.\n\n    Returns:\n    int: The maximum possible score achievable.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][(n - i) * 1])\n    return total_sum - min(diagonal_elements)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "diagonal_elements.append(grid[i][n - i - 1])",
      "mutated_line": "diagonal_elements.append(grid[i][n + i - 1])",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\n    Calculate the maximum possible score for moving a chip from the top-left to the bottom-right cell\n    in a square grid with teleportation rules.\n\n    Parameters:\n    n (int): The number of rows and columns in the grid.\n    grid (list of list of int): The square grid containing non-negative integers.\n\n    Returns:\n    int: The maximum possible score achievable.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][n + i - 1])\n    return total_sum - min(diagonal_elements)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "diagonal_elements.append(grid[i][n - i - 1])",
      "mutated_line": "diagonal_elements.append(grid[i][n * i - 1])",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\n    Calculate the maximum possible score for moving a chip from the top-left to the bottom-right cell\n    in a square grid with teleportation rules.\n\n    Parameters:\n    n (int): The number of rows and columns in the grid.\n    grid (list of list of int): The square grid containing non-negative integers.\n\n    Returns:\n    int: The maximum possible score achievable.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][n * i - 1])\n    return total_sum - min(diagonal_elements)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "diagonal_elements.append(grid[i][n - i - 1])",
      "mutated_line": "diagonal_elements.append(grid[i][n - i - 2])",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\n    Calculate the maximum possible score for moving a chip from the top-left to the bottom-right cell\n    in a square grid with teleportation rules.\n\n    Parameters:\n    n (int): The number of rows and columns in the grid.\n    grid (list of list of int): The square grid containing non-negative integers.\n\n    Returns:\n    int: The maximum possible score achievable.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][n - i - 2])\n    return total_sum - min(diagonal_elements)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "diagonal_elements.append(grid[i][n - i - 1])",
      "mutated_line": "diagonal_elements.append(grid[i][n - i - 0])",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\n    Calculate the maximum possible score for moving a chip from the top-left to the bottom-right cell\n    in a square grid with teleportation rules.\n\n    Parameters:\n    n (int): The number of rows and columns in the grid.\n    grid (list of list of int): The square grid containing non-negative integers.\n\n    Returns:\n    int: The maximum possible score achievable.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][n - i - 0])\n    return total_sum - min(diagonal_elements)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "diagonal_elements.append(grid[i][n - i - 1])",
      "mutated_line": "diagonal_elements.append(grid[i][n - i - 0])",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\n    Calculate the maximum possible score for moving a chip from the top-left to the bottom-right cell\n    in a square grid with teleportation rules.\n\n    Parameters:\n    n (int): The number of rows and columns in the grid.\n    grid (list of list of int): The square grid containing non-negative integers.\n\n    Returns:\n    int: The maximum possible score achievable.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][n - i - 0])\n    return total_sum - min(diagonal_elements)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "diagonal_elements.append(grid[i][n - i - 1])",
      "mutated_line": "diagonal_elements.append(grid[i][n - i - -1])",
      "code": "def max_possible_score(n, grid):\n    \"\"\"\n    Calculate the maximum possible score for moving a chip from the top-left to the bottom-right cell\n    in a square grid with teleportation rules.\n\n    Parameters:\n    n (int): The number of rows and columns in the grid.\n    grid (list of list of int): The square grid containing non-negative integers.\n\n    Returns:\n    int: The maximum possible score achievable.\n    \"\"\"\n    total_sum = 0\n    for row in grid:\n        total_sum += sum(row)\n    diagonal_elements = []\n    for i in range(n):\n        diagonal_elements.append(grid[i][n - i - -1])\n    return total_sum - min(diagonal_elements)"
    }
  ]
}