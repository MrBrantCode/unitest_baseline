{
  "task_id": "taco_804",
  "entry_point": "find_max_total_beauty",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if m == 'C':",
      "mutated_line": "if m != 'C':",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m != 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][0] + fd[0][0] if fc or fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc or fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][0] - fd[0][0] if fc and fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] - fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][0] * fd[0][0] if fc and fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] * fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 1",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 1\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][0] + fd[0][0] if fc and fd else -1",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else -1\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 1",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 1\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(len(l) - 1):",
      "mutated_line": "for i in range(len(l) + 1):",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) + 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(len(l) - 1):",
      "mutated_line": "for i in range(len(l) * 1):",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) * 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if b1 + l[i + 1][0] <= mx:",
      "mutated_line": "if b1 + l[i + 1][0] < mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] < mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if b1 + l[i + 1][0] <= mx:",
      "mutated_line": "if b1 + l[i + 1][0] > mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] > mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if b1 + l[i + 1][0] <= mx:",
      "mutated_line": "if b1 + l[i + 1][0] == mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] == mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if m == 'C':",
      "mutated_line": "if m == '':",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == '':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if p <= c:",
      "mutated_line": "if p < c:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p < c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if p <= c:",
      "mutated_line": "if p > c:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p > c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if p <= c:",
      "mutated_line": "if p == c:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p == c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif p <= d:",
      "mutated_line": "elif p < d:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p < d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif p <= d:",
      "mutated_line": "elif p > d:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p > d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif p <= d:",
      "mutated_line": "elif p == d:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p == d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "fc.sort(key=operator.itemgetter(0), reverse=True)",
      "mutated_line": "fc.sort(key=operator.itemgetter(0), reverse=False)",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=False)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "fd.sort(key=operator.itemgetter(0), reverse=True)",
      "mutated_line": "fd.sort(key=operator.itemgetter(0), reverse=False)",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=False)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(len(l) - 1):",
      "mutated_line": "for i in range(len(l) - 2):",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 2):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(len(l) - 1):",
      "mutated_line": "for i in range(len(l) - 0):",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 0):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(len(l) - 1):",
      "mutated_line": "for i in range(len(l) - 0):",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 0):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(len(l) - 1):",
      "mutated_line": "for i in range(len(l) - -1):",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - -1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if b1 + l[i + 1][0] <= mx:",
      "mutated_line": "if b1 - l[i + 1][0] <= mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 - l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if b1 + l[i + 1][0] <= mx:",
      "mutated_line": "if b1 * l[i + 1][0] <= mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 * l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for j in range(i + 1, len(l)):",
      "mutated_line": "for j in range(i - 1, len(l)):",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i - 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for j in range(i + 1, len(l)):",
      "mutated_line": "for j in range(i * 1, len(l)):",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i * 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if b1 + b2 <= mx:",
      "mutated_line": "if b1 + b2 < mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 < mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if b1 + b2 <= mx:",
      "mutated_line": "if b1 + b2 > mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 > mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if b1 + b2 <= mx:",
      "mutated_line": "if b1 + b2 == mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 == mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if p1 + p2 <= m:",
      "mutated_line": "if p1 + p2 < m:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 < m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if p1 + p2 <= m:",
      "mutated_line": "if p1 + p2 > m:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 > m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if p1 + p2 <= m:",
      "mutated_line": "if p1 + p2 == m:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 == m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "fc.sort(key=operator.itemgetter(0), reverse=True)",
      "mutated_line": "fc.sort(key=operator.itemgetter(1), reverse=True)",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(1), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "fc.sort(key=operator.itemgetter(0), reverse=True)",
      "mutated_line": "fc.sort(key=operator.itemgetter(-1), reverse=True)",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(-1), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "fc.sort(key=operator.itemgetter(0), reverse=True)",
      "mutated_line": "fc.sort(key=operator.itemgetter(1), reverse=True)",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(1), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "fd.sort(key=operator.itemgetter(0), reverse=True)",
      "mutated_line": "fd.sort(key=operator.itemgetter(1), reverse=True)",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(1), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "fd.sort(key=operator.itemgetter(0), reverse=True)",
      "mutated_line": "fd.sort(key=operator.itemgetter(-1), reverse=True)",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(-1), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "fd.sort(key=operator.itemgetter(0), reverse=True)",
      "mutated_line": "fd.sort(key=operator.itemgetter(1), reverse=True)",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(1), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][1] + fd[0][0] if fc and fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][1] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][-1] + fd[0][0] if fc and fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][-1] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][1] + fd[0][0] if fc and fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][1] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][0] + fd[0][1] if fc and fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][1] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][0] + fd[0][-1] if fc and fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][-1] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][0] + fd[0][1] if fc and fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][1] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(i + 1, len(l)):",
      "mutated_line": "for j in range(i + 2, len(l)):",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 2, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(i + 1, len(l)):",
      "mutated_line": "for j in range(i + 0, len(l)):",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 0, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(i + 1, len(l)):",
      "mutated_line": "for j in range(i + 0, len(l)):",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 0, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for j in range(i + 1, len(l)):",
      "mutated_line": "for j in range(i + -1, len(l)):",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + -1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if b1 + b2 <= mx:",
      "mutated_line": "if b1 - b2 <= mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 - b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if b1 + b2 <= mx:",
      "mutated_line": "if b1 * b2 <= mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 * b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if p1 + p2 <= m:",
      "mutated_line": "if p1 - p2 <= m:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 - p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if p1 + p2 <= m:",
      "mutated_line": "if p1 * p2 <= m:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 * p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "mx = b1 + b2",
      "mutated_line": "mx = b1 - b2",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 - b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "mx = b1 + b2",
      "mutated_line": "mx = b1 * b2",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 * b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[1][0] + fd[0][0] if fc and fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[1][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[-1][0] + fd[0][0] if fc and fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[-1][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[1][0] + fd[0][0] if fc and fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[1][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][0] + fd[1][0] if fc and fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[1][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][0] + fd[-1][0] if fc and fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[-1][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = fc[0][0] + fd[0][0] if fc and fd else 0",
      "mutated_line": "mx = fc[0][0] + fd[1][0] if fc and fd else 0",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[1][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if b1 + l[i + 1][0] <= mx:",
      "mutated_line": "if b1 + l[i + 1][1] <= mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][1] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if b1 + l[i + 1][0] <= mx:",
      "mutated_line": "if b1 + l[i + 1][-1] <= mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][-1] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if b1 + l[i + 1][0] <= mx:",
      "mutated_line": "if b1 + l[i + 1][1] <= mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 1][1] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if b1 + l[i + 1][0] <= mx:",
      "mutated_line": "if b1 + l[i - 1][0] <= mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i - 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if b1 + l[i + 1][0] <= mx:",
      "mutated_line": "if b1 + l[i * 1][0] <= mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i * 1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if b1 + l[i + 1][0] <= mx:",
      "mutated_line": "if b1 + l[i + 2][0] <= mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 2][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if b1 + l[i + 1][0] <= mx:",
      "mutated_line": "if b1 + l[i + 0][0] <= mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 0][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if b1 + l[i + 1][0] <= mx:",
      "mutated_line": "if b1 + l[i + 0][0] <= mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + 0][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if b1 + l[i + 1][0] <= mx:",
      "mutated_line": "if b1 + l[i + -1][0] <= mx:",
      "code": "import operator\n\ndef find_max_total_beauty(n, c, d, fountains):\n\n    def maxl(l, m, mx):\n        for i in range(len(l) - 1):\n            (b1, p1) = l[i]\n            if b1 + l[i + -1][0] <= mx:\n                break\n            for j in range(i + 1, len(l)):\n                (b2, p2) = l[j]\n                if b1 + b2 <= mx:\n                    break\n                if p1 + p2 <= m:\n                    mx = b1 + b2\n                    break\n        return mx\n    fc = []\n    fd = []\n    for (b, p, m) in fountains:\n        if m == 'C':\n            if p <= c:\n                fc.append((b, p))\n        elif p <= d:\n            fd.append((b, p))\n    fc.sort(key=operator.itemgetter(0), reverse=True)\n    fd.sort(key=operator.itemgetter(0), reverse=True)\n    mx = fc[0][0] + fd[0][0] if fc and fd else 0\n    mx = maxl(fc, c, mx)\n    mx = maxl(fd, d, mx)\n    return mx"
    }
  ]
}