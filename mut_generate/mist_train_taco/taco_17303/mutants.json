{
  "task_id": "taco_17303",
  "entry_point": "find_valid_partition",
  "mutant_count": 89,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 2,
      "original_line": "if S.count('0') == 0 or S.count('1') == 0:",
      "mutated_line": "if S.count('0') == 0 and S.count('1') == 0:",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 and S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if len(p) == N:",
      "mutated_line": "if len(p) != N:",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) != N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if S.count('0') == 0 or S.count('1') == 0:",
      "mutated_line": "if S.count('0') != 0 or S.count('1') == 0:",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') != 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if S.count('0') == 0 or S.count('1') == 0:",
      "mutated_line": "if S.count('0') == 0 or S.count('1') != 0:",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') != 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return +1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if S[i] == '1':",
      "mutated_line": "if S[i] != '1':",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] != '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) or len(p) == i + 1 or i + 1 < N:",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) or len(p) == i + 1 or i + 1 < N:\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if len(p) == N:",
      "mutated_line": "if len(p) != N:",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) != N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return +1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if S.count('0') == 0 or S.count('1') == 0:",
      "mutated_line": "if S.count('0') == 1 or S.count('1') == 0:",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 1 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if S.count('0') == 0 or S.count('1') == 0:",
      "mutated_line": "if S.count('0') == -1 or S.count('1') == 0:",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == -1 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if S.count('0') == 0 or S.count('1') == 0:",
      "mutated_line": "if S.count('0') == 1 or S.count('1') == 0:",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 1 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if S.count('0') == 0 or S.count('1') == 0:",
      "mutated_line": "if S.count('0') == 0 or S.count('1') == 1:",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 1:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if S.count('0') == 0 or S.count('1') == 0:",
      "mutated_line": "if S.count('0') == 0 or S.count('1') == -1:",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == -1:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if S.count('0') == 0 or S.count('1') == 0:",
      "mutated_line": "if S.count('0') == 0 or S.count('1') == 1:",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 1:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -2\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -0\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -0\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return --1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if S[i] == '1':",
      "mutated_line": "if S[i] == '':",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') != len(p) and len(p) == i + 1 and (i + 1 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') != len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) != i + 1 and (i + 1 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) != i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 <= N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 <= N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 >= N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 >= N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 != N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 != N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif len(p) == S.count('1'):",
      "mutated_line": "elif len(p) != S.count('1'):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) != S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -2"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return --1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if S.count('0') == 0 or S.count('1') == 0:",
      "mutated_line": "if S.count('') == 0 or S.count('1') == 0:",
      "code": "def find_valid_partition(N, S):\n    if S.count('') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if S.count('0') == 0 or S.count('1') == 0:",
      "mutated_line": "if S.count('0') == 0 or S.count('') == 0:",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "p.append(i + 1)",
      "mutated_line": "p.append(i - 1)",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i - 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "p.append(i + 1)",
      "mutated_line": "p.append(i * 1)",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i * 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i - 1 and (i + 1 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i - 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i * 1 and (i + 1 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i * 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i - 1 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i - 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i * 1 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i * 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(i + 2, N + 1):",
      "mutated_line": "for j in range(i - 2, N + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i - 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(i + 2, N + 1):",
      "mutated_line": "for j in range(i * 2, N + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i * 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(i + 2, N + 1):",
      "mutated_line": "for j in range(i + 2, N - 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N - 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for j in range(i + 2, N + 1):",
      "mutated_line": "for j in range(i + 2, N * 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N * 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "k = 2 * N",
      "mutated_line": "k = 2 / N",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 / N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "k = 2 * N",
      "mutated_line": "k = 2 + N",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 + N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "k = 2 * N",
      "mutated_line": "k = 2 ** N",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 ** N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p.append(i + 1)",
      "mutated_line": "p.append(i + 2)",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 2)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p.append(i + 1)",
      "mutated_line": "p.append(i + 0)",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 0)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p.append(i + 1)",
      "mutated_line": "p.append(i + 0)",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 0)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p.append(i + 1)",
      "mutated_line": "p.append(i + -1)",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + -1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i + 2 and (i + 1 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 2 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i + 0 and (i + 1 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 0 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i + 0 and (i + 1 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 0 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i + -1 and (i + 1 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + -1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 2 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 2 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 0 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 0 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 0 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 0 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):",
      "mutated_line": "if S.count('1') == len(p) and len(p) == i + 1 and (i + -1 < N):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + -1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i + 2, N + 1):",
      "mutated_line": "for j in range(i + 3, N + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 3, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i + 2, N + 1):",
      "mutated_line": "for j in range(i + 1, N + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 1, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i + 2, N + 1):",
      "mutated_line": "for j in range(i + 0, N + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 0, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i + 2, N + 1):",
      "mutated_line": "for j in range(i + 1, N + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 1, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i + 2, N + 1):",
      "mutated_line": "for j in range(i + -2, N + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + -2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i + 2, N + 1):",
      "mutated_line": "for j in range(i + 2, N + 2):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 2):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i + 2, N + 1):",
      "mutated_line": "for j in range(i + 2, N + 0):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 0):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i + 2, N + 1):",
      "mutated_line": "for j in range(i + 2, N + 0):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 0):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(i + 2, N + 1):",
      "mutated_line": "for j in range(i + 2, N + -1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + -1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif len(p) == S.count('1'):",
      "mutated_line": "elif len(p) == S.count(''):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count(''):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 2 * N",
      "mutated_line": "k = 3 * N",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 3 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 2 * N",
      "mutated_line": "k = 1 * N",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 1 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 2 * N",
      "mutated_line": "k = 0 * N",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 0 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 2 * N",
      "mutated_line": "k = 1 * N",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 1 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k = 2 * N",
      "mutated_line": "k = -2 * N",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = -2 * N\n            for j in range(k - (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k - (N - len(p)) - 1, k + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) - 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range((k - (N - len(p))) * 1, k + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range((k - (N - len(p))) * 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k - (N - len(p)) + 1, k - 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k - 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k - (N - len(p)) + 1, k * 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k * 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k + (N - len(p)) + 1, k + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k + (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k * (N - len(p)) + 1, k + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k * (N - len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k - (N - len(p)) + 2, k + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 2, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k - (N - len(p)) + 0, k + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 0, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k - (N - len(p)) + 0, k + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 0, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k - (N - len(p)) + -1, k + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + -1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k - (N - len(p)) + 1, k + 2):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 2):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k - (N - len(p)) + 1, k + 0):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 0):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k - (N - len(p)) + 1, k + 0):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + 0):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k - (N - len(p)) + 1, k + -1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N - len(p)) + 1, k + -1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k - (N + len(p)) + 1, k + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - (N + len(p)) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(k - (N - len(p)) + 1, k + 1):",
      "mutated_line": "for j in range(k - N * len(p) + 1, k + 1):",
      "code": "def find_valid_partition(N, S):\n    if S.count('0') == 0 or S.count('1') == 0:\n        return -1\n    p = []\n    for i in range(len(S)):\n        if S[i] == '1':\n            p.append(i + 1)\n        if S.count('1') == len(p) and len(p) == i + 1 and (i + 1 < N):\n            for j in range(i + 2, N + 1):\n                p.append(j)\n        if len(p) == N:\n            break\n        elif len(p) == S.count('1'):\n            k = 2 * N\n            for j in range(k - N * len(p) + 1, k + 1):\n                p.append(j)\n    if len(p) == N:\n        return p\n    else:\n        return -1"
    }
  ]
}