{
  "task_id": "taco_9883",
  "entry_point": "min_moves_to_single_chip",
  "mutant_count": 257,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 1\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ret = 0",
      "mutated_line": "ret = -1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = -1\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 1\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "f = [0] * (n + 1)",
      "mutated_line": "f = [0] / (n + 1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] / (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "f = [0] * (n + 1)",
      "mutated_line": "f = [0] + (n + 1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] + (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "f = [0] * (n + 1)",
      "mutated_line": "f = [0] ** (n + 1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] ** (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) / 2",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) / 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) * 2",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) * 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 1\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = -1\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 1\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if g[0][right] == '*':",
      "mutated_line": "if g[0][right] != '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] != '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt -= 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if g[1][right] == '*':",
      "mutated_line": "if g[1][right] != '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] != '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt -= 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret - (1 if cnt == 2 else 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret - (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret * (1 if cnt == 2 else 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret * (1 if cnt == 2 else 0)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "left, right = -1, 0",
      "mutated_line": "(left, right) = (+1, 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (+1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "left, right = -1, 0",
      "mutated_line": "(left, right) = (-1, 1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 1)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "left, right = -1, 0",
      "mutated_line": "(left, right) = (-1, -1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, -1)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "left, right = -1, 0",
      "mutated_line": "(left, right) = (-1, 1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 1)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "if g[0][i] == '*' or g[1][i] == '*':",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' and g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "f = [0] * (n + 1)",
      "mutated_line": "f = [0] * (n - 1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n - 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "f = [0] * (n + 1)",
      "mutated_line": "f = [0] * (n * 1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n * 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left - right) // 2",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left - right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = left * right // 2",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = left * right // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 3",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 3\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 1\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 0\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 1\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // -2",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // -2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "ret += 1",
      "mutated_line": "ret -= 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret -= 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' or g[1][i] == '*' or g[0][i + 1] == '.' or (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' or g[1][i] == '*' or g[0][i + 1] == '.' or (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "ret += 2",
      "mutated_line": "ret -= 2",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret -= 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if g[0][i] == '*':",
      "mutated_line": "if g[0][i] != '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] != '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "ret += 1",
      "mutated_line": "ret -= 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret -= 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if g[1][i] == '*':",
      "mutated_line": "if g[1][i] != '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] != '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "ret += 1",
      "mutated_line": "ret -= 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret -= 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if g[0][right] == '*':",
      "mutated_line": "if g[0][right] == '':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 2\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 0\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 0\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += -1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if g[1][right] == '*':",
      "mutated_line": "if g[1][right] == '':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 2\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 0\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 0\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += -1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "left, right = -1, 0",
      "mutated_line": "(left, right) = (-2, 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-2, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "left, right = -1, 0",
      "mutated_line": "(left, right) = (-0, 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-0, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "left, right = -1, 0",
      "mutated_line": "(left, right) = (-0, 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-0, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "left, right = -1, 0",
      "mutated_line": "(left, right) = (--1, 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (--1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if g[0][i] == '*' or g[1][i] == '*':",
      "mutated_line": "if g[0][i] != '*' or g[1][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] != '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if g[0][i] == '*' or g[1][i] == '*':",
      "mutated_line": "if g[0][i] == '*' or g[1][i] != '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] != '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if left == -1:",
      "mutated_line": "if left != -1:",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left != -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [0] * (n + 1)",
      "mutated_line": "f = [1] * (n + 1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [1] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [0] * (n + 1)",
      "mutated_line": "f = [-1] * (n + 1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [-1] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [0] * (n + 1)",
      "mutated_line": "f = [1] * (n + 1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [1] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [0] * (n + 1)",
      "mutated_line": "f = [0] * (n + 2)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 2)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [0] * (n + 1)",
      "mutated_line": "f = [0] * (n + 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 0)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [0] * (n + 1)",
      "mutated_line": "f = [0] * (n + 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 0)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "f = [0] * (n + 1)",
      "mutated_line": "f = [0] * (n + -1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + -1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' or g[1][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' or g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ret += 1",
      "mutated_line": "ret += 2",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ret += 1",
      "mutated_line": "ret += 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 0\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ret += 1",
      "mutated_line": "ret += 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 0\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ret += 1",
      "mutated_line": "ret += -1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += -1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] != '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] != '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] != '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] != '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] != '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] != '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] != '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] != '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + 1] = 2",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 2\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + 1] = 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 0\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + 1] = 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 0\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + 1] = -1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = -1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ret += 2",
      "mutated_line": "ret += 3",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 3\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ret += 2",
      "mutated_line": "ret += 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ret += 2",
      "mutated_line": "ret += 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 0\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ret += 2",
      "mutated_line": "ret += 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ret += 2",
      "mutated_line": "ret += -2",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += -2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if g[0][i] == '*':",
      "mutated_line": "if g[0][i] == '':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' or g[1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' or g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret += 1",
      "mutated_line": "ret += 2",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 2\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret += 1",
      "mutated_line": "ret += 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 0\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret += 1",
      "mutated_line": "ret += 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 0\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret += 1",
      "mutated_line": "ret += -1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += -1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if g[1][i] == '*':",
      "mutated_line": "if g[1][i] == '':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[1][i + 1] == '.' or g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' or g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ret += 1",
      "mutated_line": "ret += 2",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 2\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ret += 1",
      "mutated_line": "ret += 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 0\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ret += 1",
      "mutated_line": "ret += 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 0\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ret += 1",
      "mutated_line": "ret += -1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += -1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret + (1 if cnt != 2 else 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt != 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret + (2 if cnt == 2 else 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (2 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret + (0 if cnt == 2 else 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (0 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret + (0 if cnt == 2 else 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (0 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret + (-1 if cnt == 2 else 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (-1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret + (1 if cnt == 2 else 1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 1)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret + (1 if cnt == 2 else -1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else -1)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret + (1 if cnt == 2 else 1)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 1)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if g[0][i] == '*' or g[1][i] == '*':",
      "mutated_line": "if g[0][i] == '' or g[1][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if g[0][i] == '*' or g[1][i] == '*':",
      "mutated_line": "if g[0][i] == '*' or g[1][i] == '':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "if left == -1:",
      "mutated_line": "if left == +1:",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == +1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] != '.' and g[1][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] != '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[1][i + 1] != '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] != '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + 1] = 2",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 2\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + 1] = 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 0\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + 1] = 0",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 0\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + 1] = -1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = -1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == ''):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == ''):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i - 1] = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i - 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i * 1] = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i * 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i + 1] != '.' and g[1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] != '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[1][i] != '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] != '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[0][i + 1] = '*'",
      "mutated_line": "g[0][i + 1] = ''",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = ''\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[1][i + 1] != '.' and g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] != '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[1][i + 1] == '.' and g[0][i] != '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] != '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "g[1][i + 1] = '*'",
      "mutated_line": "g[1][i + 1] = ''",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = ''\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if g[0][right] == '*':",
      "mutated_line": "if g[1][right] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[1][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if g[0][right] == '*':",
      "mutated_line": "if g[-1][right] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[-1][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if g[0][right] == '*':",
      "mutated_line": "if g[1][right] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[1][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if g[1][right] == '*':",
      "mutated_line": "if g[2][right] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[2][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if g[1][right] == '*':",
      "mutated_line": "if g[0][right] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[0][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if g[1][right] == '*':",
      "mutated_line": "if g[0][right] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[0][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if g[1][right] == '*':",
      "mutated_line": "if g[-1][right] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[-1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret + (1 if cnt == 3 else 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 3 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret + (1 if cnt == 1 else 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 1 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret + (1 if cnt == 0 else 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 0 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret + (1 if cnt == 1 else 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 1 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return ret + (1 if cnt == 2 else 0)",
      "mutated_line": "return ret + (1 if cnt == -2 else 0)",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == -2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if left == -1:",
      "mutated_line": "if left == -2:",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -2:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if left == -1:",
      "mutated_line": "if left == -0:",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -0:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if left == -1:",
      "mutated_line": "if left == -0:",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -0:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if left == -1:",
      "mutated_line": "if left == --1:",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == --1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] == '' and g[1][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i - 1] = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i - 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i * 1] = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i * 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i - 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i - 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i * 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i * 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i - 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i - 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i * 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i * 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + 2] = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 2] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + 0] = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 0] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + 0] = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 0] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + -1] = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + -1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if g[0][i] == '*':",
      "mutated_line": "if g[1][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[1][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if g[0][i] == '*':",
      "mutated_line": "if g[-1][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[-1][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if g[0][i] == '*':",
      "mutated_line": "if g[1][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[1][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i + 1] == '' and g[1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[1][i] == '':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "g[0][i + 1] = '*'",
      "mutated_line": "g[0][i - 1] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i - 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "g[0][i + 1] = '*'",
      "mutated_line": "g[0][i * 1] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i * 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if g[1][i] == '*':",
      "mutated_line": "if g[2][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[2][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if g[1][i] == '*':",
      "mutated_line": "if g[0][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[0][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if g[1][i] == '*':",
      "mutated_line": "if g[0][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[0][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if g[1][i] == '*':",
      "mutated_line": "if g[-1][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[-1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[1][i + 1] == '' and g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[1][i + 1] == '.' and g[0][i] == '':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "g[1][i + 1] = '*'",
      "mutated_line": "g[1][i - 1] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i - 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "g[1][i + 1] = '*'",
      "mutated_line": "g[1][i * 1] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i * 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if g[0][i] == '*' or g[1][i] == '*':",
      "mutated_line": "if g[1][i] == '*' or g[1][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[1][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if g[0][i] == '*' or g[1][i] == '*':",
      "mutated_line": "if g[-1][i] == '*' or g[1][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[-1][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if g[0][i] == '*' or g[1][i] == '*':",
      "mutated_line": "if g[1][i] == '*' or g[1][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[1][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if g[0][i] == '*' or g[1][i] == '*':",
      "mutated_line": "if g[0][i] == '*' or g[2][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[2][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if g[0][i] == '*' or g[1][i] == '*':",
      "mutated_line": "if g[0][i] == '*' or g[0][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[0][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if g[0][i] == '*' or g[1][i] == '*':",
      "mutated_line": "if g[0][i] == '*' or g[0][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[0][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if g[0][i] == '*' or g[1][i] == '*':",
      "mutated_line": "if g[0][i] == '*' or g[-1][i] == '*':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[-1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i - 1] == '.' and g[1][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i - 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i * 1] == '.' and g[1][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i * 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[1][i - 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i - 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[1][i * 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i * 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + 2] = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 2] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + 0] = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 0] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + 0] = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 0] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "f[i + 1] = 1",
      "mutated_line": "f[i + -1] = 1",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + -1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[1][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[1][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[-1][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[-1][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[1][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[1][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[2][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[2][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[0][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[0][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[0][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[0][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[-1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[-1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[1][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[1][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[-1][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[-1][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[1][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[1][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 2] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 2] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 0] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 0] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 0] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 0] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + -1] == '.') and (g[1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + -1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[2][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[2][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[0][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[0][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[0][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[0][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[-1][i + 1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[-1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 2] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 2] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 0] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 0] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 0] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 0] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):",
      "mutated_line": "if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + -1] == '.'):",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + -1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i - 1] == '.' and g[1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i - 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i * 1] == '.' and g[1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i * 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[0][i + 1] = '*'",
      "mutated_line": "g[1][i + 1] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[0][i + 1] = '*'",
      "mutated_line": "g[-1][i + 1] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[-1][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[0][i + 1] = '*'",
      "mutated_line": "g[1][i + 1] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[0][i + 1] = '*'",
      "mutated_line": "g[0][i + 2] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 2] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[0][i + 1] = '*'",
      "mutated_line": "g[0][i + 0] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 0] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[0][i + 1] = '*'",
      "mutated_line": "g[0][i + 0] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 0] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "g[0][i + 1] = '*'",
      "mutated_line": "g[0][i + -1] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + -1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[1][i - 1] == '.' and g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i - 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[1][i * 1] == '.' and g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i * 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "g[1][i + 1] = '*'",
      "mutated_line": "g[2][i + 1] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[2][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "g[1][i + 1] = '*'",
      "mutated_line": "g[0][i + 1] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "g[1][i + 1] = '*'",
      "mutated_line": "g[0][i + 1] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "g[1][i + 1] = '*'",
      "mutated_line": "g[-1][i + 1] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[-1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "g[1][i + 1] = '*'",
      "mutated_line": "g[1][i + 2] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 2] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "g[1][i + 1] = '*'",
      "mutated_line": "g[1][i + 0] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 0] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "g[1][i + 1] = '*'",
      "mutated_line": "g[1][i + 0] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 0] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "g[1][i + 1] = '*'",
      "mutated_line": "g[1][i + -1] = '*'",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + -1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[1][i + 1] == '.' and g[1][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[1][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[-1][i + 1] == '.' and g[1][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[-1][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[1][i + 1] == '.' and g[1][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[1][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 2] == '.' and g[1][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 2] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 0] == '.' and g[1][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 0] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 0] == '.' and g[1][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 0] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + -1] == '.' and g[1][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + -1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[2][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[2][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[0][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[0][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[0][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[0][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[-1][i + 1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[-1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[1][i + 2] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 2] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[1][i + 0] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 0] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[1][i + 0] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 0] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if g[0][i + 1] == '.' and g[1][i + 1] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[1][i + -1] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + -1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[1][i + 1] == '.' and g[1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[1][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[-1][i + 1] == '.' and g[1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[-1][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[1][i + 1] == '.' and g[1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[1][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i + 2] == '.' and g[1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 2] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i + 0] == '.' and g[1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 0] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i + 0] == '.' and g[1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 0] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i + -1] == '.' and g[1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + -1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[2][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[2][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[0][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[0][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if g[0][i + 1] == '.' and g[1][i] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[-1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[-1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[2][i + 1] == '.' and g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[2][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[0][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[0][i + 1] == '.' and g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[0][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[-1][i + 1] == '.' and g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[-1][i + 1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[1][i + 2] == '.' and g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 2] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[1][i + 0] == '.' and g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 0] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[1][i + 0] == '.' and g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 0] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[1][i + -1] == '.' and g[0][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + -1] == '.' and g[0][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[1][i + 1] == '.' and g[1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[1][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[1][i + 1] == '.' and g[-1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[-1][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if g[1][i + 1] == '.' and g[0][i] == '.':",
      "mutated_line": "if g[1][i + 1] == '.' and g[1][i] == '.':",
      "code": "def min_moves_to_single_chip(n, s1, s2):\n    g = [list(s1), list(s2)]\n    (left, right) = (-1, 0)\n    for i in range(n):\n        if g[0][i] == '*' or g[1][i] == '*':\n            if left == -1:\n                left = i\n            right = i\n    ret = 0\n    f = [0] * (n + 1)\n    mid = (left + right) // 2\n    for i in range(right):\n        if f[i]:\n            if g[0][i + 1] == '.' and g[1][i + 1] == '.':\n                f[i + 1] = 1\n            ret += 1\n            continue\n        if g[0][i] == '*' and g[1][i] == '*' and (g[0][i + 1] == '.') and (g[1][i + 1] == '.'):\n            f[i + 1] = 1\n            ret += 2\n            continue\n        if g[0][i] == '*':\n            if g[0][i + 1] == '.' and g[1][i] == '.':\n                g[0][i + 1] = '*'\n            ret += 1\n        if g[1][i] == '*':\n            if g[1][i + 1] == '.' and g[1][i] == '.':\n                g[1][i + 1] = '*'\n            ret += 1\n    cnt = 0\n    if g[0][right] == '*':\n        cnt += 1\n    if g[1][right] == '*':\n        cnt += 1\n    return ret + (1 if cnt == 2 else 0)"
    }
  ]
}