{
  "task_id": "taco_13682",
  "entry_point": "calculate_special_xor",
  "mutant_count": 185,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 1\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = -1\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 1\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.seg = [0] * self.n * 4",
      "mutated_line": "self.seg = [0] * self.n / 4",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n / 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.seg = [0] * self.n * 4",
      "mutated_line": "self.seg = [0] * self.n + 4",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n + 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.seg = [0] * self.n * 4",
      "mutated_line": "self.seg = ([0] * self.n) ** 4",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = ([0] * self.n) ** 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if low > r or l > high:",
      "mutated_line": "if low > r and l > high:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r and l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if low >= l and high <= r:",
      "mutated_line": "if low >= l or high <= r:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l or high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return left ^ right",
      "mutated_line": "return left | right",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left | right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(1, 0, N - 1, i - 1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(1, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(-1, 0, N - 1, i - 1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(-1, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(1, 0, N - 1, i - 1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(1, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 1, N - 1, i - 1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 1, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, -1, N - 1, i - 1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, -1, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 1, N - 1, i - 1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 1, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N + 1, i - 1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N + 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N * 1, i - 1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N * 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 1, i + 1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i + 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 1, i * 1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i * 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 1, i - 1, j + 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j + 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 1, i - 1, j * 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j * 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "res.append(ans ^ temp)",
      "mutated_line": "res.append(ans | temp)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans | temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.seg = [0] * self.n * 4",
      "mutated_line": "self.seg = [0] / self.n * 4",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] / self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.seg = [0] * self.n * 4",
      "mutated_line": "self.seg = ([0] + self.n) * 4",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = ([0] + self.n) * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "self.seg = [0] * self.n * 4",
      "mutated_line": "self.seg = [0] ** self.n * 4",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] ** self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.seg = [0] * self.n * 4",
      "mutated_line": "self.seg = [0] * self.n * 5",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 5\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.seg = [0] * self.n * 4",
      "mutated_line": "self.seg = [0] * self.n * 3",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 3\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.seg = [0] * self.n * 4",
      "mutated_line": "self.seg = [0] * self.n * 0",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 0\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.seg = [0] * self.n * 4",
      "mutated_line": "self.seg = [0] * self.n * 1",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 1\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.seg = [0] * self.n * 4",
      "mutated_line": "self.seg = [0] * self.n * -4",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * -4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if low == high:",
      "mutated_line": "if low != high:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low != high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] | self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] | self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, self.n - 1)",
      "mutated_line": "build(1, 0, self.n - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(1, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, self.n - 1)",
      "mutated_line": "build(-1, 0, self.n - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(-1, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, self.n - 1)",
      "mutated_line": "build(1, 0, self.n - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(1, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, self.n - 1)",
      "mutated_line": "build(0, 1, self.n - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 1, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, self.n - 1)",
      "mutated_line": "build(0, -1, self.n - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, -1, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, self.n - 1)",
      "mutated_line": "build(0, 1, self.n - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 1, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "build(0, 0, self.n - 1)",
      "mutated_line": "build(0, 0, self.n + 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n + 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "build(0, 0, self.n - 1)",
      "mutated_line": "build(0, 0, self.n * 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n * 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if low > r or l > high:",
      "mutated_line": "if low >= r or l > high:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low >= r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if low > r or l > high:",
      "mutated_line": "if low <= r or l > high:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low <= r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if low > r or l > high:",
      "mutated_line": "if low != r or l > high:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low != r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if low > r or l > high:",
      "mutated_line": "if low > r or l >= high:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l >= high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if low > r or l > high:",
      "mutated_line": "if low > r or l <= high:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l <= high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if low > r or l > high:",
      "mutated_line": "if low > r or l != high:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l != high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 1\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return -1\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 1\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if low >= l and high <= r:",
      "mutated_line": "if low > l and high <= r:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low > l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if low >= l and high <= r:",
      "mutated_line": "if low < l and high <= r:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low < l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if low >= l and high <= r:",
      "mutated_line": "if low == l and high <= r:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low == l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if low >= l and high <= r:",
      "mutated_line": "if low >= l and high < r:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high < r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if low >= l and high <= r:",
      "mutated_line": "if low >= l and high > r:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high > r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if low >= l and high <= r:",
      "mutated_line": "if low >= l and high == r:",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high == r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mid = low + high >> 1",
      "mutated_line": "mid = low - high >> 1",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low - high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "mid = low + high >> 1",
      "mutated_line": "mid = low * high >> 1",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low * high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = low + high >> 1",
      "mutated_line": "mid = low + high >> 2",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 2\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = low + high >> 1",
      "mutated_line": "mid = low + high >> 0",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 0\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = low + high >> 1",
      "mutated_line": "mid = low + high >> 0",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 0\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mid = low + high >> 1",
      "mutated_line": "mid = low + high >> -1",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> -1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = self.query(ind * 2 + 1, low, mid, l, r)",
      "mutated_line": "left = self.query(ind * 2 - 1, low, mid, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 - 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = self.query(ind * 2 + 1, low, mid, l, r)",
      "mutated_line": "left = self.query(ind * 2 * 1, low, mid, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 * 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 2 - 2, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 - 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 2 * 2, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 * 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 2 + 2, mid - 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid - 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 2 + 2, mid * 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid * 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 2, i - 1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 2, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 0, i - 1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 0, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 0, i - 1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 0, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - -1, i - 1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - -1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 1, i - 2, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 2, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 1, i - 0, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 0, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 1, i - 0, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 0, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 1, i - -1, j - 1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - -1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 1, i - 1, j - 2)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 2)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 1, i - 1, j - 0)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 0)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 1, i - 1, j - 0)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 0)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "temp = s.query(0, 0, N - 1, i - 1, j - 1)",
      "mutated_line": "temp = s.query(0, 0, N - 1, i - 1, j - -1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - -1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mid = low + high >> 1",
      "mutated_line": "mid = low - high >> 1",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low - high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mid = low + high >> 1",
      "mutated_line": "mid = low * high >> 1",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low * high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mid = low + high >> 1",
      "mutated_line": "mid = low + high >> 2",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 2\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mid = low + high >> 1",
      "mutated_line": "mid = low + high >> 0",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 0\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mid = low + high >> 1",
      "mutated_line": "mid = low + high >> 0",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 0\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mid = low + high >> 1",
      "mutated_line": "mid = low + high >> -1",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> -1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "build(ind * 2 + 1, low, mid)",
      "mutated_line": "build(ind * 2 - 1, low, mid)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 - 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "build(ind * 2 + 1, low, mid)",
      "mutated_line": "build(ind * 2 * 1, low, mid)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 * 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 2 - 2, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 - 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 2 * 2, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 * 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 2 + 2, mid - 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid - 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 2 + 2, mid * 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid * 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, self.n - 1)",
      "mutated_line": "build(0, 0, self.n - 2)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 2)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, self.n - 1)",
      "mutated_line": "build(0, 0, self.n - 0)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 0)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, self.n - 1)",
      "mutated_line": "build(0, 0, self.n - 0)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 0)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "build(0, 0, self.n - 1)",
      "mutated_line": "build(0, 0, self.n - -1)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - -1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = self.query(ind * 2 + 1, low, mid, l, r)",
      "mutated_line": "left = self.query(ind / 2 + 1, low, mid, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind / 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = self.query(ind * 2 + 1, low, mid, l, r)",
      "mutated_line": "left = self.query(ind + 2 + 1, low, mid, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind + 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "left = self.query(ind * 2 + 1, low, mid, l, r)",
      "mutated_line": "left = self.query(ind ** 2 + 1, low, mid, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind ** 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = self.query(ind * 2 + 1, low, mid, l, r)",
      "mutated_line": "left = self.query(ind * 2 + 2, low, mid, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 2, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = self.query(ind * 2 + 1, low, mid, l, r)",
      "mutated_line": "left = self.query(ind * 2 + 0, low, mid, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 0, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = self.query(ind * 2 + 1, low, mid, l, r)",
      "mutated_line": "left = self.query(ind * 2 + 0, low, mid, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 0, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = self.query(ind * 2 + 1, low, mid, l, r)",
      "mutated_line": "left = self.query(ind * 2 + -1, low, mid, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + -1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind / 2 + 2, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind / 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind + 2 + 2, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind + 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind ** 2 + 2, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind ** 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 2 + 3, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 3, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 2 + 1, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 1, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 2 + 0, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 0, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 2 + 1, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 1, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 2 + -2, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + -2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 2 + 2, mid + 2, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 2, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 2 + 2, mid + 0, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 0, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 2 + 2, mid + 0, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 0, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 2 + 2, mid + -1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + -1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.seg = [0] * self.n * 4",
      "mutated_line": "self.seg = [1] * self.n * 4",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [1] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.seg = [0] * self.n * 4",
      "mutated_line": "self.seg = [-1] * self.n * 4",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [-1] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "self.seg = [0] * self.n * 4",
      "mutated_line": "self.seg = [1] * self.n * 4",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [1] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "build(ind * 2 + 1, low, mid)",
      "mutated_line": "build(ind / 2 + 1, low, mid)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind / 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "build(ind * 2 + 1, low, mid)",
      "mutated_line": "build(ind + 2 + 1, low, mid)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind + 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "build(ind * 2 + 1, low, mid)",
      "mutated_line": "build(ind ** 2 + 1, low, mid)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind ** 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(ind * 2 + 1, low, mid)",
      "mutated_line": "build(ind * 2 + 2, low, mid)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 2, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(ind * 2 + 1, low, mid)",
      "mutated_line": "build(ind * 2 + 0, low, mid)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 0, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(ind * 2 + 1, low, mid)",
      "mutated_line": "build(ind * 2 + 0, low, mid)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 0, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(ind * 2 + 1, low, mid)",
      "mutated_line": "build(ind * 2 + -1, low, mid)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + -1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind / 2 + 2, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind / 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind + 2 + 2, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind + 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind ** 2 + 2, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind ** 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 2 + 3, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 3, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 2 + 1, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 1, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 2 + 0, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 0, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 2 + 1, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 1, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 2 + -2, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + -2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 2 + 2, mid + 2, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 2, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 2 + 2, mid + 0, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 0, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 2 + 2, mid + 0, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 0, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 2 + 2, mid + -1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + -1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 - 1] ^ self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 - 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 * 1] ^ self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 * 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 - 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 - 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 * 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 * 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = self.query(ind * 2 + 1, low, mid, l, r)",
      "mutated_line": "left = self.query(ind * 3 + 1, low, mid, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 3 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = self.query(ind * 2 + 1, low, mid, l, r)",
      "mutated_line": "left = self.query(ind * 1 + 1, low, mid, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 1 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = self.query(ind * 2 + 1, low, mid, l, r)",
      "mutated_line": "left = self.query(ind * 0 + 1, low, mid, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 0 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = self.query(ind * 2 + 1, low, mid, l, r)",
      "mutated_line": "left = self.query(ind * 1 + 1, low, mid, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 1 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "left = self.query(ind * 2 + 1, low, mid, l, r)",
      "mutated_line": "left = self.query(ind * -2 + 1, low, mid, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * -2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 3 + 2, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 3 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 1 + 2, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 1 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 0 + 2, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 0 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * 1 + 2, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 1 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "right = self.query(ind * 2 + 2, mid + 1, high, l, r)",
      "mutated_line": "right = self.query(ind * -2 + 2, mid + 1, high, l, r)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * -2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(ind * 2 + 1, low, mid)",
      "mutated_line": "build(ind * 3 + 1, low, mid)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 3 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(ind * 2 + 1, low, mid)",
      "mutated_line": "build(ind * 1 + 1, low, mid)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 1 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(ind * 2 + 1, low, mid)",
      "mutated_line": "build(ind * 0 + 1, low, mid)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 0 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(ind * 2 + 1, low, mid)",
      "mutated_line": "build(ind * 1 + 1, low, mid)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 1 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "build(ind * 2 + 1, low, mid)",
      "mutated_line": "build(ind * -2 + 1, low, mid)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * -2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 3 + 2, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 3 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 1 + 2, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 1 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 0 + 2, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 0 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * 1 + 2, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 1 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "build(ind * 2 + 2, mid + 1, high)",
      "mutated_line": "build(ind * -2 + 2, mid + 1, high)",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * -2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind / 2 + 1] ^ self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind / 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind + 2 + 1] ^ self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind + 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind ** 2 + 1] ^ self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind ** 2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 2] ^ self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 2] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 0] ^ self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 0] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 0] ^ self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 0] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + -1] ^ self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + -1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind / 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind / 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind + 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind + 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind ** 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind ** 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 3]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 3]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 1]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 1]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 0]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 0]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 1]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 1]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + -2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + -2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 3 + 1] ^ self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 3 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 1 + 1] ^ self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 1 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 0 + 1] ^ self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 0 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 1 + 1] ^ self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 1 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * -2 + 1] ^ self.seg[ind * 2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * -2 + 1] ^ self.seg[ind * 2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 3 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 3 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 1 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 1 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 0 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 0 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 1 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 1 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * 2 + 2]",
      "mutated_line": "self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * -2 + 2]",
      "code": "def calculate_special_xor(N, Q, a, query):\n\n    class SegmentTree:\n\n        def __init__(self, arr):\n            self.arr = arr\n            self.n = len(arr)\n            self.seg = [0] * self.n * 4\n\n            def build(ind, low, high):\n                if low == high:\n                    self.seg[ind] = arr[low]\n                    return\n                mid = low + high >> 1\n                build(ind * 2 + 1, low, mid)\n                build(ind * 2 + 2, mid + 1, high)\n                self.seg[ind] = self.seg[ind * 2 + 1] ^ self.seg[ind * -2 + 2]\n            build(0, 0, self.n - 1)\n\n        def query(self, ind, low, high, l, r):\n            if low > r or l > high:\n                return 0\n            if low >= l and high <= r:\n                return self.seg[ind]\n            mid = low + high >> 1\n            left = self.query(ind * 2 + 1, low, mid, l, r)\n            right = self.query(ind * 2 + 2, mid + 1, high, l, r)\n            return left ^ right\n    s = SegmentTree(a)\n    ans = 0\n    for i in a:\n        ans ^= i\n    res = []\n    for (i, j) in query:\n        temp = s.query(0, 0, N - 1, i - 1, j - 1)\n        res.append(ans ^ temp)\n    return res"
    }
  ]
}