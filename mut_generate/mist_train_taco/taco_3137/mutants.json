{
  "task_id": "taco_3137",
  "entry_point": "find_shortest_path",
  "mutant_count": 128,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[i_start][j_start] = 0",
      "mutated_line": "dist[i_start][j_start] = 1",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 1\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[i_start][j_start] = 0",
      "mutated_line": "dist[i_start][j_start] = -1",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = -1\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist[i_start][j_start] = 0",
      "mutated_line": "dist[i_start][j_start] = 1",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 1\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) >= 0:",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) >= 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) <= 0:",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) <= 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) != 0:",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) != 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return \"Impossible\"",
      "mutated_line": "return ''",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) > 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 1:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) > -1:",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > -1:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "while len(q) > 0:",
      "mutated_line": "while len(q) > 1:",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 1:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if i == i_end and j == j_end:",
      "mutated_line": "if i == i_end or j == j_end:",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end or j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(+2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(+2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, +1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, +1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, ''), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, ''), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (+2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (+2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 2, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 2, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 0, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 0, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 0, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 0, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, -1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, -1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, ''), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, ''), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (1, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (1, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (-1, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (-1, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (1, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (1, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 3, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 3, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 1, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 1, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 0, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 0, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 1, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 1, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, -2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, -2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, ''), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, ''), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (3, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (3, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (1, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (1, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (0, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (0, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (1, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (1, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (-2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (-2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 2, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 2, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 0, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 0, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 0, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 0, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, -1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, -1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, ''), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, ''), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (3, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (3, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (1, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (1, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (0, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (0, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (1, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (1, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (-2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (-2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, +1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, +1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, ''), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, ''), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (1, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (1, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (-1, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (-1, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (1, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (1, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, +2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, +2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, '')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, '')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dist = [[-1 for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dist = [[+1 for _ in range(n)] for _ in range(n)]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[+1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if i == i_end and j == j_end:",
      "mutated_line": "if i != i_end and j == j_end:",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i != i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if i == i_end and j == j_end:",
      "mutated_line": "if i == i_end and j != j_end:",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j != j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n or 0 <= j + dy < n or dist[i + dx][j + dy] == -1:",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n or 0 <= j + dy < n or dist[i + dx][j + dy] == -1:\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-3, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-3, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-1, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-1, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-0, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-0, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-1, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-1, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(--2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(--2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -2, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -2, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -0, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -0, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -0, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -0, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, --1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, --1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-3, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-3, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-1, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-1, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-0, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-0, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-1, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-1, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (--2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (--2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -2, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -2, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -0, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -0, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -0, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -0, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, --1, 'LL'), (0, -2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, --1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -3, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -3, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -1, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -1, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -0, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -0, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -1, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -1, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]",
      "mutated_line": "surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, --2, 'L')]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, --2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[-1 for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dist = [[-2 for _ in range(n)] for _ in range(n)]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-2 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[-1 for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dist = [[-0 for _ in range(n)] for _ in range(n)]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-0 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[-1 for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dist = [[-0 for _ in range(n)] for _ in range(n)]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-0 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[-1 for _ in range(n)] for _ in range(n)]",
      "mutated_line": "dist = [[--1 for _ in range(n)] for _ in range(n)]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[--1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 < i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 < i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 > i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 > i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 == i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 == i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 < j + dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 < j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 > j + dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 > j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 == j + dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 == j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] != -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] != -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dist[i + dx][j + dy] = dist[i][j] + 1",
      "mutated_line": "dist[i + dx][j + dy] = dist[i][j] - 1",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] - 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dist[i + dx][j + dy] = dist[i][j] + 1",
      "mutated_line": "dist[i + dx][j + dy] = dist[i][j] * 1",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] * 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "path[i + dx][j + dy] = path[i][j] + [name]",
      "mutated_line": "path[i + dx][j + dy] = path[i][j] - [name]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] - [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "path[i + dx][j + dy] = path[i][j] + [name]",
      "mutated_line": "path[i + dx][j + dy] = path[i][j] * [name]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] * [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 1 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 1 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if -1 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if -1 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 1 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 1 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i - dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i - dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i * dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i * dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 1 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 1 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and -1 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and -1 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 1 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 1 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 <= j - dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j - dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 <= j * dy < n and (dist[i + dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j * dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == +1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == +1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dist[i + dx][j + dy] = dist[i][j] + 1",
      "mutated_line": "dist[i + dx][j - dy] = dist[i][j] + 1",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j - dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dist[i + dx][j + dy] = dist[i][j] + 1",
      "mutated_line": "dist[i + dx][j * dy] = dist[i][j] + 1",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j * dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist[i + dx][j + dy] = dist[i][j] + 1",
      "mutated_line": "dist[i + dx][j + dy] = dist[i][j] + 2",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 2\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist[i + dx][j + dy] = dist[i][j] + 1",
      "mutated_line": "dist[i + dx][j + dy] = dist[i][j] + 0",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 0\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist[i + dx][j + dy] = dist[i][j] + 1",
      "mutated_line": "dist[i + dx][j + dy] = dist[i][j] + 0",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 0\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist[i + dx][j + dy] = dist[i][j] + 1",
      "mutated_line": "dist[i + dx][j + dy] = dist[i][j] + -1",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + -1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "path[i + dx][j + dy] = path[i][j] + [name]",
      "mutated_line": "path[i + dx][j - dy] = path[i][j] + [name]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j - dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "path[i + dx][j + dy] = path[i][j] + [name]",
      "mutated_line": "path[i + dx][j * dy] = path[i][j] + [name]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j * dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j - dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j - dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j * dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j * dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -2):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -2):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -0):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -0):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -0):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -0):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == --1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == --1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q.append((i + dx, j + dy))",
      "mutated_line": "q.append((i - dx, j + dy))",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i - dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q.append((i + dx, j + dy))",
      "mutated_line": "q.append((i * dx, j + dy))",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i * dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q.append((i + dx, j + dy))",
      "mutated_line": "q.append((i + dx, j - dy))",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j - dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q.append((i + dx, j + dy))",
      "mutated_line": "q.append((i + dx, j * dy))",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j * dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dist[i + dx][j + dy] = dist[i][j] + 1",
      "mutated_line": "dist[i - dx][j + dy] = dist[i][j] + 1",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i - dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dist[i + dx][j + dy] = dist[i][j] + 1",
      "mutated_line": "dist[i * dx][j + dy] = dist[i][j] + 1",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i * dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "path[i + dx][j + dy] = path[i][j] + [name]",
      "mutated_line": "path[i - dx][j + dy] = path[i][j] + [name]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i - dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "path[i + dx][j + dy] = path[i][j] + [name]",
      "mutated_line": "path[i * dx][j + dy] = path[i][j] + [name]",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i * dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i - dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i - dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i + dx][j + dy] == -1):",
      "mutated_line": "if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i * dx][j + dy] == -1):",
      "code": "from collections import deque\n\ndef find_shortest_path(n, i_start, j_start, i_end, j_end):\n    surround = [(-2, -1, 'UL'), (-2, 1, 'UR'), (0, 2, 'R'), (2, 1, 'LR'), (2, -1, 'LL'), (0, -2, 'L')]\n    dist = [[-1 for _ in range(n)] for _ in range(n)]\n    path = [[[] for _ in range(n)] for _ in range(n)]\n    q = deque([(i_start, j_start)])\n    dist[i_start][j_start] = 0\n    while len(q) > 0:\n        (i, j) = q.popleft()\n        if i == i_end and j == j_end:\n            return (dist[i][j], path[i][j])\n        for (dx, dy, name) in surround:\n            if 0 <= i + dx < n and 0 <= j + dy < n and (dist[i * dx][j + dy] == -1):\n                q.append((i + dx, j + dy))\n                dist[i + dx][j + dy] = dist[i][j] + 1\n                path[i + dx][j + dy] = path[i][j] + [name]\n    return 'Impossible'"
    }
  ]
}