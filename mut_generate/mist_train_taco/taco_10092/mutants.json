{
  "task_id": "taco_10092",
  "entry_point": "min_penalty_to_reach_bottom_right",
  "mutant_count": 149,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M - 1][N - 1] = 1",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 1\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M - 1][N - 1] = -1",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = -1\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M - 1][N - 1] = 1",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 1\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [[float('inf')] * N for _ in range(M)]",
      "mutated_line": "dp = [[float('inf')] / N for _ in range(M)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] / N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [[float('inf')] * N for _ in range(M)]",
      "mutated_line": "dp = [[float('inf')] + N for _ in range(M)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] + N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp = [[float('inf')] * N for _ in range(M)]",
      "mutated_line": "dp = [[float('inf')] ** N for _ in range(M)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] ** N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M - 1][N + 1] = 0",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N + 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M - 1][N * 1] = 0",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N * 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if (cx, cy) not in visited:",
      "mutated_line": "if (cx, cy) in visited:",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return dp[0][0]",
      "mutated_line": "return dp[0][1]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return dp[0][0]",
      "mutated_line": "return dp[0][-1]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return dp[0][0]",
      "mutated_line": "return dp[0][1]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M + 1][N - 1] = 0",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M + 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M * 1][N - 1] = 0",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M * 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M - 1][N - 2] = 0",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 2] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M - 1][N - 0] = 0",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 0] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M - 1][N - 0] = 0",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 0] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M - 1][N - -1] = 0",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - -1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 1], M + 1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M + 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 1], M * 1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M * 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 1], M - 1, N + 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N + 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 1], M - 1, N * 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N * 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(+1, 0), (0, 1), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(+1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 1), (0, 1), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 1), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, -1), (0, 1), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, -1), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 1), (0, 1), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 1), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (1, 1), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (1, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (-1, 1), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (-1, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (1, 1), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (1, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 2), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 2), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 0), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 0), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 0), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 0), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, -1), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, -1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (2, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (2, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (0, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (0, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (0, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (0, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (-1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (-1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (1, 1), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 1), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (1, -1), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, -1), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (1, 1), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 1), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (1, 0), (1, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (1, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (1, 0), (-1, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (-1, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (1, 0), (1, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (1, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, +1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, +1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return dp[0][0]",
      "mutated_line": "return dp[1][0]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return dp[0][0]",
      "mutated_line": "return dp[-1][0]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[-1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return dp[0][0]",
      "mutated_line": "return dp[1][0]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M - 2][N - 1] = 0",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 2][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M - 0][N - 1] = 0",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 0][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M - 0][N - 1] = 0",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 0][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "dp[M - 1][N - 1] = 0",
      "mutated_line": "dp[M - -1][N - 1] = 0",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - -1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N + 1], M - 1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N + 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N * 1], M - 1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N * 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 1], M - 2, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 2, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 1], M - 0, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 0, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 1], M - 0, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 0, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 1], M - -1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - -1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 2])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 2])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 0])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 0])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 0])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 0])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 1], M - 1, N - -1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - -1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-2, 0), (0, 1), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-2, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-0, 0), (0, 1), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-0, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-0, 0), (0, 1), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-0, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(--1, 0), (0, 1), (1, 0), (0, -1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(--1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -2)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -2)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -0)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -0)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -0)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -0)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
      "mutated_line": "directions = [(-1, 0), (0, 1), (1, 0), (0, --1)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, --1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cx, cy = pop[1], pop[2]",
      "mutated_line": "(cx, cy) = (pop[2], pop[2])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[2], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cx, cy = pop[1], pop[2]",
      "mutated_line": "(cx, cy) = (pop[0], pop[2])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[0], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cx, cy = pop[1], pop[2]",
      "mutated_line": "(cx, cy) = (pop[0], pop[2])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[0], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cx, cy = pop[1], pop[2]",
      "mutated_line": "(cx, cy) = (pop[-1], pop[2])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[-1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cx, cy = pop[1], pop[2]",
      "mutated_line": "(cx, cy) = (pop[1], pop[3])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[3])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cx, cy = pop[1], pop[2]",
      "mutated_line": "(cx, cy) = (pop[1], pop[1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[1])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cx, cy = pop[1], pop[2]",
      "mutated_line": "(cx, cy) = (pop[1], pop[0])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[0])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cx, cy = pop[1], pop[2]",
      "mutated_line": "(cx, cy) = (pop[1], pop[1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[1])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cx, cy = pop[1], pop[2]",
      "mutated_line": "(cx, cy) = (pop[1], pop[-2])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[-2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(5):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(5):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(3):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(3):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(0):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(0):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(1):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(1):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(-4):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(-4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "mutated_line": "if 0 <= nx < M or 0 <= ny < N or (nx, ny) not in visited:",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M or 0 <= ny < N or (nx, ny) not in visited:\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[float('inf')] * N for _ in range(M)]",
      "mutated_line": "dp = [[float('')] * N for _ in range(M)]",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M + 1][N - 1], M - 1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M + 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M * 1][N - 1], M - 1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M * 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 2], M - 1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 2], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 0], M - 1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 0], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - 0], M - 1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 0], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 1][N - -1], M - 1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - -1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "nx, ny = cx + directions[k][0], cy + directions[k][1]",
      "mutated_line": "(nx, ny) = (cx - directions[k][0], cy + directions[k][1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx - directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "nx, ny = cx + directions[k][0], cy + directions[k][1]",
      "mutated_line": "(nx, ny) = (cx * directions[k][0], cy + directions[k][1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx * directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "nx, ny = cx + directions[k][0], cy + directions[k][1]",
      "mutated_line": "(nx, ny) = (cx + directions[k][0], cy - directions[k][1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy - directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "nx, ny = cx + directions[k][0], cy + directions[k][1]",
      "mutated_line": "(nx, ny) = (cx + directions[k][0], cy * directions[k][1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy * directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "mutated_line": "if 0 < nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 < nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "mutated_line": "if 0 > nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 > nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "mutated_line": "if 0 == nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 == nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "mutated_line": "if 0 <= nx < M and 0 < ny < N and ((nx, ny) not in visited):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 < ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "mutated_line": "if 0 <= nx < M and 0 > ny < N and ((nx, ny) not in visited):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 > ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "mutated_line": "if 0 <= nx < M and 0 == ny < N and ((nx, ny) not in visited):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 == ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "mutated_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) in visited):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 2) % 4) * 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) * 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = k - (ind + 2) % 4 + 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = k - (ind + 2) % 4 + 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if dp[cx][cy] + cost < dp[nx][ny]:",
      "mutated_line": "if dp[cx][cy] + cost <= dp[nx][ny]:",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost <= dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if dp[cx][cy] + cost < dp[nx][ny]:",
      "mutated_line": "if dp[cx][cy] + cost >= dp[nx][ny]:",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost >= dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if dp[cx][cy] + cost < dp[nx][ny]:",
      "mutated_line": "if dp[cx][cy] + cost != dp[nx][ny]:",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost != dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 2][N - 1], M - 1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 2][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 0][N - 1], M - 1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 0][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - 0][N - 1], M - 1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 0][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "pq.put([dp[M - 1][N - 1], M - 1, N - 1])",
      "mutated_line": "pq.put([dp[M - -1][N - 1], M - 1, N - 1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - -1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "mutated_line": "if 1 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 1 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "mutated_line": "if -1 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if -1 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "mutated_line": "if 1 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 1 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "mutated_line": "if 0 <= nx < M and 1 <= ny < N and ((nx, ny) not in visited):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 1 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "mutated_line": "if 0 <= nx < M and -1 <= ny < N and ((nx, ny) not in visited):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and -1 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):",
      "mutated_line": "if 0 <= nx < M and 1 <= ny < N and ((nx, ny) not in visited):",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 1 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k + (ind + 2) % 4) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k + (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = k * ((ind + 2) % 4) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = k * ((ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 2) % 4) % 5",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 5\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 2) % 4) % 3",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 3\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 2) % 4) % 0",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 0\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 2) % 4) % 1",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 1\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 2) % 4) % -4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % -4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if dp[cx][cy] + cost < dp[nx][ny]:",
      "mutated_line": "if dp[cx][cy] - cost < dp[nx][ny]:",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] - cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if dp[cx][cy] + cost < dp[nx][ny]:",
      "mutated_line": "if dp[cx][cy] * cost < dp[nx][ny]:",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] * cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[nx][ny] = dp[cx][cy] + cost",
      "mutated_line": "dp[nx][ny] = dp[cx][cy] - cost",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] - cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dp[nx][ny] = dp[cx][cy] + cost",
      "mutated_line": "dp[nx][ny] = dp[cx][cy] * cost",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] * cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "nx, ny = cx + directions[k][0], cy + directions[k][1]",
      "mutated_line": "(nx, ny) = (cx + directions[k][1], cy + directions[k][1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][1], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "nx, ny = cx + directions[k][0], cy + directions[k][1]",
      "mutated_line": "(nx, ny) = (cx + directions[k][-1], cy + directions[k][1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][-1], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "nx, ny = cx + directions[k][0], cy + directions[k][1]",
      "mutated_line": "(nx, ny) = (cx + directions[k][1], cy + directions[k][1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][1], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "nx, ny = cx + directions[k][0], cy + directions[k][1]",
      "mutated_line": "(nx, ny) = (cx + directions[k][0], cy + directions[k][2])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][2])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "nx, ny = cx + directions[k][0], cy + directions[k][1]",
      "mutated_line": "(nx, ny) = (cx + directions[k][0], cy + directions[k][0])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][0])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "nx, ny = cx + directions[k][0], cy + directions[k][1]",
      "mutated_line": "(nx, ny) = (cx + directions[k][0], cy + directions[k][0])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][0])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "nx, ny = cx + directions[k][0], cy + directions[k][1]",
      "mutated_line": "(nx, ny) = (cx + directions[k][0], cy + directions[k][-1])",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][-1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 2) * 4) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) * 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 2 + 4)) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2 + 4)) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind - 2) % 4) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind - 2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - ind * 2 % 4) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - ind * 2 % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 2) % 5) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 5) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 2) % 3) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 3) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 2) % 0) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 0) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 2) % 1) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % 1) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 2) % -4) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 2) % -4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 3) % 4) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 3) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 1) % 4) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 1) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 0) % 4) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 0) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + 1) % 4) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + 1) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cost = (k - (ind + 2) % 4) % 4",
      "mutated_line": "cost = (k - (ind + -2) % 4) % 4",
      "code": "import queue as Q\n\ndef min_penalty_to_reach_bottom_right(M, N, grid):\n    dp = [[float('inf')] * N for _ in range(M)]\n    dp[M - 1][N - 1] = 0\n    pq = Q.PriorityQueue()\n    pq.put([dp[M - 1][N - 1], M - 1, N - 1])\n    visited = set()\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    while not pq.empty():\n        pop = pq.get()\n        (cx, cy) = (pop[1], pop[2])\n        if (cx, cy) not in visited:\n            visited.add((cx, cy))\n            for k in range(4):\n                (nx, ny) = (cx + directions[k][0], cy + directions[k][1])\n                if 0 <= nx < M and 0 <= ny < N and ((nx, ny) not in visited):\n                    clr = grid[cx][cy][k]\n                    ind = grid[nx][ny].index(clr)\n                    cost = (k - (ind + -2) % 4) % 4\n                    if dp[cx][cy] + cost < dp[nx][ny]:\n                        dp[nx][ny] = dp[cx][cy] + cost\n                        pq.put([dp[nx][ny], nx, ny])\n    return dp[0][0]"
    }
  ]
}