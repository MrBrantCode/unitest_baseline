{
  "task_id": "taco_10030",
  "entry_point": "find_optimal_tram_schedule",
  "mutant_count": 125,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "M2 = m // 2",
      "mutated_line": "M2 = m / 2",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m / 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "M2 = m // 2",
      "mutated_line": "M2 = m * 2",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m * 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "tt = [0] * ln",
      "mutated_line": "tt = [0] / ln",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] / ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "tt = [0] * ln",
      "mutated_line": "tt = [0] + ln",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] + ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "tt = [0] * ln",
      "mutated_line": "tt = [0] ** ln",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] ** ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "tt[enc[l]] += 1",
      "mutated_line": "tt[enc[l]] -= 1",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] -= 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "tt[enc[r]] -= 1",
      "mutated_line": "tt[enc[r]] += 1",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] += 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "tt[i + 1] += tt[i]",
      "mutated_line": "tt[i + 1] -= tt[i]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] -= tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "tt[i] += tt[i + ln // 2]",
      "mutated_line": "tt[i] -= tt[i + ln // 2]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] -= tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "M2 = m // 2",
      "mutated_line": "M2 = m // 3",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 3\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "M2 = m // 2",
      "mutated_line": "M2 = m // 1",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 1\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "M2 = m // 2",
      "mutated_line": "M2 = m // 0",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 0\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "M2 = m // 2",
      "mutated_line": "M2 = m // 1",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 1\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "M2 = m // 2",
      "mutated_line": "M2 = m // -2",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // -2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "s = (m_i + 1) % M2",
      "mutated_line": "s = (m_i + 1) * M2",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) * M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "s = (m_i + 1) % M2",
      "mutated_line": "s = m_i + 1 + M2",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = m_i + 1 + M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tt[enc[l]] += 1",
      "mutated_line": "tt[enc[l]] += 2",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 2\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tt[enc[l]] += 1",
      "mutated_line": "tt[enc[l]] += 0",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 0\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tt[enc[l]] += 1",
      "mutated_line": "tt[enc[l]] += 0",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 0\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tt[enc[l]] += 1",
      "mutated_line": "tt[enc[l]] += -1",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += -1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "tt[enc[r]] -= 1",
      "mutated_line": "tt[enc[r]] -= 2",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 2\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "tt[enc[r]] -= 1",
      "mutated_line": "tt[enc[r]] -= 0",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 0\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "tt[enc[r]] -= 1",
      "mutated_line": "tt[enc[r]] -= 0",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 0\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "tt[enc[r]] -= 1",
      "mutated_line": "tt[enc[r]] -= -1",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= -1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(ln - 1):",
      "mutated_line": "for i in range(ln + 1):",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln + 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(ln - 1):",
      "mutated_line": "for i in range(ln * 1):",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln * 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for i in range(ln // 2):",
      "mutated_line": "for i in range(ln / 2):",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln / 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for i in range(ln // 2):",
      "mutated_line": "for i in range(ln * 2):",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln * 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if l <= t < r or l <= t + M2 < r:",
      "mutated_line": "if l <= t < r and l <= t + M2 < r:",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r and l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = set([0, M2])",
      "mutated_line": "st = set([1, M2])",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([1, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = set([0, M2])",
      "mutated_line": "st = set([-1, M2])",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([-1, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "st = set([0, M2])",
      "mutated_line": "st = set([1, M2])",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([1, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "s = (m_i + 1) % M2",
      "mutated_line": "s = (m_i - 1) % M2",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i - 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "s = (m_i + 1) % M2",
      "mutated_line": "s = m_i * 1 % M2",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = m_i * 1 % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "rr.append(s + k - 1)",
      "mutated_line": "rr.append(s + k + 1)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k + 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "rr.append(s + k - 1)",
      "mutated_line": "rr.append((s + k) * 1)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append((s + k) * 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "st.add(s + M2)",
      "mutated_line": "st.add(s - M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s - M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "st.add(s + M2)",
      "mutated_line": "st.add(s * M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s * M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "st.add((s + k - 1) % M2)",
      "mutated_line": "st.add((s + k - 1) * M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) * M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "st.add((s + k - 1) % M2)",
      "mutated_line": "st.add(s + k - 1 + M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add(s + k - 1 + M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st.add((s + k - 1) % M2 + M2)",
      "mutated_line": "st.add((s + k - 1) % M2 - M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 - M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st.add((s + k - 1) % M2 + M2)",
      "mutated_line": "st.add((s + k - 1) % M2 * M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 * M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tt = [0] * ln",
      "mutated_line": "tt = [1] * ln",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [1] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tt = [0] * ln",
      "mutated_line": "tt = [-1] * ln",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [-1] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "tt = [0] * ln",
      "mutated_line": "tt = [1] * ln",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [1] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(ln - 1):",
      "mutated_line": "for i in range(ln - 2):",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 2):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(ln - 1):",
      "mutated_line": "for i in range(ln - 0):",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 0):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(ln - 1):",
      "mutated_line": "for i in range(ln - 0):",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 0):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(ln - 1):",
      "mutated_line": "for i in range(ln - -1):",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - -1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "tt[i + 1] += tt[i]",
      "mutated_line": "tt[i - 1] += tt[i]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i - 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "tt[i + 1] += tt[i]",
      "mutated_line": "tt[i * 1] += tt[i]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i * 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(ln // 2):",
      "mutated_line": "for i in range(ln // 3):",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 3):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(ln // 2):",
      "mutated_line": "for i in range(ln // 1):",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 1):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(ln // 2):",
      "mutated_line": "for i in range(ln // 0):",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 0):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(ln // 2):",
      "mutated_line": "for i in range(ln // 1):",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 1):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(ln // 2):",
      "mutated_line": "for i in range(ln // -2):",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // -2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tt[i] += tt[i + ln // 2]",
      "mutated_line": "tt[i] += tt[i - ln // 2]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i - ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tt[i] += tt[i + ln // 2]",
      "mutated_line": "tt[i] += tt[i * (ln // 2)]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i * (ln // 2)]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if l <= t < r or l <= t + M2 < r:",
      "mutated_line": "if l < t < r or l <= t + M2 < r:",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l < t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if l <= t < r or l <= t + M2 < r:",
      "mutated_line": "if l > t < r or l <= t + M2 < r:",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l > t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if l <= t < r or l <= t + M2 < r:",
      "mutated_line": "if l == t < r or l <= t + M2 < r:",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l == t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if l <= t < r or l <= t + M2 < r:",
      "mutated_line": "if l <= t < r or l < t + M2 < r:",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l < t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if l <= t < r or l <= t + M2 < r:",
      "mutated_line": "if l <= t < r or l > t + M2 < r:",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l > t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if l <= t < r or l <= t + M2 < r:",
      "mutated_line": "if l <= t < r or l == t + M2 < r:",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l == t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = (m_i + 1) % M2",
      "mutated_line": "s = (m_i + 2) % M2",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 2) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = (m_i + 1) % M2",
      "mutated_line": "s = (m_i + 0) % M2",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 0) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = (m_i + 1) % M2",
      "mutated_line": "s = (m_i + 0) % M2",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 0) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = (m_i + 1) % M2",
      "mutated_line": "s = (m_i + -1) % M2",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + -1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "rr.append(s + k - 1)",
      "mutated_line": "rr.append(s - k - 1)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s - k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "rr.append(s + k - 1)",
      "mutated_line": "rr.append(s * k - 1)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s * k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rr.append(s + k - 1)",
      "mutated_line": "rr.append(s + k - 2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 2)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rr.append(s + k - 1)",
      "mutated_line": "rr.append(s + k - 0)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 0)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rr.append(s + k - 1)",
      "mutated_line": "rr.append(s + k - 0)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 0)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rr.append(s + k - 1)",
      "mutated_line": "rr.append(s + k - -1)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - -1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "st.add((s + k - 1) % M2)",
      "mutated_line": "st.add((s + k + 1) % M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k + 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "st.add((s + k - 1) % M2)",
      "mutated_line": "st.add((s + k) * 1 % M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k) * 1 % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st.add((s + k - 1) % M2 + M2)",
      "mutated_line": "st.add((s + k - 1) * M2 + M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) * M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st.add((s + k - 1) % M2 + M2)",
      "mutated_line": "st.add(s + k - 1 + M2 + M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add(s + k - 1 + M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tt[i + 1] += tt[i]",
      "mutated_line": "tt[i + 2] += tt[i]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 2] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tt[i + 1] += tt[i]",
      "mutated_line": "tt[i + 0] += tt[i]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 0] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tt[i + 1] += tt[i]",
      "mutated_line": "tt[i + 0] += tt[i]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 0] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tt[i + 1] += tt[i]",
      "mutated_line": "tt[i + -1] += tt[i]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + -1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tt[i] += tt[i + ln // 2]",
      "mutated_line": "tt[i] += tt[i + ln / 2]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln / 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tt[i] += tt[i + ln // 2]",
      "mutated_line": "tt[i] += tt[i + ln * 2]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln * 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "mn = min(tt[:ln // 2])",
      "mutated_line": "mn = min(tt[:ln / 2])",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln / 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "mn = min(tt[:ln // 2])",
      "mutated_line": "mn = min(tt[:ln * 2])",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln * 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if l <= t < r or l <= t + M2 < r:",
      "mutated_line": "if l <= t < r or l <= t - M2 < r:",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t - M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if l <= t < r or l <= t + M2 < r:",
      "mutated_line": "if l <= t < r or l <= t * M2 < r:",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t * M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans.append(i + 1)",
      "mutated_line": "ans.append(i - 1)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i - 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans.append(i + 1)",
      "mutated_line": "ans.append(i * 1)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i * 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "st.add((s + k - 1) % M2)",
      "mutated_line": "st.add((s - k - 1) % M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s - k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "st.add((s + k - 1) % M2)",
      "mutated_line": "st.add((s * k - 1) % M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s * k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "st.add((s + k - 1) % M2)",
      "mutated_line": "st.add((s + k - 2) % M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 2) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "st.add((s + k - 1) % M2)",
      "mutated_line": "st.add((s + k - 0) % M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 0) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "st.add((s + k - 1) % M2)",
      "mutated_line": "st.add((s + k - 0) % M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 0) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "st.add((s + k - 1) % M2)",
      "mutated_line": "st.add((s + k - -1) % M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - -1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st.add((s + k - 1) % M2 + M2)",
      "mutated_line": "st.add((s + k + 1) % M2 + M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k + 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st.add((s + k - 1) % M2 + M2)",
      "mutated_line": "st.add((s + k) * 1 % M2 + M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k) * 1 % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tt[i] += tt[i + ln // 2]",
      "mutated_line": "tt[i] += tt[i + ln // 3]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 3]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tt[i] += tt[i + ln // 2]",
      "mutated_line": "tt[i] += tt[i + ln // 1]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 1]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tt[i] += tt[i + ln // 2]",
      "mutated_line": "tt[i] += tt[i + ln // 0]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 0]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tt[i] += tt[i + ln // 2]",
      "mutated_line": "tt[i] += tt[i + ln // 1]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 1]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tt[i] += tt[i + ln // 2]",
      "mutated_line": "tt[i] += tt[i + ln // -2]",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // -2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mn = min(tt[:ln // 2])",
      "mutated_line": "mn = min(tt[:ln // 3])",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 3])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mn = min(tt[:ln // 2])",
      "mutated_line": "mn = min(tt[:ln // 1])",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 1])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mn = min(tt[:ln // 2])",
      "mutated_line": "mn = min(tt[:ln // 0])",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 0])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mn = min(tt[:ln // 2])",
      "mutated_line": "mn = min(tt[:ln // 1])",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 1])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mn = min(tt[:ln // 2])",
      "mutated_line": "mn = min(tt[:ln // -2])",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // -2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "i = tt[:ln // 2].index(mn)",
      "mutated_line": "i = tt[:ln / 2].index(mn)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln / 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "i = tt[:ln // 2].index(mn)",
      "mutated_line": "i = tt[:ln * 2].index(mn)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln * 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans.append(i + 1)",
      "mutated_line": "ans.append(i + 2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 2)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans.append(i + 1)",
      "mutated_line": "ans.append(i + 0)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 0)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans.append(i + 1)",
      "mutated_line": "ans.append(i + 0)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 0)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans.append(i + 1)",
      "mutated_line": "ans.append(i + -1)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + -1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st.add((s + k - 1) % M2 + M2)",
      "mutated_line": "st.add((s - k - 1) % M2 + M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s - k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "st.add((s + k - 1) % M2 + M2)",
      "mutated_line": "st.add((s * k - 1) % M2 + M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s * k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st.add((s + k - 1) % M2 + M2)",
      "mutated_line": "st.add((s + k - 2) % M2 + M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 2) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st.add((s + k - 1) % M2 + M2)",
      "mutated_line": "st.add((s + k - 0) % M2 + M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 0) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st.add((s + k - 1) % M2 + M2)",
      "mutated_line": "st.add((s + k - 0) % M2 + M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 0) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "st.add((s + k - 1) % M2 + M2)",
      "mutated_line": "st.add((s + k - -1) % M2 + M2)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - -1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "i = tt[:ln // 2].index(mn)",
      "mutated_line": "i = tt[:ln // 3].index(mn)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 3].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "i = tt[:ln // 2].index(mn)",
      "mutated_line": "i = tt[:ln // 1].index(mn)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 1].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "i = tt[:ln // 2].index(mn)",
      "mutated_line": "i = tt[:ln // 0].index(mn)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 0].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "i = tt[:ln // 2].index(mn)",
      "mutated_line": "i = tt[:ln // 1].index(mn)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // 1].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "i = tt[:ln // 2].index(mn)",
      "mutated_line": "i = tt[:ln // -2].index(mn)",
      "code": "def find_optimal_tram_schedule(n, h, m, k, departures):\n    M2 = m // 2\n    ll = []\n    rr = []\n    st = set([0, M2])\n    for (h_i, m_i) in departures:\n        s = (m_i + 1) % M2\n        ll.append(s)\n        rr.append(s + k - 1)\n        st.add(s)\n        st.add(s + M2)\n        st.add((s + k - 1) % M2)\n        st.add((s + k - 1) % M2 + M2)\n    dec = list(sorted(st))\n    enc = {a: i for (i, a) in enumerate(dec)}\n    ln = len(dec)\n    tt = [0] * ln\n    for (l, r) in zip(ll, rr):\n        tt[enc[l]] += 1\n        tt[enc[r]] -= 1\n    for i in range(ln - 1):\n        tt[i + 1] += tt[i]\n    for i in range(ln // 2):\n        tt[i] += tt[i + ln // 2]\n    mn = min(tt[:ln // 2])\n    i = tt[:ln // -2].index(mn)\n    t = dec[i]\n    ans = []\n    for (i, (l, r)) in enumerate(zip(ll, rr)):\n        if l <= t < r or l <= t + M2 < r:\n            ans.append(i + 1)\n    return (mn, t, ans)"
    }
  ]
}