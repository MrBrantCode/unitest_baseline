{
  "task_id": "taco_6684",
  "entry_point": "find_minimum_k",
  "mutant_count": 111,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(0, 0)] / (n + 1)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] / (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(0, 0)] + (n + 1)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] + (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(0, 0)] ** (n + 1)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] ** (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([1]), [0] / (n + 1), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] / (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([1]), [0] + (n + 1), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] + (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([1]), [0] ** (n + 1), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] ** (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(0, 0)] * (n - 1)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n - 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(0, 0)] * (n * 1)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n * 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if u == 1:",
      "mutated_line": "if u != 1:",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u != 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([1]), [0] * (n - 1), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n - 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([1]), [0] * (n * 1), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n * 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if par[u] == v:",
      "mutated_line": "if par[u] != v:",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] != v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(0, 0)] * (n + 2)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 2)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(0, 0)] * (n + 0)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 0)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(0, 0)] * (n + 0)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 0)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(0, 0)] * (n + -1)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + -1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if par[u] == v:",
      "mutated_line": "if par[u] != v:",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] != v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if u == 1:",
      "mutated_line": "if u == 2:",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 2:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if u == 1:",
      "mutated_line": "if u == 0:",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 0:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if u == 1:",
      "mutated_line": "if u == 0:",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 0:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if u == 1:",
      "mutated_line": "if u == -1:",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == -1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = el[0][1]",
      "mutated_line": "mx = el[0][2]",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][2]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = el[0][1]",
      "mutated_line": "mx = el[0][0]",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][0]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = el[0][1]",
      "mutated_line": "mx = el[0][0]",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][0]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = el[0][1]",
      "mutated_line": "mx = el[0][-1]",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][-1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[1][1], ln[1][1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][1], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[1][-1], ln[1][1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][-1], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[1][1], ln[1][1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][1], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[1][0], ln[1][2])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][2])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[1][0], ln[1][0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[1][0], ln[1][0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][0])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[1][0], ln[1][-1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][-1])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "e = [[] for _ in range(n - 1)]",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n - 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "e = [[] for _ in range(n * 1)]",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n * 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([2]), [0] * (n + 1), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([2]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([0]), [0] * (n + 1), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([0]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([0]), [0] * (n + 1), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([0]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([-1]), [0] * (n + 1), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([-1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([1]), [1] * (n + 1), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [1] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([1]), [-1] * (n + 1), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [-1] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([1]), [1] * (n + 1), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [1] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([1]), [0] * (n + 2), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 2), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([1]), [0] * (n + 0), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 0), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([1]), [0] * (n + 0), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 0), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "q, par, order = deque([1]), [0] * (n + 1), []",
      "mutated_line": "(q, par, order) = (deque([1]), [0] * (n + -1), [])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + -1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(1, 0)] * (n + 1)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(1, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(-1, 0)] * (n + 1)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(-1, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(1, 0)] * (n + 1)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(1, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(0, 1)] * (n + 1)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 1)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(0, -1)] * (n + 1)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, -1)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ln = [(0, 0)] * (n + 1)",
      "mutated_line": "ln = [(0, 1)] * (n + 1)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 1)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = el[0][1]",
      "mutated_line": "mx = el[1][1]",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[1][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = el[0][1]",
      "mutated_line": "mx = el[-1][1]",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[-1][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = el[0][1]",
      "mutated_line": "mx = el[1][1]",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[1][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (a, b) in el[1:]:",
      "mutated_line": "for (a, b) in el[2:]:",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[2:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (a, b) in el[1:]:",
      "mutated_line": "for (a, b) in el[0:]:",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[0:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (a, b) in el[1:]:",
      "mutated_line": "for (a, b) in el[0:]:",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[0:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for (a, b) in el[1:]:",
      "mutated_line": "for (a, b) in el[-1:]:",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[-1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ln[u] = (el[0][0], mx)",
      "mutated_line": "ln[u] = (el[0][1], mx)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][1], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ln[u] = (el[0][0], mx)",
      "mutated_line": "ln[u] = (el[0][-1], mx)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][-1], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ln[u] = (el[0][0], mx)",
      "mutated_line": "ln[u] = (el[0][1], mx)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][1], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[2][0], ln[1][1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[2][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[0][0], ln[1][1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[0][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[0][0], ln[1][1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[0][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[-1][0], ln[1][1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[-1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[1][0], ln[2][1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[2][1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[1][0], ln[0][1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[0][1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[1][0], ln[0][1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[0][1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(ln[1][0], ln[1][1])",
      "mutated_line": "return max(ln[1][0], ln[-1][1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[-1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "e = [[] for _ in range(n + 2)]",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 2)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "e = [[] for _ in range(n + 0)]",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 0)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "e = [[] for _ in range(n + 0)]",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 0)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "e = [[] for _ in range(n + -1)]",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + -1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "el.append((ln[v][0] + 1, ln[v][1]))",
      "mutated_line": "el.append((ln[v][0] - 1, ln[v][1]))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] - 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "el.append((ln[v][0] + 1, ln[v][1]))",
      "mutated_line": "el.append((ln[v][0] * 1, ln[v][1]))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] * 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[1], el[-1]) = (el[-1], el[0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[1], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[-1], el[-1]) = (el[-1], el[0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[-1], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[1], el[-1]) = (el[-1], el[0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[1], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[0], el[+1]) = (el[-1], el[0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[+1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[0], el[-1]) = (el[+1], el[0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[+1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[0], el[-1]) = (el[-1], el[1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[1])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[0], el[-1]) = (el[-1], el[-1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[-1])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[0], el[-1]) = (el[-1], el[1])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[1])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "mx = max(mx, max(a + 1, b))",
      "mutated_line": "mx = max(mx, max(a - 1, b))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a - 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "mx = max(mx, max(a + 1, b))",
      "mutated_line": "mx = max(mx, max(a * 1, b))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a * 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ln[u] = (el[0][0], mx)",
      "mutated_line": "ln[u] = (el[1][0], mx)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[1][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ln[u] = (el[0][0], mx)",
      "mutated_line": "ln[u] = (el[-1][0], mx)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[-1][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ln[u] = (el[0][0], mx)",
      "mutated_line": "ln[u] = (el[1][0], mx)",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[1][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "el.append((ln[v][0] + 1, ln[v][1]))",
      "mutated_line": "el.append((ln[v][0] + 2, ln[v][1]))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 2, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "el.append((ln[v][0] + 1, ln[v][1]))",
      "mutated_line": "el.append((ln[v][0] + 0, ln[v][1]))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 0, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "el.append((ln[v][0] + 1, ln[v][1]))",
      "mutated_line": "el.append((ln[v][0] + 0, ln[v][1]))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 0, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "el.append((ln[v][0] + 1, ln[v][1]))",
      "mutated_line": "el.append((ln[v][0] + -1, ln[v][1]))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + -1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "el.append((ln[v][0] + 1, ln[v][1]))",
      "mutated_line": "el.append((ln[v][0] + 1, ln[v][2]))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][2]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "el.append((ln[v][0] + 1, ln[v][1]))",
      "mutated_line": "el.append((ln[v][0] + 1, ln[v][0]))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][0]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "el.append((ln[v][0] + 1, ln[v][1]))",
      "mutated_line": "el.append((ln[v][0] + 1, ln[v][0]))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][0]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "el.append((ln[v][0] + 1, ln[v][1]))",
      "mutated_line": "el.append((ln[v][0] + 1, ln[v][-1]))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][-1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[0], el[-2]) = (el[-1], el[0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-2]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[0], el[-0]) = (el[-1], el[0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-0]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[0], el[-0]) = (el[-1], el[0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-0]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[0], el[--1]) = (el[-1], el[0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[--1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[0], el[-1]) = (el[-2], el[0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-2], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[0], el[-1]) = (el[-0], el[0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-0], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[0], el[-1]) = (el[-0], el[0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-0], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(el[0], el[-1]) = (el[-1], el[0])",
      "mutated_line": "(el[0], el[-1]) = (el[--1], el[0])",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[--1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "mx = max(mx, max(a + 1, b))",
      "mutated_line": "mx = max(mx, max(a + 2, b))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 2, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "mx = max(mx, max(a + 1, b))",
      "mutated_line": "mx = max(mx, max(a + 0, b))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 0, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "mx = max(mx, max(a + 1, b))",
      "mutated_line": "mx = max(mx, max(a + 0, b))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 0, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "mx = max(mx, max(a + 1, b))",
      "mutated_line": "mx = max(mx, max(a + -1, b))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][0] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + -1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "el.append((ln[v][0] + 1, ln[v][1]))",
      "mutated_line": "el.append((ln[v][1] + 1, ln[v][1]))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][1] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "el.append((ln[v][0] + 1, ln[v][1]))",
      "mutated_line": "el.append((ln[v][-1] + 1, ln[v][1]))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][-1] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "el.append((ln[v][0] + 1, ln[v][1]))",
      "mutated_line": "el.append((ln[v][1] + 1, ln[v][1]))",
      "code": "from collections import deque\n\ndef find_minimum_k(n, roads):\n    e = [[] for _ in range(n + 1)]\n    for (a, b) in roads:\n        e[a].append(b)\n        e[b].append(a)\n    (q, par, order) = (deque([1]), [0] * (n + 1), [])\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            q.append(v)\n            par[v] = u\n    ln = [(0, 0)] * (n + 1)\n    for u in reversed(order):\n        el = []\n        for v in e[u]:\n            if par[u] == v:\n                continue\n            el.append((ln[v][1] + 1, ln[v][1]))\n        if not el:\n            continue\n        el.sort()\n        if u == 1:\n            (el[0], el[-1]) = (el[-1], el[0])\n        mx = el[0][1]\n        for (a, b) in el[1:]:\n            mx = max(mx, max(a + 1, b))\n        ln[u] = (el[0][0], mx)\n    return max(ln[1][0], ln[1][1])"
    }
  ]
}