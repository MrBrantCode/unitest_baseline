{
  "task_id": "taco_11636",
  "entry_point": "count_connected_cities",
  "mutant_count": 109,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = 0",
      "mutated_line": "color = 1",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 1\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = 0",
      "mutated_line": "color = -1",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = -1\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "color = 0",
      "mutated_line": "color = 1",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 1\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "color2 = 0",
      "mutated_line": "color2 = 1",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 1\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "color2 = 0",
      "mutated_line": "color2 = -1",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = -1\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "color2 = 0",
      "mutated_line": "color2 = 1",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 1\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "M = 1 + max(color_list)",
      "mutated_line": "M = 1 - max(color_list)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 - max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "M = 1 + max(color_list)",
      "mutated_line": "M = 1 * max(color_list)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 * max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while len(Q) > 0:",
      "mutated_line": "while len(Q) >= 0:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) >= 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while len(Q) > 0:",
      "mutated_line": "while len(Q) <= 0:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) <= 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while len(Q) > 0:",
      "mutated_line": "while len(Q) != 0:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) != 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "color_list = [-1 for _ in range(N)]",
      "mutated_line": "color_list = [+1 for _ in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [+1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if color_list[i] == -1:",
      "mutated_line": "if color_list[i] != -1:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] != -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "color += 1",
      "mutated_line": "color -= 1",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color -= 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "color_list2 = [-1 for _ in range(N)]",
      "mutated_line": "color_list2 = [+1 for _ in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [+1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if color_list2[i] == -1:",
      "mutated_line": "if color_list2[i] != -1:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] != -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "color2 += 1",
      "mutated_line": "color2 -= 1",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 -= 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "M = 1 + max(color_list)",
      "mutated_line": "M = 2 + max(color_list)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 2 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "M = 1 + max(color_list)",
      "mutated_line": "M = 0 + max(color_list)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 0 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "M = 1 + max(color_list)",
      "mutated_line": "M = 0 + max(color_list)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 0 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "M = 1 + max(color_list)",
      "mutated_line": "M = -1 + max(color_list)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = -1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "color_list = [color_list[i] + M * color_list2[i] for i in range(N)]",
      "mutated_line": "color_list = [color_list[i] - M * color_list2[i] for i in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] - M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "color_list = [color_list[i] + M * color_list2[i] for i in range(N)]",
      "mutated_line": "color_list = [color_list[i] * (M * color_list2[i]) for i in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] * (M * color_list2[i]) for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(Q) > 0:",
      "mutated_line": "while len(Q) > 1:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 1:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(Q) > 0:",
      "mutated_line": "while len(Q) > -1:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > -1:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(Q) > 0:",
      "mutated_line": "while len(Q) > 1:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 1:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "e_list1[p - 1].append(q - 1)",
      "mutated_line": "e_list1[p - 1].append(q + 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q + 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "e_list1[p - 1].append(q - 1)",
      "mutated_line": "e_list1[p - 1].append(q * 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q * 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "e_list1[q - 1].append(p - 1)",
      "mutated_line": "e_list1[q - 1].append(p + 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p + 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "e_list1[q - 1].append(p - 1)",
      "mutated_line": "e_list1[q - 1].append(p * 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p * 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "e_list2[p - 1].append(q - 1)",
      "mutated_line": "e_list2[p - 1].append(q + 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q + 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "e_list2[p - 1].append(q - 1)",
      "mutated_line": "e_list2[p - 1].append(q * 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q * 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "e_list2[q - 1].append(p - 1)",
      "mutated_line": "e_list2[q - 1].append(p + 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p + 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "e_list2[q - 1].append(p - 1)",
      "mutated_line": "e_list2[q - 1].append(p * 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p * 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "color_list = [-1 for _ in range(N)]",
      "mutated_line": "color_list = [-2 for _ in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-2 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "color_list = [-1 for _ in range(N)]",
      "mutated_line": "color_list = [-0 for _ in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-0 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "color_list = [-1 for _ in range(N)]",
      "mutated_line": "color_list = [-0 for _ in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-0 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "color_list = [-1 for _ in range(N)]",
      "mutated_line": "color_list = [--1 for _ in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [--1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "if color_list[i] == -1:",
      "mutated_line": "if color_list[i] == +1:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == +1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "color += 1",
      "mutated_line": "color += 2",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 2\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "color += 1",
      "mutated_line": "color += 0",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 0\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "color += 1",
      "mutated_line": "color += 0",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 0\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "color += 1",
      "mutated_line": "color += -1",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += -1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "color_list2 = [-1 for _ in range(N)]",
      "mutated_line": "color_list2 = [-2 for _ in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-2 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "color_list2 = [-1 for _ in range(N)]",
      "mutated_line": "color_list2 = [-0 for _ in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-0 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "color_list2 = [-1 for _ in range(N)]",
      "mutated_line": "color_list2 = [-0 for _ in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-0 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "color_list2 = [-1 for _ in range(N)]",
      "mutated_line": "color_list2 = [--1 for _ in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [--1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "if color_list2[i] == -1:",
      "mutated_line": "if color_list2[i] == +1:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == +1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "color2 += 1",
      "mutated_line": "color2 += 2",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 2\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "color2 += 1",
      "mutated_line": "color2 += 0",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 0\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "color2 += 1",
      "mutated_line": "color2 += 0",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 0\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "color2 += 1",
      "mutated_line": "color2 += -1",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += -1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "color_list = [color_list[i] + M * color_list2[i] for i in range(N)]",
      "mutated_line": "color_list = [color_list[i] + M / color_list2[i] for i in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M / color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "color_list = [color_list[i] + M * color_list2[i] for i in range(N)]",
      "mutated_line": "color_list = [color_list[i] + (M + color_list2[i]) for i in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + (M + color_list2[i]) for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "color_list = [color_list[i] + M * color_list2[i] for i in range(N)]",
      "mutated_line": "color_list = [color_list[i] + M ** color_list2[i] for i in range(N)]",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M ** color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if color_list[v1] == -1:",
      "mutated_line": "if color_list[v1] != -1:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] != -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "e_list1[p - 1].append(q - 1)",
      "mutated_line": "e_list1[p - 1].append(q - 2)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 2)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "e_list1[p - 1].append(q - 1)",
      "mutated_line": "e_list1[p - 1].append(q - 0)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 0)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "e_list1[p - 1].append(q - 1)",
      "mutated_line": "e_list1[p - 1].append(q - 0)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 0)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "e_list1[p - 1].append(q - 1)",
      "mutated_line": "e_list1[p - 1].append(q - -1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - -1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "e_list1[q - 1].append(p - 1)",
      "mutated_line": "e_list1[q - 1].append(p - 2)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 2)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "e_list1[q - 1].append(p - 1)",
      "mutated_line": "e_list1[q - 1].append(p - 0)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 0)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "e_list1[q - 1].append(p - 1)",
      "mutated_line": "e_list1[q - 1].append(p - 0)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 0)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "e_list1[q - 1].append(p - 1)",
      "mutated_line": "e_list1[q - 1].append(p - -1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - -1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "e_list2[p - 1].append(q - 1)",
      "mutated_line": "e_list2[p - 1].append(q - 2)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 2)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "e_list2[p - 1].append(q - 1)",
      "mutated_line": "e_list2[p - 1].append(q - 0)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 0)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "e_list2[p - 1].append(q - 1)",
      "mutated_line": "e_list2[p - 1].append(q - 0)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 0)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "e_list2[p - 1].append(q - 1)",
      "mutated_line": "e_list2[p - 1].append(q - -1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - -1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "e_list2[q - 1].append(p - 1)",
      "mutated_line": "e_list2[q - 1].append(p - 2)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 2)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "e_list2[q - 1].append(p - 1)",
      "mutated_line": "e_list2[q - 1].append(p - 0)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 0)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "e_list2[q - 1].append(p - 1)",
      "mutated_line": "e_list2[q - 1].append(p - 0)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 0)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "e_list2[q - 1].append(p - 1)",
      "mutated_line": "e_list2[q - 1].append(p - -1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - -1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if color_list[i] == -1:",
      "mutated_line": "if color_list[i] == -2:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -2:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if color_list[i] == -1:",
      "mutated_line": "if color_list[i] == -0:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -0:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if color_list[i] == -1:",
      "mutated_line": "if color_list[i] == -0:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -0:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if color_list[i] == -1:",
      "mutated_line": "if color_list[i] == --1:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == --1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if color_list2[i] == -1:",
      "mutated_line": "if color_list2[i] == -2:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -2:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if color_list2[i] == -1:",
      "mutated_line": "if color_list2[i] == -0:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -0:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if color_list2[i] == -1:",
      "mutated_line": "if color_list2[i] == -0:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -0:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if color_list2[i] == -1:",
      "mutated_line": "if color_list2[i] == --1:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == --1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "if color_list[v1] == -1:",
      "mutated_line": "if color_list[v1] == +1:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == +1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "e_list1[p - 1].append(q - 1)",
      "mutated_line": "e_list1[p + 1].append(q - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p + 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "e_list1[p - 1].append(q - 1)",
      "mutated_line": "e_list1[p * 1].append(q - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p * 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "e_list1[q - 1].append(p - 1)",
      "mutated_line": "e_list1[q + 1].append(p - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q + 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "e_list1[q - 1].append(p - 1)",
      "mutated_line": "e_list1[q * 1].append(p - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q * 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "e_list2[p - 1].append(q - 1)",
      "mutated_line": "e_list2[p + 1].append(q - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p + 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "e_list2[p - 1].append(q - 1)",
      "mutated_line": "e_list2[p * 1].append(q - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p * 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "e_list2[q - 1].append(p - 1)",
      "mutated_line": "e_list2[q + 1].append(p - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q + 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "e_list2[q - 1].append(p - 1)",
      "mutated_line": "e_list2[q * 1].append(p - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q * 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if color_list[v1] == -1:",
      "mutated_line": "if color_list[v1] == -2:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -2:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if color_list[v1] == -1:",
      "mutated_line": "if color_list[v1] == -0:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -0:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if color_list[v1] == -1:",
      "mutated_line": "if color_list[v1] == -0:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -0:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if color_list[v1] == -1:",
      "mutated_line": "if color_list[v1] == --1:",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == --1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "e_list1[p - 1].append(q - 1)",
      "mutated_line": "e_list1[p - 2].append(q - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 2].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "e_list1[p - 1].append(q - 1)",
      "mutated_line": "e_list1[p - 0].append(q - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 0].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "e_list1[p - 1].append(q - 1)",
      "mutated_line": "e_list1[p - 0].append(q - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 0].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "e_list1[p - 1].append(q - 1)",
      "mutated_line": "e_list1[p - -1].append(q - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - -1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "e_list1[q - 1].append(p - 1)",
      "mutated_line": "e_list1[q - 2].append(p - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 2].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "e_list1[q - 1].append(p - 1)",
      "mutated_line": "e_list1[q - 0].append(p - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 0].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "e_list1[q - 1].append(p - 1)",
      "mutated_line": "e_list1[q - 0].append(p - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 0].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "e_list1[q - 1].append(p - 1)",
      "mutated_line": "e_list1[q - -1].append(p - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - -1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "e_list2[p - 1].append(q - 1)",
      "mutated_line": "e_list2[p - 2].append(q - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 2].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "e_list2[p - 1].append(q - 1)",
      "mutated_line": "e_list2[p - 0].append(q - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 0].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "e_list2[p - 1].append(q - 1)",
      "mutated_line": "e_list2[p - 0].append(q - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 0].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "e_list2[p - 1].append(q - 1)",
      "mutated_line": "e_list2[p - -1].append(q - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - -1].append(q - 1)\n        e_list2[q - 1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "e_list2[q - 1].append(p - 1)",
      "mutated_line": "e_list2[q - 2].append(p - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 2].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "e_list2[q - 1].append(p - 1)",
      "mutated_line": "e_list2[q - 0].append(p - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 0].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "e_list2[q - 1].append(p - 1)",
      "mutated_line": "e_list2[q - 0].append(p - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - 0].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "e_list2[q - 1].append(p - 1)",
      "mutated_line": "e_list2[q - -1].append(p - 1)",
      "code": "from collections import deque, Counter\n\ndef count_connected_cities(N, K, L, roads, railways):\n\n    def BFS(vi, color, color_list, e_list):\n        Q = deque([vi])\n        color_list[vi] = color\n        while len(Q) > 0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if color_list[v1] == -1:\n                    color_list[v1] = color\n                    Q.appendleft(v1)\n        return color_list\n    e_list1 = [[] for _ in range(N)]\n    e_list2 = [[] for _ in range(N)]\n    for (p, q) in roads:\n        e_list1[p - 1].append(q - 1)\n        e_list1[q - 1].append(p - 1)\n    for (p, q) in railways:\n        e_list2[p - 1].append(q - 1)\n        e_list2[q - -1].append(p - 1)\n    color_list = [-1 for _ in range(N)]\n    color = 0\n    for i in range(N):\n        if color_list[i] == -1:\n            color_list = BFS(i, color, color_list, e_list1)\n            color += 1\n    color_list2 = [-1 for _ in range(N)]\n    color2 = 0\n    for i in range(N):\n        if color_list2[i] == -1:\n            color_list2 = BFS(i, color2, color_list2, e_list2)\n            color2 += 1\n    M = 1 + max(color_list)\n    color_list = [color_list[i] + M * color_list2[i] for i in range(N)]\n    counter = Counter(color_list)\n    ans = [counter[color_list[i]] for i in range(N)]\n    return ans"
    }
  ]
}