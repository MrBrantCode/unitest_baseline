{
  "task_id": "taco_4088",
  "entry_point": "minimize_moves_to_equalize_remainders",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cnt = [0] * m",
      "mutated_line": "cnt = [0] / m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] / m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cnt = [0] * m",
      "mutated_line": "cnt = [0] + m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] + m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "cnt = [0] * m",
      "mutated_line": "cnt = [0] ** m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] ** m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "cnt[ai] += 1",
      "mutated_line": "cnt[ai] -= 1",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] -= 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "l = n // m",
      "mutated_line": "l = n / m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n / m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "l = n // m",
      "mutated_line": "l = n * m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n * m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 1\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = -1\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 1\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ai = a[i] % m",
      "mutated_line": "ai = a[i] * m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] * m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ai = a[i] % m",
      "mutated_line": "ai = a[i] + m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] + m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cnt[ai] += 1",
      "mutated_line": "cnt[ai] += 2",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 2\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cnt[ai] += 1",
      "mutated_line": "cnt[ai] += 0",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 0\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cnt[ai] += 1",
      "mutated_line": "cnt[ai] += 0",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 0\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cnt[ai] += 1",
      "mutated_line": "cnt[ai] += -1",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += -1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if cnt[i] < l:",
      "mutated_line": "if cnt[i] <= l:",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] <= l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if cnt[i] < l:",
      "mutated_line": "if cnt[i] >= l:",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] >= l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if cnt[i] < l:",
      "mutated_line": "if cnt[i] != l:",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] != l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "cnt[k] += 1",
      "mutated_line": "cnt[k] -= 1",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] -= 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "cnt[i] -= 1",
      "mutated_line": "cnt[i] += 1",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] += 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "ans += (k - i) % m",
      "mutated_line": "ans -= (k - i) % m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans -= (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "a[j] += (k - i) % m",
      "mutated_line": "a[j] -= (k - i) % m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] -= (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cnt = [0] * m",
      "mutated_line": "cnt = [1] * m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [1] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cnt = [0] * m",
      "mutated_line": "cnt = [-1] * m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [-1] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cnt = [0] * m",
      "mutated_line": "cnt = [1] * m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [1] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if cnt[i] <= l:",
      "mutated_line": "if cnt[i] < l:",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] < l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if cnt[i] <= l:",
      "mutated_line": "if cnt[i] > l:",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] > l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if cnt[i] <= l:",
      "mutated_line": "if cnt[i] == l:",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] == l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while q[0] < i:",
      "mutated_line": "while q[0] <= i:",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] <= i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while q[0] < i:",
      "mutated_line": "while q[0] >= i:",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] >= i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while q[0] < i:",
      "mutated_line": "while q[0] != i:",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] != i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "k = q[0] % m",
      "mutated_line": "k = q[0] * m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] * m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "k = q[0] % m",
      "mutated_line": "k = q[0] + m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] + m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt[k] += 1",
      "mutated_line": "cnt[k] += 2",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 2\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt[k] += 1",
      "mutated_line": "cnt[k] += 0",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 0\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt[k] += 1",
      "mutated_line": "cnt[k] += 0",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 0\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "cnt[k] += 1",
      "mutated_line": "cnt[k] += -1",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += -1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt[i] -= 1",
      "mutated_line": "cnt[i] -= 2",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 2\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt[i] -= 1",
      "mutated_line": "cnt[i] -= 0",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 0\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt[i] -= 1",
      "mutated_line": "cnt[i] -= 0",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 0\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt[i] -= 1",
      "mutated_line": "cnt[i] -= -1",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= -1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ans += (k - i) % m",
      "mutated_line": "ans += (k - i) * m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) * m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ans += (k - i) % m",
      "mutated_line": "ans += k - i + m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += k - i + m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "a[j] += (k - i) % m",
      "mutated_line": "a[j] += (k - i) * m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) * m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "a[j] += (k - i) % m",
      "mutated_line": "a[j] += k - i + m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += k - i + m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if cnt[k] == l:",
      "mutated_line": "if cnt[k] != l:",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] != l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ans += (k - i) % m",
      "mutated_line": "ans += (k + i) % m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k + i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ans += (k - i) % m",
      "mutated_line": "ans += k * i % m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += k * i % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "a[j] += (k - i) % m",
      "mutated_line": "a[j] += (k + i) % m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k + i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "a[j] += (k - i) % m",
      "mutated_line": "a[j] += k * i % m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += k * i % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while q[0] < i:",
      "mutated_line": "while q[1] < i:",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[1] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while q[0] < i:",
      "mutated_line": "while q[-1] < i:",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[-1] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while q[0] < i:",
      "mutated_line": "while q[1] < i:",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[1] < i:\n                q.append(q.popleft() + m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "q.append(q.popleft() + m)",
      "mutated_line": "q.append(q.popleft() - m)",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() - m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "q.append(q.popleft() + m)",
      "mutated_line": "q.append(q.popleft() * m)",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() * m)\n            k = q[0] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "k = q[0] % m",
      "mutated_line": "k = q[1] % m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[1] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "k = q[0] % m",
      "mutated_line": "k = q[-1] % m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[-1] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "k = q[0] % m",
      "mutated_line": "k = q[1] % m",
      "code": "from collections import deque\n\ndef minimize_moves_to_equalize_remainders(n, m, a):\n    cnt = [0] * m\n    x = [[] for _ in range(m)]\n    for i in range(n):\n        ai = a[i] % m\n        cnt[ai] += 1\n        x[ai].append(i)\n    l = n // m\n    q = deque()\n    for i in range(m):\n        if cnt[i] < l:\n            q.append(i)\n    ans = 0\n    for i in range(m):\n        for j in x[i]:\n            if cnt[i] <= l:\n                break\n            while q[0] < i:\n                q.append(q.popleft() + m)\n            k = q[1] % m\n            cnt[k] += 1\n            cnt[i] -= 1\n            ans += (k - i) % m\n            a[j] += (k - i) % m\n            if cnt[k] == l:\n                q.popleft()\n    return (ans, a)"
    }
  ]
}