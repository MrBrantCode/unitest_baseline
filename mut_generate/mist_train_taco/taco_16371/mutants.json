{
  "task_id": "taco_16371",
  "entry_point": "min_steps_to_reach_target",
  "mutant_count": 176,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if knight_pos == target_pos:",
      "mutated_line": "if knight_pos != target_pos:",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos != target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[knight_pos[0]][knight_pos[1]] = 0",
      "mutated_line": "vis[knight_pos[0]][knight_pos[1]] = 1",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 1\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[knight_pos[0]][knight_pos[1]] = 0",
      "mutated_line": "vis[knight_pos[0]][knight_pos[1]] = -1",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = -1\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[knight_pos[0]][knight_pos[1]] = 0",
      "mutated_line": "vis[knight_pos[0]][knight_pos[1]] = 1",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 1\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return +1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] / (N + 1) for _ in range(N + 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] / (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] + (N + 1) for _ in range(N + 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] + (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] ** (N + 1) for _ in range(N + 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] ** (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 1\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return -1\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 1\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return --1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] * (N - 1) for _ in range(N + 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N - 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] * (N * 1) for _ in range(N + 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N * 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(3, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(3, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(1, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(1, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(0, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(0, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(1, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(1, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(-2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(-2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 2), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 2), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 0), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 0), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 0), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 0), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, -1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, -1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (3, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (3, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (1, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (1, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (0, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (0, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (1, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (1, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (-2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (-2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, +1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, +1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (+2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (+2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 2), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 2), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 0), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 0), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 0), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 0), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, -1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, -1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (+2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (+2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, +1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, +1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (2, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (2, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (0, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (0, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (0, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (0, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (-1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (-1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 3), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 3), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 1), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 1), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 0), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 0), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 1), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 1), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, -2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, -2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (2, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (2, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (0, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (0, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (0, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (0, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (-1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (-1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, +2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, +2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (+1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (+1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, +2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, +2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (+1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (+1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 3)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 3)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 1)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 0)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 0)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 1)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, -2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, -2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [(knight_pos[0], knight_pos[1], 0)]",
      "mutated_line": "q = [(knight_pos[0], knight_pos[1], 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 1)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [(knight_pos[0], knight_pos[1], 0)]",
      "mutated_line": "q = [(knight_pos[0], knight_pos[1], -1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], -1)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [(knight_pos[0], knight_pos[1], 0)]",
      "mutated_line": "q = [(knight_pos[0], knight_pos[1], 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 1)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[knight_pos[0]][knight_pos[1]] = 0",
      "mutated_line": "vis[knight_pos[0]][knight_pos[2]] = 0",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[2]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[knight_pos[0]][knight_pos[1]] = 0",
      "mutated_line": "vis[knight_pos[0]][knight_pos[0]] = 0",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[0]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[knight_pos[0]][knight_pos[1]] = 0",
      "mutated_line": "vis[knight_pos[0]][knight_pos[0]] = 0",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[0]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[knight_pos[0]][knight_pos[1]] = 0",
      "mutated_line": "vis[knight_pos[0]][knight_pos[-1]] = 0",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[-1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x, y, step = q.pop(0)",
      "mutated_line": "(x, y, step) = q.pop(1)",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(1)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x, y, step = q.pop(0)",
      "mutated_line": "(x, y, step) = q.pop(-1)",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(-1)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "x, y, step = q.pop(0)",
      "mutated_line": "(x, y, step) = q.pop(1)",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(1)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "r = x + dx",
      "mutated_line": "r = x - dx",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x - dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "r = x + dx",
      "mutated_line": "r = x * dx",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x * dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "c = y + dy",
      "mutated_line": "c = y - dy",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y - dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "c = y + dy",
      "mutated_line": "c = y * dy",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y * dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if (r, c) == target_pos:",
      "mutated_line": "if (r, c) != target_pos:",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) != target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 <= r <= N or 1 <= c <= N or vis[r][c] == -1:",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N or 1 <= c <= N or vis[r][c] == -1:\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[+1] * (N + 1) for _ in range(N + 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[+1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] * (N + 2) for _ in range(N + 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 2) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] * (N + 0) for _ in range(N + 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 0) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] * (N + 0) for _ in range(N + 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 0) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] * (N + -1) for _ in range(N + 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + -1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] * (N + 1) for _ in range(N - 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N - 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] * (N + 1) for _ in range(N * 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N * 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -2), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -2), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -0), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -0), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -0), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -0), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, --1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, --1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-3, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-3, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-1, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-1, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-0, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-0, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-1, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-1, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (--2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (--2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-3, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-3, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-1, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-1, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-0, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-0, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-1, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-1, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (--2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (--2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -2), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -2), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -0), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -0), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -0), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -0), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "(2, 1), (2, -1), (-2, 1), (-2, -1),",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, --1), (1, 2), (1, -2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, --1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -3), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -3), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -1), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -1), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -0), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -0), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -1), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -1), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, --2), (-1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, --2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-2, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-2, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-0, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-0, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-0, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-0, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (--1, -2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (--1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -3), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -3), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -1), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -1), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -0), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -0), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -1), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -1), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, --2), (-1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, --2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-2, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-2, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-0, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-0, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-0, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-0, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "(1, 2), (1, -2), (-1, -2), (-1, 2)",
      "mutated_line": "moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (--1, 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (--1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [(knight_pos[0], knight_pos[1], 0)]",
      "mutated_line": "q = [(knight_pos[1], knight_pos[1], 0)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[1], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [(knight_pos[0], knight_pos[1], 0)]",
      "mutated_line": "q = [(knight_pos[-1], knight_pos[1], 0)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[-1], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [(knight_pos[0], knight_pos[1], 0)]",
      "mutated_line": "q = [(knight_pos[1], knight_pos[1], 0)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[1], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [(knight_pos[0], knight_pos[1], 0)]",
      "mutated_line": "q = [(knight_pos[0], knight_pos[2], 0)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[2], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [(knight_pos[0], knight_pos[1], 0)]",
      "mutated_line": "q = [(knight_pos[0], knight_pos[0], 0)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[0], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [(knight_pos[0], knight_pos[1], 0)]",
      "mutated_line": "q = [(knight_pos[0], knight_pos[0], 0)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[0], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [(knight_pos[0], knight_pos[1], 0)]",
      "mutated_line": "q = [(knight_pos[0], knight_pos[-1], 0)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[-1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[knight_pos[0]][knight_pos[1]] = 0",
      "mutated_line": "vis[knight_pos[1]][knight_pos[1]] = 0",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[1]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[knight_pos[0]][knight_pos[1]] = 0",
      "mutated_line": "vis[knight_pos[-1]][knight_pos[1]] = 0",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[-1]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[knight_pos[0]][knight_pos[1]] = 0",
      "mutated_line": "vis[knight_pos[1]][knight_pos[1]] = 0",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[1]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return step + 1",
      "mutated_line": "return step - 1",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step - 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return step + 1",
      "mutated_line": "return step * 1",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step * 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 < r <= N and 1 <= c <= N and (vis[r][c] == -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 < r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 > r <= N and 1 <= c <= N and (vis[r][c] == -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 > r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 == r <= N and 1 <= c <= N and (vis[r][c] == -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 == r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 <= r <= N and 1 < c <= N and (vis[r][c] == -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 < c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 <= r <= N and 1 > c <= N and (vis[r][c] == -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 > c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 <= r <= N and 1 == c <= N and (vis[r][c] == -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 == c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 <= r <= N and 1 <= c <= N and (vis[r][c] != -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] != -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "vis[r][c] = step + 1",
      "mutated_line": "vis[r][c] = step - 1",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step - 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "vis[r][c] = step + 1",
      "mutated_line": "vis[r][c] = step * 1",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step * 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-2] * (N + 1) for _ in range(N + 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-2] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-0] * (N + 1) for _ in range(N + 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-0] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-0] * (N + 1) for _ in range(N + 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-0] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[--1] * (N + 1) for _ in range(N + 1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[--1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] * (N + 1) for _ in range(N + 2)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 2)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] * (N + 1) for _ in range(N + 0)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 0)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] * (N + 1) for _ in range(N + 0)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 0)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis = [[-1] * (N + 1) for _ in range(N + 1)]",
      "mutated_line": "vis = [[-1] * (N + 1) for _ in range(N + -1)]",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + -1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return step + 1",
      "mutated_line": "return step + 2",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 2\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return step + 1",
      "mutated_line": "return step + 0",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 0\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return step + 1",
      "mutated_line": "return step + 0",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 0\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return step + 1",
      "mutated_line": "return step + -1",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + -1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 2 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 2 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 0 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 0 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 0 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 0 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if -1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if -1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 <= r <= N and 2 <= c <= N and (vis[r][c] == -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 2 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 <= r <= N and 0 <= c <= N and (vis[r][c] == -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 0 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 <= r <= N and 0 <= c <= N and (vis[r][c] == -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 0 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 <= r <= N and -1 <= c <= N and (vis[r][c] == -1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and -1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == +1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == +1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vis[r][c] = step + 1",
      "mutated_line": "vis[r][c] = step + 2",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vis[r][c] = step + 1",
      "mutated_line": "vis[r][c] = step + 0",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vis[r][c] = step + 1",
      "mutated_line": "vis[r][c] = step + 0",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 0\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "vis[r][c] = step + 1",
      "mutated_line": "vis[r][c] = step + -1",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + -1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -2):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -2):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -0):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -0):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -0):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -0):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if 1 <= r <= N and 1 <= c <= N and vis[r][c] == -1:",
      "mutated_line": "if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == --1):",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == --1):\n                q.append((r, c, step + 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "q.append((r, c, step + 1))",
      "mutated_line": "q.append((r, c, step - 1))",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step - 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "q.append((r, c, step + 1))",
      "mutated_line": "q.append((r, c, step * 1))",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step * 1))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "q.append((r, c, step + 1))",
      "mutated_line": "q.append((r, c, step + 2))",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 2))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "q.append((r, c, step + 1))",
      "mutated_line": "q.append((r, c, step + 0))",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 0))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "q.append((r, c, step + 1))",
      "mutated_line": "q.append((r, c, step + 0))",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + 0))\n                vis[r][c] = step + 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "q.append((r, c, step + 1))",
      "mutated_line": "q.append((r, c, step + -1))",
      "code": "def min_steps_to_reach_target(knight_pos, target_pos, N):\n    vis = [[-1] * (N + 1) for _ in range(N + 1)]\n    if knight_pos == target_pos:\n        return 0\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, -2), (-1, 2)]\n    q = [(knight_pos[0], knight_pos[1], 0)]\n    vis[knight_pos[0]][knight_pos[1]] = 0\n    while q:\n        (x, y, step) = q.pop(0)\n        for (dx, dy) in moves:\n            r = x + dx\n            c = y + dy\n            if (r, c) == target_pos:\n                return step + 1\n            if 1 <= r <= N and 1 <= c <= N and (vis[r][c] == -1):\n                q.append((r, c, step + -1))\n                vis[r][c] = step + 1\n    return -1"
    }
  ]
}